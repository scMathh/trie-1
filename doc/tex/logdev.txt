commit 9aa5edde767e93157a9ece4b031316167fcf50e6
Author: Joilnen <joilnen@gmail.com>
Date:   Thu Dec 16 00:03:59 2021 -0300

    trabalho de ed2

diff --git a/.gitignore b/.gitignore
new file mode 100644
index 0000000..c442bb3
--- /dev/null
+++ b/.gitignore
@@ -0,0 +1,6 @@
+*.sw*
+*~
+*.o
+*.d
+tags
+rodeme
diff --git a/doc/spec.txt b/doc/spec.txt
new file mode 100644
index 0000000..9ceb8b9
--- /dev/null
+++ b/doc/spec.txt
@@ -0,0 +1,15 @@
+TAD Conjunto Ordenado utilizando a estrutura árvore Rubro-Negra para tipos de dados genéricos.
+deve ser implementado para tipos de dados genéricos
+ o programador, usuário da biblioteca, define o tipo dos elementos do conjunto.
+ • Imprimir os elementos de um conjunto.
+ • Cardinalidade de um conjunto 
+ • Verificar se um conjunto é vazio.
+ • Esvaziar conjunto:
+ • Inserir um novo elemento em um conjunto (não deve existir elementos repetidos no conjunto).
+ • Excluir um elemento de um conjunto.
+ • Verificar se um elemento pertence ao conjunto.
+
+A intesec B
+A uniao B
+A menos B
+Impressao da arvore chave seguida da cor
diff --git a/src/Makefile b/src/Makefile
new file mode 100644
index 0000000..4c47828
--- /dev/null
+++ b/src/Makefile
@@ -0,0 +1,16 @@
+#
+# Aluno: Joilnen Leite
+#
+
+C=gcc
+S=main.c conjunto_ordenado.c
+O=main.c conjunto_ordenado.o
+B=rodeme
+
+.c.o:
+	$(C) -c $<
+all: main.o conjunto_ordenado.o
+	$(C) -o $(B) $(O)
+clean:
+	rm -f *.o $(B)
+
diff --git a/src/conjunto_ordenado.c b/src/conjunto_ordenado.c
new file mode 100644
index 0000000..da7183d
--- /dev/null
+++ b/src/conjunto_ordenado.c
@@ -0,0 +1,112 @@
+#include "conjunto_ordenado.h"
+
+int imprime_conjunto(rb_n *a)
+{
+
+    return 0;
+}
+
+unsigned int cardinalidade(rb_n *a)
+{
+
+    return 0;
+}
+
+int ta_vazio(rb_n *a)
+{
+
+    return 0;
+}
+
+int limpa_conjunto(rb_n *a)
+{
+
+    return 0;
+}
+
+int insere_elemento(rb_n *a, int k, void *e)
+{
+
+    return 0;
+}
+
+int exclui_elemento(rb_n *a, int k)
+{
+
+    return 0;
+}
+
+int verifica_pertencimento(rb_n *a, int k)
+{
+
+    return 0;
+}
+
+rb_n* intersecta_conjuntos(rb_n *a, rb_n *b)
+{
+
+    return NULL;
+}
+
+rb_n* une_conjuntos(rb_n *a, rb_n *b)
+{
+
+    return NULL;
+}
+
+rb_n* subtrai_conjuntos(rb_n *a, rb_n *b)
+{
+    return NULL;
+}
+
+int destroi_conjunto(rb_n *a)
+{
+
+    return 0;
+}
+
+int rotaciona_esquerda(rb_n *r, rb_n *w)
+{
+    rb_n *v = w->r;
+    w->r = v->l;
+    if (v->l)
+        v->l->p = w;
+    v->p = w->p;
+    if (!w->p)
+        r = v;
+    else
+    {
+        if (w == w->p->l)
+            w->p->l = v;
+        else
+            w->p->r = v;
+    }
+    v->l = w;
+    w->p = v;
+
+    return 0;
+}
+
+int rotaciona_direita(rb_n *r, rb_n *w)
+{
+    rb_n *v = w->l;
+    w->l = v->r;
+    if (v->r)
+        v->r->p = w;
+    v->p = w->p;
+    if (!w->p)
+        r = v;
+    else
+    {
+        if (w == w->p->r)
+            w->p->r = v;
+        else
+            w->p->l = v;
+    }
+    v->r = w;
+    w->p = v;
+
+    return 0;
+}
+
+
diff --git a/src/conjunto_ordenado.h b/src/conjunto_ordenado.h
new file mode 100644
index 0000000..8bcfb59
--- /dev/null
+++ b/src/conjunto_ordenado.h
@@ -0,0 +1,56 @@
+#ifndef CONJUNTO_ORDENADO_H
+#define CONJUNTO_ORDENADO_H
+
+/**
+ * Rubro Negra
+ * 0 - todo noh eh vermelho ou preto
+ * 1 - raiz sempre preta
+ * 2 - noh NULL considerado noh externo preto
+ * 3 - vermelhos tem filhos pretos
+ * 4 - noh para suas folhas tem o mesmo numero de nohs preto
+ */
+
+/**
+ * Composicao do noh da RB, apenas a parte 
+ * @rb_n noh red black
+ * @k chave (k de key)
+ * @c cor (c de color ou cor, 0-black, 1-red)
+ * @d dados (de de data ou dados)
+ * @l @r @p l-eft filho a esquerda, r-ight filho a direta e p-arent, noh pai
+ */
+
+#include <stdlib.h>
+
+typedef struct rb_n {
+    int k;
+    char c:1;
+    void *d;
+    struct rb_n *l, *r, *p;
+} rb_n;
+
+#define CRIA_CONJUNTO_ORDENDADO(a) \
+    rb_n a; \
+    a.c = 0; \
+    a.p = a.l = a.r = NULL;
+
+int imprime_conjunto(rb_n *a);
+unsigned int cardinalidade(rb_n *a);
+int ta_vazio(rb_n *a);
+int limpa_conjunto(rb_n *a);
+
+int insere_elemento(rb_n *a, int k, void *e);
+int exclui_elemento(rb_n *a, int k);
+int verifica_pertencimento(rb_n *a, int k);
+
+rb_n* intersecta_conjuntos(rb_n *a, rb_n *b);
+rb_n* une_conjuntos(rb_n *a, rb_n *b);
+rb_n* subtrai_conjuntos(rb_n *a, rb_n *b);
+
+int destroi_conjunto(rb_n *a);
+
+int troca_cor(rb_n *a);
+int rotaciona_esquerda(rb_n *r, rb_n *w);
+int rotaciona_direita(rb_n *r, rb_n *w);
+
+#endif
+
diff --git a/src/main.c b/src/main.c
new file mode 100644
index 0000000..ed6c969
--- /dev/null
+++ b/src/main.c
@@ -0,0 +1,13 @@
+/***
+ * Aluno: Joilnen Leite
+ */
+#include "conjunto_ordenado.h"
+
+int main()
+{
+    CRIA_CONJUNTO_ORDENDADO(conjunto_a);
+
+
+}
+
+

commit dd1c9e21c5f930ad2c25712d0ae3c4417b882bf5
Author: Joilnen <joilnen@gmail.com>
Date:   Thu Dec 16 04:41:33 2021 -0300

    codificando como serah estipulado o tipo de dados

diff --git a/src/conjunto_ordenado.c b/src/conjunto_ordenado.c
index da7183d..9f6ff26 100644
--- a/src/conjunto_ordenado.c
+++ b/src/conjunto_ordenado.c
@@ -1,3 +1,7 @@
+/**
+ * aluno: joilnen leite
+ */
+
 #include "conjunto_ordenado.h"
 
 int imprime_conjunto(rb_n *a)
@@ -26,7 +30,20 @@ int limpa_conjunto(rb_n *a)
 
 int insere_elemento(rb_n *a, int k, void *e)
 {
-
+    rb_n *it = a;
+    while (it)
+    {
+        if (k < it->k)
+            it = it->l;
+        else if (k > it->k)
+            it = it->r;
+        if (!it)
+        {
+            it = e;
+            it->k = k;
+            it->l = it->r = NULL;
+        }
+    }
     return 0;
 }
 
diff --git a/src/conjunto_ordenado.h b/src/conjunto_ordenado.h
index 8bcfb59..3d839ee 100644
--- a/src/conjunto_ordenado.h
+++ b/src/conjunto_ordenado.h
@@ -1,6 +1,10 @@
 #ifndef CONJUNTO_ORDENADO_H
 #define CONJUNTO_ORDENADO_H
 
+/**
+ * aluno: joilnen leite
+ */
+
 /**
  * Rubro Negra
  * 0 - todo noh eh vermelho ou preto
@@ -15,6 +19,7 @@
  * @rb_n noh red black
  * @k chave (k de key)
  * @c cor (c de color ou cor, 0-black, 1-red)
+ * @t tipo (t de tipo ou type)
  * @d dados (de de data ou dados)
  * @l @r @p l-eft filho a esquerda, r-ight filho a direta e p-arent, noh pai
  */
@@ -28,9 +33,10 @@ typedef struct rb_n {
     struct rb_n *l, *r, *p;
 } rb_n;
 
-#define CRIA_CONJUNTO_ORDENDADO(a) \
+#define CRIA_CONJUNTO_ORDENDADO(a, dado) \
     rb_n a; \
     a.c = 0; \
+    a.d = &dado; \
     a.p = a.l = a.r = NULL;
 
 int imprime_conjunto(rb_n *a);
@@ -52,5 +58,7 @@ int troca_cor(rb_n *a);
 int rotaciona_esquerda(rb_n *r, rb_n *w);
 int rotaciona_direita(rb_n *r, rb_n *w);
 
+int seta_imprime(void (*imprime_elemento)(rb_n *n));
+
 #endif
 
diff --git a/src/main.c b/src/main.c
index ed6c969..f8dc951 100644
--- a/src/main.c
+++ b/src/main.c
@@ -5,7 +5,8 @@
 
 int main()
 {
-    CRIA_CONJUNTO_ORDENDADO(conjunto_a);
+    char letra = 'a';
+    CRIA_CONJUNTO_ORDENDADO(conjunto_a, letra);
 
 
 }

commit cc53fc091c7f75af80b167978ab1a14f6fc801d0
Author: Joilnen <joilnen@gmail.com>
Date:   Thu Dec 16 05:16:35 2021 -0300

    criando funcoes de impressao setada pelo cliente

diff --git a/src/conjunto_ordenado.c b/src/conjunto_ordenado.c
index 9f6ff26..f7a995c 100644
--- a/src/conjunto_ordenado.c
+++ b/src/conjunto_ordenado.c
@@ -4,6 +4,8 @@
 
 #include "conjunto_ordenado.h"
 
+void (*imprime_elemento)(rb_n *);
+
 int imprime_conjunto(rb_n *a)
 {
 
@@ -126,4 +128,9 @@ int rotaciona_direita(rb_n *r, rb_n *w)
     return 0;
 }
 
+int seta_imprime(void (*i)(rb_n *n))
+{
+    imprime_elemento = i;
+}
+
 
diff --git a/src/conjunto_ordenado.h b/src/conjunto_ordenado.h
index 3d839ee..44b686b 100644
--- a/src/conjunto_ordenado.h
+++ b/src/conjunto_ordenado.h
@@ -58,7 +58,8 @@ int troca_cor(rb_n *a);
 int rotaciona_esquerda(rb_n *r, rb_n *w);
 int rotaciona_direita(rb_n *r, rb_n *w);
 
-int seta_imprime(void (*imprime_elemento)(rb_n *n));
+extern void (*imprime_elemento)(rb_n *);
+int seta_imprime(void (*i)(rb_n *n));
 
 #endif
 
diff --git a/src/main.c b/src/main.c
index f8dc951..251026e 100644
--- a/src/main.c
+++ b/src/main.c
@@ -1,12 +1,49 @@
 /***
- * Aluno: Joilnen Leite
+ * aluno: joilnen leite
+ */
+/**
+ * inclusao da bilioteca implementada baseada em arvores red black
  */
 #include "conjunto_ordenado.h"
 
+/**
+ * funcao  de impressao do dipo especifico criado pelo o usuario da biblioteca
+ * @noh rb
+ */
+void imprime_meu_tipo(rb_n *);
+
+/**
+ * funcao main de teste separada do codigo da biblioteca como especificado
+ */
 int main()
 {
-    char letra = 'a';
-    CRIA_CONJUNTO_ORDENDADO(conjunto_a, letra);
+    /**
+     * definicao de um tipo exemplo pelo o usuario
+     */
+    typedef struct {
+        char letra;
+    } meu_tipo;
+    meu_tipo mt;
+
+    /**
+     * criacao do dado para o tipo do usuario
+     */
+    mt.letra = 'a';
+
+    /**
+     * seta a funcao para impressao utiliza aqui a tecnica de ponteiro para funcao
+     */
+    seta_imprime(imprime_meu_tipo);
+
+    /**
+     * cria noh raiz, utiliza a tecnica de macro pois simplifica e deixa
+     * uma interface mais intuitiva ao usuario da biblioteca
+     */
+    CRIA_CONJUNTO_ORDENDADO(conjunto_a, mt);
+}
+
+void imprime_meu_tipo(rb_n *n)
+{
 
 
 }

commit 833960f5389fd02becfc02e1083ceab3899a9f24
Author: Joilnen <joilnen@gmail.com>
Date:   Thu Dec 16 05:19:03 2021 -0300

    adicionado comentario a definicao de funcao, comentando tando declaracao
    cabecalhos como definicoes

diff --git a/src/main.c b/src/main.c
index 251026e..9d40f24 100644
--- a/src/main.c
+++ b/src/main.c
@@ -42,6 +42,10 @@ int main()
     CRIA_CONJUNTO_ORDENDADO(conjunto_a, mt);
 }
 
+/**
+ * definicao da funcao de impressao estipulado pelo cliente, aqui apenas um
+ * exemplo
+ */
 void imprime_meu_tipo(rb_n *n)
 {
 

commit 9f1ce14043c169c8e0c170d7a40b6f153aade3a8
Author: Joilnen <joilnen@gmail.com>
Date:   Thu Dec 16 05:25:13 2021 -0300

    usando um nome melhor seta_imprime_elemento

diff --git a/src/conjunto_ordenado.c b/src/conjunto_ordenado.c
index f7a995c..40f65e1 100644
--- a/src/conjunto_ordenado.c
+++ b/src/conjunto_ordenado.c
@@ -128,7 +128,7 @@ int rotaciona_direita(rb_n *r, rb_n *w)
     return 0;
 }
 
-int seta_imprime(void (*i)(rb_n *n))
+int seta_imprime_elemento(void (*i)(rb_n *n))
 {
     imprime_elemento = i;
 }
diff --git a/src/conjunto_ordenado.h b/src/conjunto_ordenado.h
index 44b686b..e084108 100644
--- a/src/conjunto_ordenado.h
+++ b/src/conjunto_ordenado.h
@@ -6,7 +6,7 @@
  */
 
 /**
- * Rubro Negra
+ * rubro negra
  * 0 - todo noh eh vermelho ou preto
  * 1 - raiz sempre preta
  * 2 - noh NULL considerado noh externo preto
@@ -15,15 +15,14 @@
  */
 
 /**
- * Composicao do noh da RB, apenas a parte 
+ * composicao do noh da RB
  * @rb_n noh red black
  * @k chave (k de key)
  * @c cor (c de color ou cor, 0-black, 1-red)
  * @t tipo (t de tipo ou type)
- * @d dados (de de data ou dados)
+ * @d dado (de de data ou dados)
  * @l @r @p l-eft filho a esquerda, r-ight filho a direta e p-arent, noh pai
  */
-
 #include <stdlib.h>
 
 typedef struct rb_n {
@@ -59,7 +58,8 @@ int rotaciona_esquerda(rb_n *r, rb_n *w);
 int rotaciona_direita(rb_n *r, rb_n *w);
 
 extern void (*imprime_elemento)(rb_n *);
-int seta_imprime(void (*i)(rb_n *n));
+int seta_imprime_elemento(void (*i)(rb_n *n));
 
 #endif
 
+
diff --git a/src/main.c b/src/main.c
index 9d40f24..65afc58 100644
--- a/src/main.c
+++ b/src/main.c
@@ -33,7 +33,7 @@ int main()
     /**
      * seta a funcao para impressao utiliza aqui a tecnica de ponteiro para funcao
      */
-    seta_imprime(imprime_meu_tipo);
+    seta_imprime_elemento(imprime_meu_tipo);
 
     /**
      * cria noh raiz, utiliza a tecnica de macro pois simplifica e deixa

commit e5821185616c3a11f9b74159e21f84b70a40fcb0
Author: Joilnen <joilnen@gmail.com>
Date:   Thu Dec 16 05:26:26 2021 -0300

    cosmetico

diff --git a/src/conjunto_ordenado.c b/src/conjunto_ordenado.c
index 40f65e1..e66183c 100644
--- a/src/conjunto_ordenado.c
+++ b/src/conjunto_ordenado.c
@@ -1,7 +1,6 @@
 /**
  * aluno: joilnen leite
  */
-
 #include "conjunto_ordenado.h"
 
 void (*imprime_elemento)(rb_n *);

commit df0a1689321c768d19059b441654168d9050b512
Author: Joilnen <joilnen@gmail.com>
Date:   Thu Dec 16 05:32:18 2021 -0300

    mudancas cosmeticas em um comentario

diff --git a/src/conjunto_ordenado.c b/src/conjunto_ordenado.c
index e66183c..939de06 100644
--- a/src/conjunto_ordenado.c
+++ b/src/conjunto_ordenado.c
@@ -1,5 +1,7 @@
 /**
  * aluno: joilnen leite
+ * arquivo separado do main, como especificado 
+ * de implementacao das funcoes da biblioteca conjunto ordenado
  */
 #include "conjunto_ordenado.h"
 

commit 9db7458625c8897a3f131e320a6c1a2538a2d75c
Author: Joilnen <joilnen@gmail.com>
Date:   Thu Dec 16 06:03:29 2021 -0300

    adicionado instrucoes e modificado o padrao do makefile para o mostrado em aula

diff --git a/LEIAME b/LEIAME
new file mode 100644
index 0000000..17b9ab4
--- /dev/null
+++ b/LEIAME
@@ -0,0 +1,11 @@
+dentro do diretorio docs estao relatorios e arquivos
+relacionados ao processo de desenvolvimento
+
+binario sera gerado no mesmo diretorio dos fontes,
+src, atraves do comando make local
+dentro daquele diretorio, binario nomeado, rodeme
+comando a ser utilizado 
+
+make # para criar o binario
+make clean # para limpar, apagar objetos e binario
+
diff --git a/src/Makefile b/src/makefile
similarity index 100%
rename from src/Makefile
rename to src/makefile

commit 8cc3261a0a8eccbe89725c0706a0e837b58807c3
Author: Joilnen <joilnen@gmail.com>
Date:   Thu Dec 16 09:13:11 2021 -0300

    adicionado alguns dados para teste no arquivo main.c

diff --git a/src/conjunto_ordenado.h b/src/conjunto_ordenado.h
index e084108..aa30f43 100644
--- a/src/conjunto_ordenado.h
+++ b/src/conjunto_ordenado.h
@@ -32,8 +32,9 @@ typedef struct rb_n {
     struct rb_n *l, *r, *p;
 } rb_n;
 
-#define CRIA_CONJUNTO_ORDENDADO(a, dado) \
+#define CRIA_CONJUNTO_ORDENDADO(a, key, dado) \
     rb_n a; \
+    a.k = key; \
     a.c = 0; \
     a.d = &dado; \
     a.p = a.l = a.r = NULL;
diff --git a/src/main.c b/src/main.c
index 65afc58..941ff61 100644
--- a/src/main.c
+++ b/src/main.c
@@ -1,10 +1,12 @@
-/***
+/**
  * aluno: joilnen leite
  */
+
 /**
  * inclusao da bilioteca implementada baseada em arvores red black
  */
 #include "conjunto_ordenado.h"
+#include <string.h>
 
 /**
  * funcao  de impressao do dipo especifico criado pelo o usuario da biblioteca
@@ -12,23 +14,50 @@
  */
 void imprime_meu_tipo(rb_n *);
 
+/**
+ * funcao que adiciona alguns dados de teste
+ */
+void adiciona_alguns_dados();
+
 /**
  * funcao main de teste separada do codigo da biblioteca como especificado
  */
 int main()
+{
+    adiciona_alguns_dados();
+}
+
+/**
+ * definicao da funcao de impressao estipulado pelo cliente, aqui apenas um
+ * exemplo
+ */
+void imprime_meu_tipo(rb_n *n)
+{
+
+
+}
+
+/**
+ * funcao que adiciona alguns dados de teste
+ */
+void adiciona_alguns_dados()
 {
     /**
      * definicao de um tipo exemplo pelo o usuario
      */
     typedef struct {
-        char letra;
+        char *nome;
+        char *telefone;
     } meu_tipo;
     meu_tipo mt;
 
     /**
      * criacao do dado para o tipo do usuario
      */
-    mt.letra = 'a';
+    mt.nome = (char *) malloc(sizeof("nome para teste") + 1);
+    strncpy(mt.nome, "nome para teste", sizeof("nome para teste") + 1);
+    mt.telefone = (char *) malloc(sizeof("999999999") + 1);
+    strncpy(mt.telefone, "999999999", sizeof("999999999") + 1);
 
     /**
      * seta a funcao para impressao utiliza aqui a tecnica de ponteiro para funcao
@@ -38,18 +67,11 @@ int main()
     /**
      * cria noh raiz, utiliza a tecnica de macro pois simplifica e deixa
      * uma interface mais intuitiva ao usuario da biblioteca
+     * @parametro 0 nome variavel do noh raiz
+     * @parametro 1 chave do noh raiz
+     * @parametro 2 dado criado neste noh, pode ser de qqr tipo
      */
-    CRIA_CONJUNTO_ORDENDADO(conjunto_a, mt);
-}
-
-/**
- * definicao da funcao de impressao estipulado pelo cliente, aqui apenas um
- * exemplo
- */
-void imprime_meu_tipo(rb_n *n)
-{
-
-
+    CRIA_CONJUNTO_ORDENDADO(conjunto_a, 1, mt);
 }
 
 

commit 0f24a3c6a52d925c62c1bf6ab19043f2313f35a7
Author: Joilnen <joilnen@gmail.com>
Date:   Thu Dec 16 11:31:03 2021 -0300

    rearrumando as funcoes no .h

diff --git a/src/conjunto_ordenado.h b/src/conjunto_ordenado.h
index aa30f43..d14b82e 100644
--- a/src/conjunto_ordenado.h
+++ b/src/conjunto_ordenado.h
@@ -4,6 +4,7 @@
 /**
  * aluno: joilnen leite
  */
+#include <stdlib.h>
 
 /**
  * rubro negra
@@ -23,8 +24,6 @@
  * @d dado (de de data ou dados)
  * @l @r @p l-eft filho a esquerda, r-ight filho a direta e p-arent, noh pai
  */
-#include <stdlib.h>
-
 typedef struct rb_n {
     int k;
     char c:1;
@@ -32,6 +31,9 @@ typedef struct rb_n {
     struct rb_n *l, *r, *p;
 } rb_n;
 
+/**
+ * cria o primeiro noh, o raiz da arvore rb
+ */
 #define CRIA_CONJUNTO_ORDENDADO(a, key, dado) \
     rb_n a; \
     a.k = key; \

commit da567c4af9c079722d2141fe10d23c5d64bcf210
Author: Joilnen <joilnen@gmail.com>
Date:   Thu Dec 16 16:11:40 2021 -0300

    implementando insere noh na rb e modelo do relatorio adicionado

diff --git a/.gitignore b/.gitignore
index c442bb3..0446a97 100644
--- a/.gitignore
+++ b/.gitignore
@@ -4,3 +4,4 @@
 *.d
 tags
 rodeme
+latex.out
diff --git a/doc/tex/fig/golpatterns.png b/doc/tex/fig/golpatterns.png
new file mode 100644
index 0000000..1738c62
Binary files /dev/null and b/doc/tex/fig/golpatterns.png differ
diff --git a/doc/tex/fig/lista.png b/doc/tex/fig/lista.png
new file mode 100644
index 0000000..a674c6c
Binary files /dev/null and b/doc/tex/fig/lista.png differ
diff --git a/doc/tex/fig/ontologia.pdf b/doc/tex/fig/ontologia.pdf
new file mode 100644
index 0000000..f0041bc
Binary files /dev/null and b/doc/tex/fig/ontologia.pdf differ
diff --git a/doc/tex/fig/ontologia1.eps b/doc/tex/fig/ontologia1.eps
new file mode 100644
index 0000000..caa2853
--- /dev/null
+++ b/doc/tex/fig/ontologia1.eps
@@ -0,0 +1,831 @@
+%!PS-Adobe-3.0 EPSF-3.0
+%%Title: ontologia_diagrama_bkp.fig
+%%Creator: fig2dev Version 3.2.7b
+%%CreationDate: 2020-12-11 09:20:12
+%%BoundingBox: 0 0 409 369
+%%Magnification: 1.0000
+%%EndComments
+%%BeginProlog
+/$F2psDict 200 dict def
+$F2psDict begin
+$F2psDict /mtrx matrix put
+/col-1 {0 setgray} bind def
+/col0 {0.000 0.000 0.000 srgb} bind def
+/col7 {1.000 1.000 1.000 srgb} bind def
+/col16 {0.000 0.690 0.690 srgb} bind def
+/col27 {1.000 0.500 0.500 srgb} bind def
+/col29 {1.000 0.750 0.750 srgb} bind def
+
+end
+
+/cp {closepath} bind def
+/ef {eofill} bind def
+/gr {grestore} bind def
+/gs {gsave} bind def
+/sa {save} bind def
+/rs {restore} bind def
+/l {lineto} bind def
+/rl {rlineto} bind def
+/m {moveto} bind def
+/rm {rmoveto} bind def
+/n {newpath} bind def
+/s {stroke} bind def
+/sh {show} bind def
+/slc {setlinecap} bind def
+/slj {setlinejoin} bind def
+/slw {setlinewidth} bind def
+/srgb {setrgbcolor} bind def
+/rot {rotate} bind def
+/sc {scale} bind def
+/sd {setdash} bind def
+/ff {findfont} bind def
+/sf {setfont} bind def
+/scf {scalefont} bind def
+/sw {stringwidth} bind def
+/tr {translate} bind def
+/tnt {dup dup currentrgbcolor
+  4 -2 roll dup 1 exch sub 3 -1 roll mul add
+  4 -2 roll dup 1 exch sub 3 -1 roll mul add
+  4 -2 roll dup 1 exch sub 3 -1 roll mul add srgb}
+  bind def
+/shd {dup dup currentrgbcolor 4 -2 roll mul 4 -2 roll mul
+  4 -2 roll mul srgb} bind def
+/reencdict 12 dict def /ReEncode { reencdict begin
+/newcodesandnames exch def /newfontname exch def /basefontname exch def
+/basefontdict basefontname findfont def /newfont basefontdict maxlength dict def
+basefontdict { exch dup /FID ne { dup /Encoding eq
+{ exch dup length array copy newfont 3 1 roll put }
+{ exch newfont 3 1 roll put } ifelse } { pop pop } ifelse } forall
+newfont /FontName newfontname put newcodesandnames aload pop
+128 1 255 { newfont /Encoding get exch /.notdef put } for
+newcodesandnames length 2 idiv { newfont /Encoding get 3 1 roll put } repeat
+newfontname newfont definefont pop end } def
+/isovec [
+8#055 /minus 8#200 /grave 8#201 /acute 8#202 /circumflex 8#203 /tilde
+8#204 /macron 8#205 /breve 8#206 /dotaccent 8#207 /dieresis
+8#210 /ring 8#211 /cedilla 8#212 /hungarumlaut 8#213 /ogonek 8#214 /caron
+8#220 /dotlessi 8#230 /oe 8#231 /OE
+8#240 /space 8#241 /exclamdown 8#242 /cent 8#243 /sterling
+8#244 /currency 8#245 /yen 8#246 /brokenbar 8#247 /section 8#250 /dieresis
+8#251 /copyright 8#252 /ordfeminine 8#253 /guillemotleft 8#254 /logicalnot
+8#255 /hyphen 8#256 /registered 8#257 /macron 8#260 /degree 8#261 /plusminus
+8#262 /twosuperior 8#263 /threesuperior 8#264 /acute 8#265 /mu 8#266 /paragraph
+8#267 /periodcentered 8#270 /cedilla 8#271 /onesuperior 8#272 /ordmasculine
+8#273 /guillemotright 8#274 /onequarter 8#275 /onehalf
+8#276 /threequarters 8#277 /questiondown 8#300 /Agrave 8#301 /Aacute
+8#302 /Acircumflex 8#303 /Atilde 8#304 /Adieresis 8#305 /Aring
+8#306 /AE 8#307 /Ccedilla 8#310 /Egrave 8#311 /Eacute
+8#312 /Ecircumflex 8#313 /Edieresis 8#314 /Igrave 8#315 /Iacute
+8#316 /Icircumflex 8#317 /Idieresis 8#320 /Eth 8#321 /Ntilde 8#322 /Ograve
+8#323 /Oacute 8#324 /Ocircumflex 8#325 /Otilde 8#326 /Odieresis 8#327 /multiply
+8#330 /Oslash 8#331 /Ugrave 8#332 /Uacute 8#333 /Ucircumflex
+8#334 /Udieresis 8#335 /Yacute 8#336 /Thorn 8#337 /germandbls 8#340 /agrave
+8#341 /aacute 8#342 /acircumflex 8#343 /atilde 8#344 /adieresis 8#345 /aring
+8#346 /ae 8#347 /ccedilla 8#350 /egrave 8#351 /eacute
+8#352 /ecircumflex 8#353 /edieresis 8#354 /igrave 8#355 /iacute
+8#356 /icircumflex 8#357 /idieresis 8#360 /eth 8#361 /ntilde 8#362 /ograve
+8#363 /oacute 8#364 /ocircumflex 8#365 /otilde 8#366 /odieresis 8#367 /divide
+8#370 /oslash 8#371 /ugrave 8#372 /uacute 8#373 /ucircumflex
+8#374 /udieresis 8#375 /yacute 8#376 /thorn 8#377 /ydieresis] def
+/Courier /Courier-iso isovec ReEncode
+ /DrawEllipse {
+	/endangle exch def
+	/startangle exch def
+	/yrad exch def
+	/xrad exch def
+	/y exch def
+	/x exch def
+	/savematrix mtrx currentmatrix def
+	x y tr xrad yrad sc 0 0 1 startangle endangle arc
+	closepath
+	savematrix setmatrix
+	} def
+
+/$F2psBegin {$F2psDict begin /$F2psEnteredState save def} def
+/$F2psEnd {$F2psEnteredState restore end} def
+
+/pageheader {
+sa
+n 0 369 m 0 0 l 409 0 l 409 369 l cp clip
+0.7 372.4 tr
+1 -1 sc
+$F2psBegin
+10 setmiterlimit
+0 slj 0 slc
+ 0.06000 0.06000 sc
+} bind def
+/pagefooter {
+$F2psEnd
+restore
+} bind def
+%%EndProlog
+pageheader
+%
+% Fig objects follow
+%
+% 
+% here starts figure with depth 50
+% Ellipse
+7.500 slw
+0 slc
+n 893 1007 413 112 0 360 DrawEllipse gs col0 s gr
+% Ellipse
+n 2018 1007 413 112 0 360 DrawEllipse gs col0 s gr
+/Courier-iso ff 66.67 scf sf
+1875 1050 m
+gs 1 -1 sc (Tipos) col0 sh gr
+% Ellipse
+n 3068 1307 413 112 0 360 DrawEllipse gs col0 s gr
+/Courier-iso ff 66.67 scf sf
+2775 1350 m
+gs 1 -1 sc (Game of Life) col0 sh gr
+% Ellipse
+n 487 1912 413 112 0 360 DrawEllipse gs col0 s gr
+/Courier-iso ff 66.67 scf sf
+189 1950 m
+gs 1 -1 sc (Escolha de cor) col0 sh gr
+% Ellipse
+n 1387 3167 487 133 0 360 DrawEllipse gs col0 s gr
+/Courier-iso ff 66.67 scf sf
+975 3198 m
+gs 1 -1 sc (Redes de Computadres) col0 sh gr
+% Ellipse
+n 3187 2887 413 112 0 360 DrawEllipse gs col0 s gr
+% Ellipse
+n 3207 2441 413 112 0 360 DrawEllipse gs col0 s gr
+/Courier-iso ff 66.67 scf sf
+3000 2475 m
+gs 1 -1 sc (Ocilators) col0 sh gr
+% Ellipse
+n 3221 1981 413 112 0 360 DrawEllipse gs col0 s gr
+/Courier-iso ff 66.67 scf sf
+3000 2025 m
+gs 1 -1 sc (Still Lives) col0 sh gr
+/Courier-iso ff 66.67 scf sf
+3000 2925 m
+gs 1 -1 sc (Space Ships) col0 sh gr
+/Courier-iso ff 66.67 scf sf
+3816 876 m
+gs 1 -1 sc (Te\363ria da Computa\347\343o) col0 sh gr
+% Ellipse
+n 4162 225 413 112 0 360 DrawEllipse gs col0 s gr
+/Courier-iso ff 66.67 scf sf
+3975 300 m
+gs 1 -1 sc (Matem\341tica) col0 sh gr
+/Courier-iso ff 66.67 scf sf
+3975 225 m
+gs 1 -1 sc (Complexidade) col0 sh gr
+/Courier-iso ff 66.67 scf sf
+4650 555 m
+gs 1 -1 sc (IA-Reconhecimento) col0 sh gr
+/Courier-iso ff 66.67 scf sf
+4725 630 m
+gs 1 -1 sc (de Par\365es) col0 sh gr
+% Ellipse
+n 4972 575 444 112 0 360 DrawEllipse gs col0 s gr
+% Ellipse
+n 5468 1157 413 112 0 360 DrawEllipse gs col0 s gr
+/Courier-iso ff 66.67 scf sf
+5400 1200 m
+gs 1 -1 sc (Boat) col0 sh gr
+/Courier-iso ff 66.67 scf sf
+5700 1650 m
+gs 1 -1 sc (Beehive) col0 sh gr
+% Ellipse
+n 5843 1607 413 112 0 360 DrawEllipse gs col0 s gr
+% Ellipse
+n 4718 1532 413 112 0 360 DrawEllipse gs col0 s gr
+/Courier-iso ff 66.67 scf sf
+4650 1575 m
+gs 1 -1 sc (Block) col0 sh gr
+% Ellipse
+n 5243 1982 413 112 0 360 DrawEllipse gs col0 s gr
+/Courier-iso ff 66.67 scf sf
+5100 2025 m
+gs 1 -1 sc (Load) col0 sh gr
+% Ellipse
+n 4793 2432 413 112 0 360 DrawEllipse gs col0 s gr
+/Courier-iso ff 66.67 scf sf
+4725 2475 m
+gs 1 -1 sc (Tub) col0 sh gr
+% Ellipse
+n 4718 3632 413 112 0 360 DrawEllipse gs col0 s gr
+/Courier-iso ff 66.67 scf sf
+4413 3654 m
+gs 1 -1 sc (Penta-decathlon) col0 sh gr
+% Ellipse
+n 6068 2807 413 112 0 360 DrawEllipse gs col0 s gr
+/Courier-iso ff 66.67 scf sf
+5925 2850 m
+gs 1 -1 sc (Blinker) col0 sh gr
+% Ellipse
+n 4868 3182 413 112 0 360 DrawEllipse gs col0 s gr
+/Courier-iso ff 66.67 scf sf
+4800 3225 m
+gs 1 -1 sc (Toad) col0 sh gr
+/Courier-iso ff 66.67 scf sf
+6300 3225 m
+gs 1 -1 sc (Beacon) col0 sh gr
+% Ellipse
+n 6368 3182 413 112 0 360 DrawEllipse gs col0 s gr
+/Courier-iso ff 66.67 scf sf
+5700 3600 m
+gs 1 -1 sc (Pulsar) col0 sh gr
+% Ellipse
+n 5843 3557 413 112 0 360 DrawEllipse gs col0 s gr
+% Polyline
+2 slj
+n 3675 2475 m 3677 2476 l 3681 2477 l 3688 2479 l 3699 2483 l 3716 2489 l
+ 3737 2496 l 3764 2506 l 3797 2517 l 3834 2530 l 3877 2544 l
+ 3924 2560 l 3974 2577 l 4027 2596 l 4082 2614 l 4139 2633 l
+ 4196 2653 l 4253 2672 l 4309 2691 l 4365 2709 l 4418 2727 l
+ 4470 2744 l 4520 2761 l 4568 2777 l 4614 2792 l 4658 2806 l
+ 4700 2819 l 4740 2832 l 4778 2843 l 4814 2855 l 4849 2865 l
+ 4882 2875 l 4915 2885 l 4946 2893 l 4976 2902 l 5005 2910 l
+ 5034 2918 l 5063 2925 l 5098 2934 l 5132 2942 l 5167 2951 l
+ 5201 2958 l 5235 2966 l 5269 2973 l 5304 2979 l 5339 2986 l
+ 5376 2993 l 5414 2999 l 5453 3005 l 5493 3011 l 5535 3017 l
+ 5577 3023 l 5621 3029 l 5665 3035 l 5710 3041 l 5753 3046 l
+ 5795 3052 l 5835 3056 l 5872 3061 l 5904 3064 l 5932 3068 l
+ 5955 3070 l 5973 3072 l 5985 3073 l 5994 3074 l 5998 3075 l
+
+ 6000 3075 l gs col0 s gr % Ellipse
+n 2693 3782 413 112 0 360 DrawEllipse gs col0 s gr
+/Courier-iso ff 66.67 scf sf
+2550 3825 m
+gs 1 -1 sc (Glider) col0 sh gr
+% Ellipse
+n 2183 4709 608 166 0 360 DrawEllipse gs col0 s gr
+/Courier-iso ff 66.67 scf sf
+1725 4725 m
+gs 1 -1 sc (Middle-weight spaceship) col0 sh gr
+% Ellipse
+n 3383 5159 608 166 0 360 DrawEllipse gs col0 s gr
+/Courier-iso ff 66.67 scf sf
+2925 5175 m
+gs 1 -1 sc (Light-weight spaceship) col0 sh gr
+% Ellipse
+n 3329 4358 555 151 0 360 DrawEllipse gs col0 s gr
+/Courier-iso ff 66.67 scf sf
+2925 4380 m
+gs 1 -1 sc (Heavy-weight spaceship) col0 sh gr
+% Polyline
+0 slj
+n 105 5400 m 0 5400 0 6090 105 arcto 4 {pop} repeat
+  0 6195 1995 6195 105 arcto 4 {pop} repeat
+  2100 6195 2100 5505 105 arcto 4 {pop} repeat
+  2100 5400 105 5400 105 arcto 4 {pop} repeat
+ cp gs col16 1.00 shd ef gr gs col0 s gr /Courier-iso ff 66.67 scf sf
+75 5895 m
+gs 1 -1 sc (de simula\347\343o de comportamento celular em) col0 sh gr
+/Courier-iso ff 66.67 scf sf
+75 5625 m
+gs 1 -1 sc (Os termos em ingl\352s \351 como se ) col0 sh gr
+/Courier-iso ff 66.67 scf sf
+75 5715 m
+gs 1 -1 sc (encontra na literatura representam o) col0 sh gr
+/Courier-iso ff 66.67 scf sf
+75 5805 m
+gs 1 -1 sc (aut\364mato que deu origem a todo este estudo) col0 sh gr
+/Courier-iso ff 66.67 scf sf
+75 5985 m
+gs 1 -1 sc (computador, Game of life, apesar da ideia) col0 sh gr
+/Courier-iso ff 66.67 scf sf
+75 6075 m
+gs 1 -1 sc (ter surgido na matem\341tica ainda no s\351culo XIX) col0 sh gr
+% Ellipse
+n 1718 182 413 112 0 360 DrawEllipse gs col0 s gr
+% Ellipse
+n 937 637 413 112 0 360 DrawEllipse gs col0 s gr
+% Ellipse
+n 1943 1757 413 112 0 360 DrawEllipse gs col0 s gr
+% Ellipse
+n 2993 482 413 112 0 360 DrawEllipse gs col29 1.00 shd ef gr gs col27 s gr
+% Ellipse
+n 1462 2362 413 112 0 360 DrawEllipse gs col0 s gr
+% Ellipse
+n 1118 1457 413 112 0 360 DrawEllipse gs col0 s gr
+% Ellipse
+n 487 2662 413 112 0 360 DrawEllipse gs col0 s gr
+% Ellipse
+n 4193 857 444 112 0 360 DrawEllipse gs col0 s gr
+% Polyline
+gs  clippath
+2166 227 m 2173 216 l 2307 269 l 2276 321 l cp
+eoclip
+n 2175 225 m
+ 2550 450 l gs col0 s gr gr
+% arrowhead
+n 2307 269 m 2189 233 l 2276 321 l 2307 269 l  cp gs 0.00 setgray ef gr  col0 s
+% Polyline
+gs  clippath
+3753 291 m 3759 303 l 3642 388 l 3615 334 l cp
+eoclip
+n 3450 450 m
+ 3750 300 l gs col0 s gr gr
+% arrowhead
+n 3642 388 m 3736 307 l 3615 334 l 3642 388 l  cp gs 0.00 setgray ef gr  col0 s
+% Polyline
+2 slj
+n 3675 1950 m
+ 4725 1950 l gs col0 s gr % Polyline
+gs  clippath
+2775 2915 m 2785 2925 l 2702 3044 l 2659 3003 l cp
+eoclip
+n 2775 2925 m 2752 2949 l 2737 2965 l 2718 2985 l 2695 3009 l 2669 3038 l
+ 2639 3070 l 2608 3104 l 2575 3141 l 2541 3178 l 2507 3216 l
+ 2474 3254 l 2442 3291 l 2412 3327 l 2383 3361 l 2356 3395 l
+ 2331 3426 l 2308 3457 l 2287 3485 l 2268 3513 l 2250 3540 l
+ 2234 3566 l 2220 3591 l 2207 3615 l 2195 3639 l 2185 3663 l
+ 2175 3688 l 2166 3713 l 2157 3739 l 2150 3766 l 2144 3793 l
+ 2139 3821 l 2135 3850 l 2132 3880 l 2130 3912 l 2129 3946 l
+ 2128 3982 l 2129 4019 l 2130 4059 l 2133 4100 l 2135 4143 l
+ 2139 4186 l 2143 4230 l 2147 4274 l 2152 4316 l 2156 4355 l
+ 2161 4391 l 2164 4422 l 2168 4448 l 2171 4468 l 2173 4483 l
+ 2174 4492 l 2175 4498 l
+ 2175 4500 l gs col0 s gr gr
+% arrowhead
+0 slj
+n 2702 3044 m 2764 2937 l 2659 3003 l 2702 3044 l  cp gs 0.00 setgray ef gr  col0 s
+% Polyline
+2 slj
+gs  clippath
+2098 909 m 2091 898 l 2193 796 l 2228 845 l cp
+eoclip
+n 2625 525 m
+ 2100 900 l gs col0 s gr gr
+% arrowhead
+0 slj
+n 2193 796 m 2113 891 l 2228 845 l 2193 796 l  cp gs 0.00 setgray ef gr  col0 s
+% Polyline
+2 slj
+gs  clippath
+1734 898 m 1727 909 l 1593 856 l 1624 804 l cp
+eoclip
+n 1725 900 m
+ 1350 675 l gs col0 s gr gr
+% arrowhead
+0 slj
+n 1593 856 m 1711 892 l 1624 804 l 1593 856 l  cp gs 0.00 setgray ef gr  col0 s
+% Polyline
+2 slj
+gs  clippath
+1582 968 m 1582 982 l 1439 1005 l 1439 945 l cp
+eoclip
+n 1575 975 m
+ 1350 975 l gs col0 s gr gr
+% arrowhead
+0 slj
+n 1439 1005 m 1559 975 l 1439 945 l 1439 1005 l  cp gs 0.00 setgray ef gr  col0 s
+% Polyline
+2 slj
+gs  clippath
+1575 1040 m 1585 1050 l 1500 1168 l 1457 1125 l cp
+eoclip
+n 1575 1050 m
+ 1275 1350 l gs col0 s gr gr
+% arrowhead
+0 slj
+n 1500 1168 m 1564 1061 l 1457 1125 l 1500 1168 l  cp gs 0.00 setgray ef gr  col0 s
+% Polyline
+2 slj
+gs  clippath
+1943 1118 m 1957 1118 l 1980 1261 l 1920 1261 l cp
+eoclip
+n 1950 1125 m
+ 1950 1650 l gs col0 s gr gr
+% arrowhead
+0 slj
+n 1980 1261 m 1950 1141 l 1920 1261 l 1980 1261 l  cp gs 0.00 setgray ef gr  col0 s
+% Polyline
+2 slj
+gs  clippath
+2992 594 m 3006 592 l 3049 731 l 2990 739 l cp
+eoclip
+n 3000 600 m
+ 3075 1125 l gs col0 s gr gr
+% arrowhead
+0 slj
+n 3049 731 m 3002 616 l 2990 739 l 3049 731 l  cp gs 0.00 setgray ef gr  col0 s
+% Polyline
+2 slj
+gs  clippath
+4507 594 m 4506 607 l 4362 620 l 4366 560 l cp
+eoclip
+n 3450 525 m
+ 4500 600 l gs col0 s gr gr
+% arrowhead
+0 slj
+n 4362 620 m 4484 599 l 4366 560 l 4362 620 l  cp gs 0.00 setgray ef gr  col0 s
+% Polyline
+2 slj
+gs  clippath
+3759 823 m 3752 834 l 3618 781 l 3649 729 l cp
+eoclip
+n 3375 600 m
+ 3750 825 l gs col0 s gr gr
+% arrowhead
+0 slj
+n 3618 781 m 3736 817 l 3649 729 l 3618 781 l  cp gs 0.00 setgray ef gr  col0 s
+% Polyline
+2 slj
+gs  clippath
+3525 1885 m 3515 1875 l 3602 1759 l 3644 1802 l cp
+eoclip
+n 3525 1875 m 3552 1849 l 3568 1833 l 3588 1814 l 3612 1791 l 3638 1767 l
+ 3666 1740 l 3695 1714 l 3723 1687 l 3751 1662 l 3778 1638 l
+ 3803 1615 l 3828 1595 l 3850 1575 l 3872 1557 l 3893 1541 l
+ 3912 1526 l 3932 1512 l 3950 1499 l 3969 1487 l 3988 1475 l
+ 4008 1463 l 4029 1451 l 4050 1440 l 4072 1428 l 4094 1418 l
+ 4117 1407 l 4140 1397 l 4165 1387 l 4189 1377 l 4214 1368 l
+ 4239 1359 l 4264 1350 l 4290 1342 l 4315 1334 l 4339 1327 l
+ 4364 1320 l 4387 1314 l 4411 1308 l 4434 1302 l 4456 1297 l
+ 4478 1292 l 4500 1288 l 4522 1283 l 4544 1278 l 4567 1274 l
+ 4590 1269 l 4614 1265 l 4640 1260 l 4668 1256 l 4697 1251 l
+ 4728 1246 l 4761 1240 l 4796 1235 l 4832 1229 l 4868 1224 l
+ 4902 1218 l 4934 1214 l 4963 1209 l 4986 1206 l 5004 1203 l
+ 5015 1201 l 5022 1200 l
+ 5025 1200 l gs col0 s gr gr
+% arrowhead
+0 slj
+n 3602 1759 m 3537 1864 l 3644 1802 l 3602 1759 l  cp gs 0.00 setgray ef gr  col0 s
+% Polyline
+2 slj
+gs  clippath
+3671 1959 m 3666 1946 l 3790 1872 l 3813 1927 l cp
+eoclip
+n 3675 1950 m
+ 4425 1650 l gs col0 s gr gr
+% arrowhead
+0 slj
+n 3790 1872 m 3690 1944 l 3813 1927 l 3790 1872 l  cp gs 0.00 setgray ef gr  col0 s
+% Polyline
+2 slj
+gs  clippath
+3668 2031 m 3669 2018 l 3814 2009 l 3807 2069 l cp
+eoclip
+n 3675 2025 m 3704 2028 l 3723 2031 l 3748 2034 l 3780 2038 l 3818 2042 l
+ 3863 2048 l 3913 2054 l 3968 2060 l 4027 2067 l 4089 2074 l
+ 4153 2082 l 4219 2090 l 4285 2097 l 4351 2105 l 4416 2112 l
+ 4480 2119 l 4541 2126 l 4601 2133 l 4657 2139 l 4711 2145 l
+ 4763 2150 l 4811 2155 l 4857 2160 l 4901 2164 l 4942 2168 l
+ 4980 2171 l 5017 2175 l 5051 2177 l 5084 2180 l 5115 2182 l
+ 5144 2184 l 5172 2185 l 5199 2186 l 5225 2188 l 5264 2189 l
+ 5301 2189 l 5336 2189 l 5370 2189 l 5402 2187 l 5433 2186 l
+ 5462 2183 l 5489 2180 l 5516 2177 l 5540 2173 l 5564 2168 l
+ 5585 2163 l 5605 2157 l 5624 2151 l 5641 2145 l 5656 2138 l
+ 5670 2131 l 5683 2123 l 5694 2116 l 5704 2108 l 5714 2100 l
+ 5722 2092 l 5730 2083 l 5738 2075 l 5748 2062 l 5758 2048 l
+ 5767 2033 l 5775 2016 l 5784 1997 l 5793 1976 l 5802 1952 l
+ 5811 1926 l 5820 1900 l 5828 1873 l 5836 1848 l 5842 1828 l
+ 5846 1813 l 5849 1804 l 5850 1801 l
+ 5850 1800 l gs col0 s gr gr
+% arrowhead
+0 slj
+n 3814 2009 m 3691 2027 l 3807 2069 l 3814 2009 l  cp gs 0.00 setgray ef gr  col0 s
+% Polyline
+2 slj
+gs  clippath
+3666 2029 m 3671 2016 l 3813 2048 l 3790 2103 l cp
+eoclip
+n 3675 2025 m
+ 4425 2325 l gs col0 s gr gr
+% arrowhead
+0 slj
+n 3813 2048 m 3690 2031 l 3790 2103 l 3813 2048 l  cp gs 0.00 setgray ef gr  col0 s
+% Polyline
+2 slj
+gs  clippath
+3667 2480 m 3670 2467 l 3814 2472 l 3803 2531 l cp
+eoclip
+n 3675 2475 m 3705 2481 l 3724 2485 l 3750 2490 l 3781 2496 l 3817 2503 l
+ 3859 2511 l 3904 2520 l 3952 2529 l 4002 2539 l 4054 2549 l
+ 4106 2559 l 4157 2569 l 4207 2578 l 4255 2588 l 4302 2596 l
+ 4347 2605 l 4389 2613 l 4429 2620 l 4468 2627 l 4504 2634 l
+ 4539 2640 l 4572 2646 l 4604 2651 l 4635 2656 l 4664 2661 l
+ 4693 2666 l 4722 2671 l 4750 2675 l 4782 2680 l 4813 2684 l
+ 4845 2689 l 4877 2693 l 4909 2698 l 4942 2702 l 4976 2706 l
+ 5011 2711 l 5048 2715 l 5087 2719 l 5127 2724 l 5169 2729 l
+ 5212 2733 l 5257 2738 l 5302 2743 l 5348 2747 l 5393 2752 l
+ 5436 2756 l 5477 2760 l 5513 2764 l 5545 2767 l 5572 2770 l
+ 5593 2772 l 5608 2773 l 5617 2774 l 5623 2775 l
+ 5625 2775 l gs col0 s gr gr
+% arrowhead
+0 slj
+n 3814 2472 m 3691 2478 l 3803 2531 l 3814 2472 l  cp gs 0.00 setgray ef gr  col0 s
+% Polyline
+2 slj
+gs  clippath
+3591 2478 m 3597 2466 l 3734 2513 l 3706 2566 l cp
+eoclip
+n 3600 2475 m
+ 4725 3075 l gs col0 s gr gr
+% arrowhead
+0 slj
+n 3734 2513 m 3614 2483 l 3706 2566 l 3734 2513 l  cp gs 0.00 setgray ef gr  col0 s
+% Polyline
+2 slj
+gs  clippath
+3515 2550 m 3525 2540 l 3643 2625 l 3600 2668 l cp
+eoclip
+n 3525 2550 m
+ 4500 3525 l gs col0 s gr gr
+% arrowhead
+0 slj
+n 3643 2625 m 3536 2561 l 3600 2668 l 3643 2625 l  cp gs 0.00 setgray ef gr  col0 s
+% Polyline
+2 slj
+gs  clippath
+3516 2546 m 3529 2541 l 3599 2668 l 3543 2688 l cp
+eoclip
+n 3525 2550 m 3535 2578 l 3542 2596 l 3550 2620 l 3561 2650 l 3573 2685 l
+ 3588 2725 l 3604 2769 l 3621 2817 l 3639 2867 l 3658 2919 l
+ 3677 2972 l 3696 3024 l 3715 3076 l 3733 3126 l 3751 3174 l
+ 3768 3221 l 3784 3265 l 3800 3306 l 3815 3346 l 3829 3383 l
+ 3842 3417 l 3855 3450 l 3867 3480 l 3878 3509 l 3889 3536 l
+ 3899 3561 l 3909 3585 l 3919 3608 l 3928 3629 l 3938 3650 l
+ 3951 3680 l 3965 3709 l 3978 3736 l 3992 3762 l 4005 3787 l
+ 4019 3811 l 4032 3833 l 4046 3855 l 4060 3875 l 4074 3894 l
+ 4088 3912 l 4101 3928 l 4115 3943 l 4129 3957 l 4143 3970 l
+ 4156 3982 l 4170 3993 l 4183 4003 l 4197 4013 l 4210 4021 l
+ 4224 4030 l 4238 4038 l 4253 4046 l 4270 4054 l 4287 4063 l
+ 4305 4071 l 4324 4079 l 4344 4087 l 4365 4095 l 4387 4103 l
+ 4409 4111 l 4432 4118 l 4455 4125 l 4479 4131 l 4502 4137 l
+ 4526 4142 l 4549 4147 l 4573 4151 l 4595 4155 l 4618 4158 l
+ 4640 4161 l 4663 4163 l 4683 4164 l 4704 4165 l 4725 4165 l
+ 4747 4165 l 4769 4165 l 4792 4164 l 4815 4162 l 4839 4160 l
+ 4863 4157 l 4888 4153 l 4913 4149 l 4937 4144 l 4962 4138 l
+ 4986 4132 l 5010 4125 l 5033 4118 l 5056 4110 l 5078 4101 l
+ 5100 4093 l 5121 4083 l 5142 4073 l 5163 4063 l 5181 4052 l
+ 5200 4041 l 5218 4029 l 5238 4016 l 5257 4002 l 5278 3987 l
+ 5300 3970 l 5322 3951 l 5347 3931 l 5372 3909 l 5399 3885 l
+ 5427 3860 l 5455 3834 l 5484 3808 l 5512 3782 l 5538 3758 l
+ 5562 3736 l 5582 3716 l 5598 3701 l 5610 3689 l 5619 3681 l
+ 5623 3677 l
+ 5625 3675 l gs col0 s gr gr
+% arrowhead
+0 slj
+n 3599 2668 m 3530 2565 l 3543 2688 l 3599 2668 l  cp gs 0.00 setgray ef gr  col0 s
+% Polyline
+2 slj
+gs  clippath
+3441 2997 m 3453 2991 l 3538 3108 l 3484 3135 l cp
+eoclip
+n 3450 3000 m 3462 3024 l 3469 3040 l 3480 3062 l 3492 3088 l 3508 3121 l
+ 3525 3158 l 3545 3200 l 3567 3246 l 3591 3296 l 3615 3348 l
+ 3640 3403 l 3666 3458 l 3692 3515 l 3717 3571 l 3742 3626 l
+ 3767 3680 l 3790 3732 l 3812 3783 l 3833 3831 l 3852 3878 l
+ 3871 3922 l 3887 3964 l 3903 4004 l 3918 4042 l 3931 4078 l
+ 3943 4112 l 3953 4145 l 3963 4176 l 3971 4205 l 3979 4234 l
+ 3986 4261 l 3991 4287 l 3996 4313 l 4000 4338 l 4004 4373 l
+ 4007 4406 l 4008 4439 l 4007 4471 l 4005 4503 l 4000 4535 l
+ 3993 4566 l 3984 4598 l 3974 4631 l 3961 4664 l 3946 4698 l
+ 3930 4733 l 3912 4768 l 3892 4804 l 3872 4839 l 3852 4873 l
+ 3831 4905 l 3813 4934 l 3795 4960 l 3781 4981 l 3769 4998 l
+ 3760 5011 l 3755 5019 l 3751 5023 l
+ 3750 5025 l gs col0 s gr gr
+% arrowhead
+0 slj
+n 3538 3108 m 3457 3014 l 3484 3135 l 3538 3108 l  cp gs 0.00 setgray ef gr  col0 s
+% Polyline
+2 slj
+gs  clippath
+3143 2994 m 3156 2993 l 3188 3134 l 3129 3138 l cp
+eoclip
+n 3150 3000 m
+ 3225 4200 l gs col0 s gr gr
+% arrowhead
+0 slj
+n 3188 3134 m 3151 3016 l 3129 3138 l 3188 3134 l  cp gs 0.00 setgray ef gr  col0 s
+% Polyline
+2 slj
+gs  clippath
+2920 2992 m 2933 2995 l 2925 3139 l 2866 3126 l cp
+eoclip
+n 2925 3000 m
+ 2775 3675 l gs col0 s gr gr
+% arrowhead
+0 slj
+n 2925 3139 m 2921 3016 l 2866 3126 l 2925 3139 l  cp gs 0.00 setgray ef gr  col0 s
+% Polyline
+2 slj
+gs  clippath
+2859 2778 m 2847 2784 l 2762 2667 l 2816 2640 l cp
+eoclip
+n 2775 1425 m 2774 1427 l 2773 1432 l 2771 1442 l 2767 1457 l 2762 1477 l
+ 2756 1502 l 2748 1533 l 2740 1568 l 2731 1607 l 2721 1648 l
+ 2711 1690 l 2701 1733 l 2692 1776 l 2683 1817 l 2675 1857 l
+ 2667 1895 l 2661 1931 l 2655 1965 l 2650 1997 l 2646 2027 l
+ 2642 2055 l 2640 2082 l 2638 2107 l 2637 2131 l 2636 2155 l
+ 2637 2178 l 2638 2200 l 2639 2226 l 2642 2251 l 2646 2276 l
+ 2651 2301 l 2657 2327 l 2664 2353 l 2672 2381 l 2682 2410 l
+ 2693 2440 l 2706 2471 l 2720 2504 l 2734 2538 l 2750 2572 l
+ 2766 2606 l 2782 2640 l 2797 2671 l 2811 2700 l 2824 2724 l
+ 2834 2743 l
+ 2850 2775 l gs col0 s gr gr
+% arrowhead
+0 slj
+n 2762 2667 m 2843 2761 l 2816 2640 l 2762 2667 l  cp gs 0.00 setgray ef gr  col0 s
+% Polyline
+2 slj
+gs  clippath
+2859 2329 m 2846 2334 l 2776 2207 l 2832 2187 l cp
+eoclip
+n 2925 1425 m 2924 1428 l 2921 1434 l 2916 1446 l 2909 1463 l 2900 1486 l
+ 2889 1514 l 2877 1546 l 2864 1580 l 2851 1615 l 2838 1649 l
+ 2825 1683 l 2814 1715 l 2804 1745 l 2795 1773 l 2787 1799 l
+ 2781 1823 l 2775 1845 l 2771 1867 l 2767 1887 l 2764 1906 l
+ 2763 1925 l 2761 1945 l 2761 1966 l 2761 1986 l 2763 2007 l
+ 2766 2029 l 2770 2052 l 2774 2076 l 2780 2102 l 2787 2129 l
+ 2795 2157 l 2804 2186 l 2813 2215 l 2822 2243 l 2830 2268 l
+ 2837 2289 l
+ 2850 2325 l gs col0 s gr gr
+% arrowhead
+0 slj
+n 2776 2207 m 2845 2310 l 2832 2187 l 2776 2207 l  cp gs 0.00 setgray ef gr  col0 s
+% Polyline
+2 slj
+gs  clippath
+3233 1881 m 3219 1883 l 3173 1746 l 3232 1736 l cp
+eoclip
+n 3150 1425 m
+ 3225 1875 l gs col0 s gr gr
+% arrowhead
+0 slj
+n 3173 1746 m 3222 1859 l 3232 1736 l 3173 1746 l  cp gs 0.00 setgray ef gr  col0 s
+% Polyline
+2 slj
+gs  clippath
+1872 2334 m 1866 2322 l 1979 2232 l 2009 2285 l cp
+eoclip
+n 2850 600 m 2849 602 l 2846 608 l 2841 617 l 2833 632 l 2822 652 l
+ 2809 678 l 2793 708 l 2775 742 l 2756 779 l 2737 818 l
+ 2717 857 l 2697 896 l 2679 935 l 2661 972 l 2644 1007 l
+ 2628 1041 l 2614 1073 l 2601 1103 l 2589 1132 l 2579 1159 l
+ 2569 1186 l 2560 1212 l 2552 1237 l 2544 1262 l 2538 1288 l
+ 2531 1313 l 2525 1338 l 2520 1364 l 2514 1390 l 2509 1417 l
+ 2504 1444 l 2499 1471 l 2494 1499 l 2490 1527 l 2485 1556 l
+ 2480 1584 l 2475 1613 l 2470 1641 l 2465 1669 l 2459 1697 l
+ 2453 1724 l 2447 1751 l 2441 1776 l 2434 1801 l 2427 1825 l
+ 2420 1848 l 2412 1870 l 2404 1891 l 2395 1912 l 2385 1931 l
+ 2375 1950 l 2363 1970 l 2350 1989 l 2336 2007 l 2320 2026 l
+ 2302 2044 l 2283 2062 l 2261 2081 l 2237 2100 l 2211 2119 l
+ 2183 2139 l 2152 2160 l 2119 2181 l 2085 2203 l 2051 2224 l
+ 2017 2244 l 1985 2263 l 1955 2280 l 1930 2295 l 1909 2306 l
+
+ 1875 2325 l gs col0 s gr gr
+% arrowhead
+0 slj
+n 1979 2232 m 1889 2317 l 2009 2285 l 1979 2232 l  cp gs 0.00 setgray ef gr  col0 s
+% Polyline
+2 slj
+gs  clippath
+1134 2248 m 1127 2259 l 993 2206 l 1024 2154 l cp
+eoclip
+n 1125 2250 m
+ 750 2025 l gs col0 s gr gr
+% arrowhead
+0 slj
+n 993 2206 m 1111 2242 l 1024 2154 l 993 2206 l  cp gs 0.00 setgray ef gr  col0 s
+% Polyline
+2 slj
+gs  clippath
+1054 2391 m 1059 2404 l 930 2472 l 911 2415 l cp
+eoclip
+n 1050 2400 m
+ 600 2550 l gs col0 s gr gr
+% arrowhead
+0 slj
+n 930 2472 m 1035 2405 l 911 2415 l 930 2472 l  cp gs 0.00 setgray ef gr  col0 s
+% Polyline
+2 slj
+gs  clippath
+1418 2468 m 1432 2468 l 1455 2611 l 1395 2611 l cp
+eoclip
+n 1425 2475 m
+ 1425 3000 l gs col0 s gr gr
+% arrowhead
+0 slj
+n 1455 2611 m 1425 2491 l 1395 2611 l 1455 2611 l  cp gs 0.00 setgray ef gr  col0 s
+/Courier-iso ff 66.67 scf sf
+1500 225 m
+gs 1 -1 sc (Algor\355timo) col0 sh gr
+/Courier-iso ff 66.67 scf sf
+600 675 m
+gs 1 -1 sc (C\351lula Triangular) col0 sh gr
+/Courier-iso ff 66.67 scf sf
+525 1050 m
+gs 1 -1 sc (C\351lula Pentagonal) col0 sh gr
+/Courier-iso ff 66.67 scf sf
+1125 2400 m
+gs 1 -1 sc (\301rea de aplica\347\343o) col0 sh gr
+/Courier-iso ff 66.67 scf sf
+792 1476 m
+gs 1 -1 sc (C\351lula Hexagonal) col0 sh gr
+/Courier-iso ff 66.67 scf sf
+1650 1776 m
+gs 1 -1 sc (C\351lula Quadrada) col0 sh gr
+/Courier-iso ff 66.67 scf sf
+132 2688 m
+gs 1 -1 sc (Teclado de Celular) col0 sh gr
+/Courier-iso ff 66.67 scf sf
+2688 504 m
+gs 1 -1 sc (Aut\364mato Celular) col0 sh gr
+/Courier-iso ff 66.67 scf sf
+3600 450 m
+gs 1 -1 sc (Est\341 relacionado) col0 sh gr
+/Courier-iso ff 66.67 scf sf
+3675 600 m
+gs 1 -1 sc (Est\341 relacionado) col0 sh gr
+/Courier-iso ff 66.67 scf sf
+3225 750 m
+gs 1 -1 sc (Est\341 relacionado) col0 sh gr
+/Courier-iso ff 66.67 scf sf
+3075 975 m
+gs 1 -1 sc (\311 um\(a\)) col0 sh gr
+/Courier-iso ff 66.67 scf sf
+2100 675 m
+gs 1 -1 sc (Possui) col0 sh gr
+/Courier-iso ff 66.67 scf sf
+2400 300 m
+gs 1 -1 sc (\311 um\(a\)) col0 sh gr
+/Courier-iso ff 66.67 scf sf
+3225 1650 m
+gs 1 -1 sc (Possui) col0 sh gr
+/Courier-iso ff 66.67 scf sf
+2850 1725 m
+gs 1 -1 sc (Possui) col0 sh gr
+/Courier-iso ff 66.67 scf sf
+2400 2475 m
+gs 1 -1 sc (Possui) col0 sh gr
+/Courier-iso ff 66.67 scf sf
+4050 1275 m
+gs 1 -1 sc (\311 um\(a\)) col0 sh gr
+/Courier-iso ff 66.67 scf sf
+3975 1650 m
+gs 1 -1 sc (\311 um\(a\)) col0 sh gr
+/Courier-iso ff 66.67 scf sf
+5850 2025 m
+gs 1 -1 sc (\311 um\(a\)) col0 sh gr
+/Courier-iso ff 66.67 scf sf
+4275 2025 m
+gs 1 -1 sc (\311 um\(a\)) col0 sh gr
+/Courier-iso ff 66.67 scf sf
+3900 2325 m
+gs 1 -1 sc (\311 um\(a\)) col0 sh gr
+/Courier-iso ff 66.67 scf sf
+4875 2775 m
+gs 1 -1 sc (\311 um\(a\)) col0 sh gr
+/Courier-iso ff 66.67 scf sf
+4800 3000 m
+gs 1 -1 sc (\311 um\(a\)) col0 sh gr
+/Courier-iso ff 66.67 scf sf
+4275 3000 m
+gs 1 -1 sc (\311 um\(a\)) col0 sh gr
+/Courier-iso ff 66.67 scf sf
+3900 3225 m
+gs 1 -1 sc (\311 um\(a\)) col0 sh gr
+/Courier-iso ff 66.67 scf sf
+5475 3900 m
+gs 1 -1 sc (\311 um\(a\)) col0 sh gr
+/Courier-iso ff 66.67 scf sf
+3150 3375 m
+gs 1 -1 sc (\311 um\(a\)) col0 sh gr
+/Courier-iso ff 66.67 scf sf
+2550 3450 m
+gs 1 -1 sc (\311 um\(a\)) col0 sh gr
+/Courier-iso ff 66.67 scf sf
+4050 4575 m
+gs 1 -1 sc (\311 um\(a\)) col0 sh gr
+/Courier-iso ff 66.67 scf sf
+2175 4275 m
+gs 1 -1 sc (\311 um\(a\)) col0 sh gr
+/Courier-iso ff 66.67 scf sf
+2025 1425 m
+gs 1 -1 sc (\311 um\(a\)) col0 sh gr
+/Courier-iso ff 66.67 scf sf
+1425 1275 m
+gs 1 -1 sc (\311 um\(a\)) col0 sh gr
+/Courier-iso ff 66.67 scf sf
+1275 900 m
+gs 1 -1 sc (\311 um\(a\)) col0 sh gr
+/Courier-iso ff 66.67 scf sf
+1500 750 m
+gs 1 -1 sc (\311 um\(a\)) col0 sh gr
+/Courier-iso ff 66.67 scf sf
+1950 2100 m
+gs 1 -1 sc (Possui) col0 sh gr
+/Courier-iso ff 66.67 scf sf
+675 2175 m
+gs 1 -1 sc (\311 um\(a\)) col0 sh gr
+/Courier-iso ff 66.67 scf sf
+825 2475 m
+gs 1 -1 sc (\311 um\(a\)) col0 sh gr
+/Courier-iso ff 66.67 scf sf
+1350 2775 m
+gs 1 -1 sc (\311 um\(a\)) col0 sh gr
+% here ends figure;
+pagefooter
+showpage
+%%Trailer
+%EOF
diff --git a/doc/tex/fig/t.jpg b/doc/tex/fig/t.jpg
new file mode 100644
index 0000000..9c7f0e4
Binary files /dev/null and b/doc/tex/fig/t.jpg differ
diff --git a/doc/tex/mybib.bib b/doc/tex/mybib.bib
new file mode 100644
index 0000000..124a6bf
--- /dev/null
+++ b/doc/tex/mybib.bib
@@ -0,0 +1,23 @@
+@book{book1,
+   title =     {Computação Gráfica: Imagem},
+   author =    {Jonas Gomes, Luiz Velho},
+   publisher = {SBM},
+   isbn =      {85-244-0088-9},
+   year =      {1994},
+   series =    {},
+   edition =   {},
+   volume =    {},
+   url =       {}}
+
+@book{book2,
+   title =     {A Computational Introduction to Digital Image Processing},
+   author =    {Alasdair McAndrew},
+   publisher = {Taylor and Francis},
+   isbn =      {978-1-4822-4735-0},
+   year =      {2016},
+   series =    {},
+   edition =   {Second},
+   volume =    {},
+   url =       {}}
+
+
diff --git a/doc/tex/packages.tex b/doc/tex/packages.tex
new file mode 100644
index 0000000..1351cce
--- /dev/null
+++ b/doc/tex/packages.tex
@@ -0,0 +1,127 @@
+\usepackage{syntax}
+\usepackage[brazilian]{babel}
+\usepackage[utf8]{inputenc}
+% \usepackage[usenames, dvipsnames]{xcolor}
+\usepackage[usenames, dvipsnames]{color}
+% \usepackage{tgtermes} times homan font similar
+\usepackage{hyperref}
+\usepackage{indentfirst}
+\usepackage{bbding}
+\usepackage{pifont}
+\usepackage{makeidx}
+\makeindex
+\hypersetup{
+    colorlinks,
+    citecolor=black,
+    filecolor=black,
+    linkcolor=black,
+    urlcolor=black
+}
+\usepackage{fullpage}
+\usepackage{amssymb}
+\usepackage{float}
+\usepackage[toc,page]{appendix}
+\usepackage{cite}
+% \usepackage{draftwatermark}
+% \SetWatermarkText{RASCUNHO}
+% \SetWatermarkScale{1.0}
+% \SetWatermarkColor[rgb]{0.9, 0.9, 0.9}
+
+% \setdefaultlanguage[babelshorthands]{brazilian}
+% \usepackage{fontspec}
+% Pra mostra codigo fonte
+\usepackage{listings}
+\usepackage{caption}
+\usepackage[most]{tcolorbox}
+\DeclareCaptionFont{white}{\color{white}}
+\DeclareCaptionFormat{listing}{%
+  \parbox{\textwidth}{\colorbox{gray}{\parbox{\textwidth}{#1#2#3}}\vskip-4pt}}
+\captionsetup[lstlisting]{format=listing,labelfont=white,textfont=white}
+\lstset{frame=lrb,xleftmargin=\fboxsep,xrightmargin=-\fboxsep}
+
+%%%  Definiciao da sintaxe da linguagem jSmall para o hiligth
+\lstdefinelanguage{jSmall}{
+    keywords={numfi, numf, true, false, loop, return, if, in, while, then, else, elif},
+    keywordstyle=\color{blue}\bfseries,
+    ndkeywords={boot, export, boolean, throw, implements, import, this},
+    ndkeywordstyle=\color{darkgray}\bfseries,
+    identifierstyle=\color{black},
+    sensitive=false,
+    comment=[l]{~},
+    morecomment=[s]{~\{}{\}~},
+    commentstyle=\color{purple}\ttfamily,
+    stringstyle=\color{red}\ttfamily,
+    morestring=[b]',
+    morestring=[b]"
+}
+
+\lstset{language=C++,
+    basicstyle=\ttfamily,
+    keywordstyle=\color{blue}\ttfamily,
+    stringstyle=\color{red}\ttfamily,
+    commentstyle=\color{green}\ttfamily,
+    morecomment=[l][\color{magenta}]{\#}
+}
+
+\newtcblisting[auto counter]{sexylisting}[2][]{sharp corners, 
+    fonttitle=\bfseries, colframe=gray, listing only, 
+    listing options={basicstyle=\ttfamily,language=jSmall, numbers=left}, 
+    title=Listing \thetcbcounter: #2, #1}
+
+\newtcblisting[auto counter]{sexylistingjava}[2][]{sharp corners, 
+    fonttitle=\bfseries, colframe=gray, listing only, 
+    listing options={basicstyle=\ttfamily,language=java, numbers=left}, 
+    title=Listing \thetcbcounter: #2, #1}
+    
+\newtcblisting[auto counter]{sexylistingcpp}[2][]{sharp corners, 
+    fonttitle=\bfseries, colframe=gray, listing only, 
+    listing options={basicstyle=\ttfamily,language=C++, numbers=left}, 
+    title=Listing \thetcbcounter: #2, #1}
+
+% Automata packages
+\usepackage{tikz, graphics}
+
+\usepackage{pgfplots}
+\pgfplotsset{compat=1.16}
+\usetikzlibrary{tikzmark, shapes.callouts}
+\usetikzlibrary{automata, positioning, arrows}
+\usetikzlibrary{arrows.meta, % if the figure contains arrow-tips
+                bending,     % arrow tips on arcs are "bent," i.e., deformed a bit
+                patterns     % if the figure contains pattern fills
+               }
+
+\usepackage{tipa}
+
+% Hacking pra poder usar syntax package junto com o tikz
+\usepackage{etoolbox}
+\AtBeginEnvironment{tikzpicture}{\catcode`\_=8}
+
+\usepackage{ifthen,xcolor,xkeyval,calc}
+\newlength{\tabcont}
+
+\newcommand{\tab}[1]{%
+\settowidth{\tabcont}{#1}%
+\ifthenelse{\lengthtest{\tabcont < .25\linewidth}}%
+{\makebox[.25\linewidth][l]{#1}\ignorespaces}%
+{\makebox[.5\linewidth][l]{#1}\ignorespaces}%
+}%
+
+\frenchspacing
+
+% \title{
+%     \textbf{\Large UNIVERSIDADE FEDERAL DE ALAGOAS}\\
+%     \textbf{\Large INSTITUTO DE COMPUTAÇÃO}\\
+%     {\ }\\
+%     \textbf{\Large Slam Combinando}\\
+%     \textbf{\Large com Filtros de Kalman}\\
+%     \textbf{\Large para Robôs Móveis}\\
+%     % \line(1,0){250} \\
+% }
+\author{Joilnen Leite\\ 2017.2}
+
+% \usepackage[colorinlistoftodos]{todonotes}\setlength{\marginparwidth}{3cm}\reversemarginpar
+\usepackage {todonotes}\setlength{\marginparwidth}{3cm}\reversemarginpar
+
+% HACK: set length so that the paper can have better width for margin
+
+\usepackage{float}
diff --git a/doc/tex/relatorio.pdf b/doc/tex/relatorio.pdf
new file mode 100644
index 0000000..c748d51
Binary files /dev/null and b/doc/tex/relatorio.pdf differ
diff --git a/doc/tex/relatorio.tex b/doc/tex/relatorio.tex
new file mode 100644
index 0000000..c79ccbd
--- /dev/null
+++ b/doc/tex/relatorio.tex
@@ -0,0 +1,92 @@
+\documentclass [a4paper, 12pt] {article}
+
+\input{packages}
+% \usepackage{fancyhdr}
+% \pagestyle{fancy}
+
+% \fancyhead{}
+% \fancyfoot{}
+
+% \renewcommand{\headrulewidth}{0pt} \renewcommand{\footrulewidth}{0pt} 
+% \fancyhead[LO, LE]{\thepage}
+
+\graphicspath{{fig/}}
+
+\begin {document}
+% \setmainfont[
+%     Ligatures=TeX,
+%     Numbers={OldStyle, Proportional}
+% ]{DejaVu Sans}
+
+\title {
+    \Large{\textbf{RELATÓRIO SOBRE O CÓDIGO FONTE DESTE PROJETO, CONJUNTO ORDENADO}} \\
+    \large{\textbf{projeto este que faz uso da estrutura de dados Red Black}} \\
+    \large {UFES Centro Universitário Norte do Espírito Santo}
+    \author{JOILNEN LEITE \\ \href{mailto:joilnen.leite@edu.ufes.br}
+    {\color{blue}joilnen.leite@edu.ufes.br}}
+%      \footnotesize{Joilnen Leite} 
+%      \footnotesize{UFES Centro Universitário Norte do Espírito Santo} 
+%      \footnotesize{\href{joilnen.leite@edu.ufes.br}}
+    \date{}
+} 
+\maketitle 
+% \thispagestyle{empty}
+% \begin{center}
+%     \Large{\textit{\textbf{Resenha Crítica do ensaio,\\ "Ética e Pesquisa: Autonomia e Heteronomia na Prática Científica"}}}
+%     \footnote{Artigo escrito por Antonio Joaquim Severino}
+% \ \\
+% \end{center}
+% \hrule
+% \ \\
+% \ \\
+% \normalsize{\textit{\textbf{Autor: Joilnen Leite}}}\\
+% \normalsize{\textit{\textbf{Disciplina: Metodologia Científica}}}\\
+% \normalsize{\textit{\textbf{Curso: Ciência da Computação}}}\\
+% \normalsize{\textit{\textbf{Data: 24 de junho de 2020}}}
+% \ \\
+% \hrule
+% \tableofcontents
+% \vspace*{2cm}
+\textbf{Resumo: } Relatório básico sobre os mais comuns tipos de imagem digital e espaço de cores\\
+\ \\
+\indent \textbf{Palavras-chave: } imagens, rastreio, digital, digitalização\\
+\small
+\section {Introdução}
+Neste texto será abordado o uso do histograma com relação ao estudo de imagens
+digitais.
+
+\section{Conceito de Contraste}
+Contraste é a medida da diferença entre as áreas claras e escuras de uma imagem
+
+
+\section{Histograma e suas utilidades}
+Histograma bla bla
+
+\subsection{Modificação de Histograma}
+Mod de Histograma bla bla
+
+\subsection{Equalização do Histograma}
+Equali de Histograma bla bla
+
+\subsection{Algorítmo de Equalização do Histograma}
+Descrever
+
+\begin{itemize}
+    \item CIE 1931 XYZ é um dos primeiros espaços de cores, onde se criou a relação
+entre a distribuição de ondas eletromagnéticas no espéctro visível e a percepção
+humana das cores. Onde XYZ se refere a um estímulo ternário no olho.
+    \item HSV ou HSL é Matiz, Saturação e Valor ou Luminância, distribuído numa geometria conica ou cilíndrica permite uma distribuíção mais intuítiva das cores
+diferente do cubo RGB.
+    \item CMYK Ciano, Magenta, Amarela e Preto, diferente do espaço RGB que é aditivo
+este espaço de cores funciona subtrativamente e utlizado no caso de impressão
+em papel.
+\end{itemize}
+
+\section{Referências Bibliográficas}
+\nocite{*}
+\bibliography{mybib.bib}{}
+\bibliographystyle{plain}
+
+\end {document}
+
+
diff --git a/src/conjunto_ordenado.h b/src/conjunto_ordenado.h
index d14b82e..95550ee 100644
--- a/src/conjunto_ordenado.h
+++ b/src/conjunto_ordenado.h
@@ -33,6 +33,8 @@ typedef struct rb_n {
 
 /**
  * cria o primeiro noh, o raiz da arvore rb
+ * serah o primeiro elemento criado na arvore
+ * e o primeiro do conjunto ordenado
  */
 #define CRIA_CONJUNTO_ORDENDADO(a, key, dado) \
     rb_n a; \
@@ -49,6 +51,7 @@ int limpa_conjunto(rb_n *a);
 int insere_elemento(rb_n *a, int k, void *e);
 int exclui_elemento(rb_n *a, int k);
 int verifica_pertencimento(rb_n *a, int k);
+int imprime_arvore(rb_n *a, short h);
 
 rb_n* intersecta_conjuntos(rb_n *a, rb_n *b);
 rb_n* une_conjuntos(rb_n *a, rb_n *b);
diff --git a/src/main.c b/src/main.c
index 941ff61..2a3b16c 100644
--- a/src/main.c
+++ b/src/main.c
@@ -6,6 +6,7 @@
  * inclusao da bilioteca implementada baseada em arvores red black
  */
 #include "conjunto_ordenado.h"
+#include <stdio.h>
 #include <string.h>
 
 /**
@@ -49,15 +50,16 @@ void adiciona_alguns_dados()
         char *nome;
         char *telefone;
     } meu_tipo;
-    meu_tipo mt;
+
+    meu_tipo mt0, mt1;
 
     /**
      * criacao do dado para o tipo do usuario
      */
-    mt.nome = (char *) malloc(sizeof("nome para teste") + 1);
-    strncpy(mt.nome, "nome para teste", sizeof("nome para teste") + 1);
-    mt.telefone = (char *) malloc(sizeof("999999999") + 1);
-    strncpy(mt.telefone, "999999999", sizeof("999999999") + 1);
+    mt0.nome = (char *) malloc(sizeof("nome para teste") + 1);
+    strncpy(mt0.nome, "nome para teste", sizeof("nome para teste") + 1);
+    mt0.telefone = (char *) malloc(sizeof("999999999") + 1);
+    strncpy(mt0.telefone, "999999999", sizeof("999999999") + 1);
 
     /**
      * seta a funcao para impressao utiliza aqui a tecnica de ponteiro para funcao
@@ -71,7 +73,42 @@ void adiciona_alguns_dados()
      * @parametro 1 chave do noh raiz
      * @parametro 2 dado criado neste noh, pode ser de qqr tipo
      */
-    CRIA_CONJUNTO_ORDENDADO(conjunto_a, 1, mt);
+    CRIA_CONJUNTO_ORDENDADO(conjunto_a, 10, mt0);
+
+    mt1.nome = (char *) malloc(sizeof("nome para teste") + 1);
+    strncpy(mt1.nome, "nome para teste", sizeof("nome para teste") + 1);
+    mt1.telefone = (char *) malloc(sizeof("999999999") + 1);
+    strncpy(mt1.telefone, "999999999", sizeof("999999999") + 1);
+
+    insere_elemento(&conjunto_a, 9, &mt1);
+}
+
+int imprime_arvore(rb_n *a, short h)
+{
+    rb_n *it = a;
+    int count = h;
+    if(it) 
+    {
+        for(; count; --count) printf(" ");
+        printf("%d%d", it->k, it->c);
+        if(it->l)
+        {
+            for(count = h - 2; h; --h) printf(" ");
+            printf("%d%d", it->l->k, it->l->c);
+
+        }
+        if(it->r)
+        {
+            for(count = h + 2; h; --h) printf(" ");
+            printf("%d%d", it->r->k, it->r->c);
+
+        }
+        printf("\n");
+        imprime_arvore(it->r->r, h - 1);
+        imprime_arvore(it->r->l, h - 1);
+        imprime_arvore(it->l->r, h - 1);
+        imprime_arvore(it->l->l, h - 1);
+    }
 }
 
 
diff --git a/src/makefile b/src/makefile
index 4c47828..bf6a1bd 100644
--- a/src/makefile
+++ b/src/makefile
@@ -6,9 +6,10 @@ C=gcc
 S=main.c conjunto_ordenado.c
 O=main.c conjunto_ordenado.o
 B=rodeme
+D=-g
 
 .c.o:
-	$(C) -c $<
+	$(C) -c $(D) $<
 all: main.o conjunto_ordenado.o
 	$(C) -o $(B) $(O)
 clean:

commit a2ad083e76c0b0ed593fc547e8e45194c5a28ebb
Author: Joilnen <joilnen@gmail.com>
Date:   Thu Dec 16 16:22:28 2021 -0300

    trabalhando o insere

diff --git a/src/conjunto_ordenado.c b/src/conjunto_ordenado.c
index 939de06..c040e29 100644
--- a/src/conjunto_ordenado.c
+++ b/src/conjunto_ordenado.c
@@ -9,25 +9,21 @@ void (*imprime_elemento)(rb_n *);
 
 int imprime_conjunto(rb_n *a)
 {
-
     return 0;
 }
 
 unsigned int cardinalidade(rb_n *a)
 {
-
     return 0;
 }
 
 int ta_vazio(rb_n *a)
 {
-
     return 0;
 }
 
 int limpa_conjunto(rb_n *a)
 {
-
     return 0;
 }
 
@@ -52,25 +48,21 @@ int insere_elemento(rb_n *a, int k, void *e)
 
 int exclui_elemento(rb_n *a, int k)
 {
-
     return 0;
 }
 
 int verifica_pertencimento(rb_n *a, int k)
 {
-
     return 0;
 }
 
 rb_n* intersecta_conjuntos(rb_n *a, rb_n *b)
 {
-
     return NULL;
 }
 
 rb_n* une_conjuntos(rb_n *a, rb_n *b)
 {
-
     return NULL;
 }
 
@@ -81,7 +73,6 @@ rb_n* subtrai_conjuntos(rb_n *a, rb_n *b)
 
 int destroi_conjunto(rb_n *a)
 {
-
     return 0;
 }
 
@@ -135,3 +126,4 @@ int seta_imprime_elemento(void (*i)(rb_n *n))
 }
 
 
+

commit bdba4da62308482975f9a2fc8f7ac829e0507880
Author: Joilnen <joilnen@gmail.com>
Date:   Fri Dec 17 10:41:30 2021 -0300

    comeco da documentacao (relatorio) e foi consertado o insere

diff --git a/doc/tex/relatorio.pdf b/doc/tex/relatorio.pdf
index c748d51..05f6b10 100644
Binary files a/doc/tex/relatorio.pdf and b/doc/tex/relatorio.pdf differ
diff --git a/doc/tex/relatorio.tex b/doc/tex/relatorio.tex
index c79ccbd..e79cb0a 100644
--- a/doc/tex/relatorio.tex
+++ b/doc/tex/relatorio.tex
@@ -1,14 +1,45 @@
 \documentclass [a4paper, 12pt] {article}
 
 \input{packages}
+\usepackage{fancyvrb}
 % \usepackage{fancyhdr}
 % \pagestyle{fancy}
 
 % \fancyhead{}
 % \fancyfoot{}
+\usepackage{listings}
+\usepackage{xcolor}
+
+\definecolor{codegreen}{rgb}{0,0.6,0}
+\definecolor{codegray}{rgb}{0.5,0.5,0.5}
+\definecolor{codepurple}{rgb}{0.58,0,0.82}
+\definecolor{backcolour}{rgb}{0.95,0.95,0.92}
+
+\lstdefinestyle{mystyle}{
+    backgroundcolor=\color{backcolour},   
+    commentstyle=\color{codegreen},
+    keywordstyle=\color{magenta},
+    numberstyle=\tiny\color{codegray},
+    stringstyle=\color{codepurple},
+    basicstyle=\ttfamily\tiny,
+    breakatwhitespace=false,         
+    breaklines=true,                 
+    captionpos=b,                    
+    keepspaces=true,                 
+    numbers=left,                    
+    numbersep=5pt,                  
+    showspaces=false,                
+    showstringspaces=false,
+    showtabs=false,                  
+    frame=single,
+    tabsize=2
+}
+
+\lstset{style=mystyle}
 
 % \renewcommand{\headrulewidth}{0pt} \renewcommand{\footrulewidth}{0pt} 
 % \fancyhead[LO, LE]{\thepage}
+\newcommand{\enf}[1]{\emph{\textbf{#1}}}
 
 \graphicspath{{fig/}}
 
@@ -32,7 +63,7 @@
 \maketitle 
 % \thispagestyle{empty}
 % \begin{center}
-%     \Large{\textit{\textbf{Resenha Crítica do ensaio,\\ "Ética e Pesquisa: Autonomia e Heteronomia na Prática Científica"}}}
+%     \Large{\textit{\textbf{Resenha Crítica do ensaio,\\ "}Ética e Pesquisa: Autonomia e Heteronomia na Prática Científica"}}}
 %     \footnote{Artigo escrito por Antonio Joaquim Severino}
 % \ \\
 % \end{center}
@@ -47,42 +78,51 @@
 % \hrule
 % \tableofcontents
 % \vspace*{2cm}
-\textbf{Resumo: } Relatório básico sobre os mais comuns tipos de imagem digital e espaço de cores\\
+\textbf{Resumo: } Relatório básico sobre o conteúdo e processo de desenvolvimento 
+da atividade conjunto ordenado \\
 \ \\
-\indent \textbf{Palavras-chave: } imagens, rastreio, digital, digitalização\\
+\indent \textbf{Palavras-chave: } fontes, C, Red Black, Conjunto\\
 \small
 \section {Introdução}
-Neste texto será abordado o uso do histograma com relação ao estudo de imagens
-digitais.
-
-\section{Conceito de Contraste}
-Contraste é a medida da diferença entre as áreas claras e escuras de uma imagem
-
-
-\section{Histograma e suas utilidades}
-Histograma bla bla
-
-\subsection{Modificação de Histograma}
-Mod de Histograma bla bla
-
-\subsection{Equalização do Histograma}
-Equali de Histograma bla bla
-
-\subsection{Algorítmo de Equalização do Histograma}
-Descrever
-
-\begin{itemize}
-    \item CIE 1931 XYZ é um dos primeiros espaços de cores, onde se criou a relação
-entre a distribuição de ondas eletromagnéticas no espéctro visível e a percepção
-humana das cores. Onde XYZ se refere a um estímulo ternário no olho.
-    \item HSV ou HSL é Matiz, Saturação e Valor ou Luminância, distribuído numa geometria conica ou cilíndrica permite uma distribuíção mais intuítiva das cores
-diferente do cubo RGB.
-    \item CMYK Ciano, Magenta, Amarela e Preto, diferente do espaço RGB que é aditivo
-este espaço de cores funciona subtrativamente e utlizado no caso de impressão
-em papel.
-\end{itemize}
-
-\section{Referências Bibliográficas}
+Esta biblioteca é composta por dois arquivos, conjunto\_ordenado.c e seu cabeçalho,
+conjunto\_ordenado.h, sendo necessário apenas para seu uso a inclusão via, \\
+\enf{\#include "conjunto\_ordenado.h"} e compilação conjunta com conjunto\_ordenado.c
+
+Além da convencional inclusão e compilação, o usuário da biblioteca, pessoa
+que escreve o programa cliente, aqui neste trabalho exemplificado pelo o arquivo \enf{main.c}
+deverá escolher definir seu tipo dado, através de uma struct ou utilizar um tipo de dado nativo da 
+linguagem.
+\renewcommand{\lstlistingname}{Fonte}
+\begin{lstlisting}[language=c, caption={Exemplo do uso da biblioteca conjunto_ordenado}]
+
+#include "conjunto_ordenado.h"
+
+int main()
+{
+    typedef struct {
+        char *nome;
+        char *telefone;
+    } meu_tipo;
+    meu_tipo mt0, mt1;
+    mt0.nome = (char *) malloc(sizeof("nome para teste") + 1);
+    strncpy(mt0.nome, "nome para teste", sizeof("nome para teste") + 1);
+    mt0.telefone = (char *) malloc(sizeof("999999999") + 1);
+    strncpy(mt0.telefone, "999999999", sizeof("999999999") + 1);
+
+    seta_imprime_elemento(imprime_meu_tipo);
+
+    CRIA_CONJUNTO_ORDENDADO(conjunto_a, 10, mt0);
+    mt1.nome = (char *) malloc(sizeof("nome para teste") + 1);
+    strncpy(mt1.nome, "nome para teste", sizeof("nome para teste") + 1);
+    mt1.telefone = (char *) malloc(sizeof("999999999") + 1);
+    strncpy(mt1.telefone, "999999999", sizeof("999999999") + 1);
+
+    insere_elemento(&conjunto_a, 9, &mt1);
+}
+
+
+\end{lstlisting}
+% \section{Referências Bibliográficas}
 \nocite{*}
 \bibliography{mybib.bib}{}
 \bibliographystyle{plain}
diff --git a/src/conjunto_ordenado.c b/src/conjunto_ordenado.c
index c040e29..67596da 100644
--- a/src/conjunto_ordenado.c
+++ b/src/conjunto_ordenado.c
@@ -4,6 +4,7 @@
  * de implementacao das funcoes da biblioteca conjunto ordenado
  */
 #include "conjunto_ordenado.h"
+#include <stdio.h>
 
 void (*imprime_elemento)(rb_n *);
 
@@ -30,6 +31,7 @@ int limpa_conjunto(rb_n *a)
 int insere_elemento(rb_n *a, int k, void *e)
 {
     rb_n *it = a;
+    printf("k %d it->k %d\n", k, it->k);
     while (it)
     {
         if (k < it->k)
@@ -41,6 +43,7 @@ int insere_elemento(rb_n *a, int k, void *e)
             it = e;
             it->k = k;
             it->l = it->r = NULL;
+            it = NULL;
         }
     }
     return 0;

commit 6874ee55997cb34d17ac04f65a2e294903af3747
Author: Joilnen <joilnen@gmail.com>
Date:   Fri Dec 17 13:56:50 2021 -0300

    melhorando o relatorio

diff --git a/doc/tex/relatorio.pdf b/doc/tex/relatorio.pdf
index 05f6b10..aec8bba 100644
Binary files a/doc/tex/relatorio.pdf and b/doc/tex/relatorio.pdf differ
diff --git a/doc/tex/relatorio.tex b/doc/tex/relatorio.tex
index e79cb0a..829d600 100644
--- a/doc/tex/relatorio.tex
+++ b/doc/tex/relatorio.tex
@@ -94,7 +94,6 @@ deverá escolher definir seu tipo dado, através de uma struct ou utilizar um ti
 linguagem.
 \renewcommand{\lstlistingname}{Fonte}
 \begin{lstlisting}[language=c, caption={Exemplo do uso da biblioteca conjunto_ordenado}]
-
 #include "conjunto_ordenado.h"
 
 int main()
@@ -119,9 +118,80 @@ int main()
 
     insere_elemento(&conjunto_a, 9, &mt1);
 }
+\end{lstlisting}
 
+\section{Lista de Estruturas e Funções Implementadas}
+Como foi especificado a estrutura de dados utilizada para guardar os dados neste projeto 
+é a árvore binária de busca Red Black, no código esta árvore e seus nós são representados
+pela estrutura \enf{rb_n}\footnote{Red Black Node ou nó Red Black}, a semântica escolhida
+é a seguinte, representamos apenas os nós e seus relacionamentos, a árvore completa fica
+referenciada no ato da criação do nó raiz no código cliente, logo no exemplo acima
+temos uma árvore nomeada \enf{conjunto_a}, enquanto nós filhos nessa árvore é adicionado 
+com \enf{insere_elemento}
+\ \\
 
+\noindent Estrutura principal
+\begin{lstlisting}[language=c, caption={Nó Red Black}]
+/**
+ * composicao do noh da RB
+ * @rb_n noh red black
+ * @k chave (k de key)
+ * @c cor (c de color ou cor, 0-black, 1-red)
+ * @t tipo (t de tipo ou type)
+ * @d dado (de de data ou dados)
+ * @l @r @p l-eft filho a esquerda, r-ight filho a direta e p-arent, noh pai
+ */
+typedef struct rb_n {
+    int k;
+    char c:1;
+    void *d;
+    struct rb_n *l, *r, *p;
+} rb_n;
 \end{lstlisting}
+Significado dos componentes da estrutura \enf{rb_n}
+\begin{itemize}
+    \item \enf{k} - chave
+    \item \enf{c} - cor (0 - preto e 1 - vermelho, apenas o primeiro bit utilizado)
+    \item \enf{d} - dado generico
+    \item \enf{l, r, p} - ponteiro para filho a esquerda, filho a direita e nó pai
+\end{itemize}
+Funções que manipulam os nós na Árvore
+\begin{lstlisting}[language=c, caption={Funções da biblioteca}]
+/**
+ * cria o primeiro noh, o raiz da arvore rb
+ * serah o primeiro elemento criado na arvore
+ * e o primeiro do conjunto ordenado
+ */
+#define CRIA_CONJUNTO_ORDENDADO(a, key, dado) \
+    rb_n a; \
+    a.k = key; \
+    a.c = 0; \
+    a.d = &dado; \
+    a.p = a.l = a.r = NULL;
+int imprime_conjunto(rb_n *a);
+unsigned int cardinalidade(rb_n *a);
+int ta_vazio(rb_n *a);
+int limpa_conjunto(rb_n *a);
+
+int insere_elemento(rb_n *a, int k, void *e);
+int exclui_elemento(rb_n *a, int k);
+int verifica_pertencimento(rb_n *a, int k);
+int imprime_arvore(rb_n *a, short h);
+
+rb_n* intersecta_conjuntos(rb_n *a, rb_n *b);
+rb_n* une_conjuntos(rb_n *a, rb_n *b);
+rb_n* subtrai_conjuntos(rb_n *a, rb_n *b);
+
+int destroi_conjunto(rb_n *a);
+
+int troca_cor(rb_n *a);
+int rotaciona_esquerda(rb_n *r, rb_n *w);
+int rotaciona_direita(rb_n *r, rb_n *w);
+
+void (*imprime_elemento)(rb_n *);
+int seta_imprime_elemento(void (*i)(rb_n *n));
+\end{lstlisting}
+
 % \section{Referências Bibliográficas}
 \nocite{*}
 \bibliography{mybib.bib}{}
diff --git a/src/conjunto_ordenado.c b/src/conjunto_ordenado.c
index 67596da..bc239c3 100644
--- a/src/conjunto_ordenado.c
+++ b/src/conjunto_ordenado.c
@@ -32,6 +32,8 @@ int insere_elemento(rb_n *a, int k, void *e)
 {
     rb_n *it = a;
     printf("k %d it->k %d\n", k, it->k);
+    if((int)k == (int)(it->k))
+        return -1;
     while (it)
     {
         if (k < it->k)

commit 14a0694781b3e7d9c64213ed69ee844863c48a96
Author: Joilnen <joilnen@gmail.com>
Date:   Fri Dec 17 15:54:03 2021 -0300

    atualizando ignore file from git

diff --git a/.gitignore b/.gitignore
index 0446a97..15638f0 100644
--- a/.gitignore
+++ b/.gitignore
@@ -5,3 +5,7 @@
 tags
 rodeme
 latex.out
+*.aux
+*.idx
+*.log
+*.out

commit a6ddf09704424642cc4cf37772a27843e3af636a
Author: Joilnen <joilnen@gmail.com>
Date:   Fri Dec 17 17:28:30 2021 -0300

    modificado para deixar o TAD mais explicito embora a abstracao ja feita
    sobre rb estritamente ja seria um TAD

diff --git a/rd.h b/rd.h
new file mode 100644
index 0000000..e69de29
diff --git a/src/conjunto_ordenado.c b/src/conjunto_ordenado.c
index bc239c3..8e3abe4 100644
--- a/src/conjunto_ordenado.c
+++ b/src/conjunto_ordenado.c
@@ -1,134 +1,20 @@
-/**
- * aluno: joilnen leite
- * arquivo separado do main, como especificado 
- * de implementacao das funcoes da biblioteca conjunto ordenado
- */
 #include "conjunto_ordenado.h"
-#include <stdio.h>
 
-void (*imprime_elemento)(rb_n *);
-
-int imprime_conjunto(rb_n *a)
+conjord *conjord_cria()
 {
-    return 0;
-}
-
-unsigned int cardinalidade(rb_n *a)
-{
-    return 0;
-}
+    conjord *c = (conjord *) malloc (sizeof(conjord));
+    c->raiz = NULL;
+    c->cardinalidade = 0;
 
-int ta_vazio(rb_n *a)
-{
-    return 0;
+    return c;
 }
 
-int limpa_conjunto(rb_n *a)
+int conjord_eh_vazio(conjord *a)
 {
-    return 0;
+    return !a->raiz;
 }
 
-int insere_elemento(rb_n *a, int k, void *e)
+int conjord_esvazia(conjord *a)
 {
-    rb_n *it = a;
-    printf("k %d it->k %d\n", k, it->k);
-    if((int)k == (int)(it->k))
-        return -1;
-    while (it)
-    {
-        if (k < it->k)
-            it = it->l;
-        else if (k > it->k)
-            it = it->r;
-        if (!it)
-        {
-            it = e;
-            it->k = k;
-            it->l = it->r = NULL;
-            it = NULL;
-        }
-    }
-    return 0;
-}
 
-int exclui_elemento(rb_n *a, int k)
-{
-    return 0;
 }
-
-int verifica_pertencimento(rb_n *a, int k)
-{
-    return 0;
-}
-
-rb_n* intersecta_conjuntos(rb_n *a, rb_n *b)
-{
-    return NULL;
-}
-
-rb_n* une_conjuntos(rb_n *a, rb_n *b)
-{
-    return NULL;
-}
-
-rb_n* subtrai_conjuntos(rb_n *a, rb_n *b)
-{
-    return NULL;
-}
-
-int destroi_conjunto(rb_n *a)
-{
-    return 0;
-}
-
-int rotaciona_esquerda(rb_n *r, rb_n *w)
-{
-    rb_n *v = w->r;
-    w->r = v->l;
-    if (v->l)
-        v->l->p = w;
-    v->p = w->p;
-    if (!w->p)
-        r = v;
-    else
-    {
-        if (w == w->p->l)
-            w->p->l = v;
-        else
-            w->p->r = v;
-    }
-    v->l = w;
-    w->p = v;
-
-    return 0;
-}
-
-int rotaciona_direita(rb_n *r, rb_n *w)
-{
-    rb_n *v = w->l;
-    w->l = v->r;
-    if (v->r)
-        v->r->p = w;
-    v->p = w->p;
-    if (!w->p)
-        r = v;
-    else
-    {
-        if (w == w->p->r)
-            w->p->r = v;
-        else
-            w->p->l = v;
-    }
-    v->r = w;
-    w->p = v;
-
-    return 0;
-}
-
-int seta_imprime_elemento(void (*i)(rb_n *n))
-{
-    imprime_elemento = i;
-}
-
-
-
diff --git a/src/conjunto_ordenado.h b/src/conjunto_ordenado.h
index 95550ee..d8ac556 100644
--- a/src/conjunto_ordenado.h
+++ b/src/conjunto_ordenado.h
@@ -1,70 +1,34 @@
 #ifndef CONJUNTO_ORDENADO_H
 #define CONJUNTO_ORDENADO_H
 
-/**
- * aluno: joilnen leite
- */
-#include <stdlib.h>
-
-/**
- * rubro negra
- * 0 - todo noh eh vermelho ou preto
- * 1 - raiz sempre preta
- * 2 - noh NULL considerado noh externo preto
- * 3 - vermelhos tem filhos pretos
- * 4 - noh para suas folhas tem o mesmo numero de nohs preto
- */
-
-/**
- * composicao do noh da RB
- * @rb_n noh red black
- * @k chave (k de key)
- * @c cor (c de color ou cor, 0-black, 1-red)
- * @t tipo (t de tipo ou type)
- * @d dado (de de data ou dados)
- * @l @r @p l-eft filho a esquerda, r-ight filho a direta e p-arent, noh pai
- */
-typedef struct rb_n {
-    int k;
-    char c:1;
-    void *d;
-    struct rb_n *l, *r, *p;
-} rb_n;
+#include "red_black.h"
 
 /**
- * cria o primeiro noh, o raiz da arvore rb
- * serah o primeiro elemento criado na arvore
- * e o primeiro do conjunto ordenado
+ * estrutura da TAD explicitamente
+ * esta estrutura oculta o uso da red black
+ * suas funcoes e funcionamento interno do cliente
  */
-#define CRIA_CONJUNTO_ORDENDADO(a, key, dado) \
-    rb_n a; \
-    a.k = key; \
-    a.c = 0; \
-    a.d = &dado; \
-    a.p = a.l = a.r = NULL;
-
-int imprime_conjunto(rb_n *a);
-unsigned int cardinalidade(rb_n *a);
-int ta_vazio(rb_n *a);
-int limpa_conjunto(rb_n *a);
-
-int insere_elemento(rb_n *a, int k, void *e);
-int exclui_elemento(rb_n *a, int k);
-int verifica_pertencimento(rb_n *a, int k);
-int imprime_arvore(rb_n *a, short h);
-
-rb_n* intersecta_conjuntos(rb_n *a, rb_n *b);
-rb_n* une_conjuntos(rb_n *a, rb_n *b);
-rb_n* subtrai_conjuntos(rb_n *a, rb_n *b);
-
-int destroi_conjunto(rb_n *a);
-
-int troca_cor(rb_n *a);
-int rotaciona_esquerda(rb_n *r, rb_n *w);
-int rotaciona_direita(rb_n *r, rb_n *w);
-
-extern void (*imprime_elemento)(rb_n *);
-int seta_imprime_elemento(void (*i)(rb_n *n));
+typedef struct conjord {
+    rb_n *raiz;
+    int cardinalidade;
+} conjord;
+
+conjord *conjord_cria();
+void conjord_imprime();
+unsigned int conjord_cardinalidade();
+int conjord_eh_vazio();
+int conjord_esvazia();
+void conjord_destroi(conjord **a);
+
+void conjord_insere_elemento(conjord *a, int chave, void *elemento);
+void conjord_exclui_elemento(conjord *a, int chave);
+int conjord_existe_elemento(conjord *a, int chave);
+
+conjord *conjord_interseciona(conjord *a, conjord *b);
+conjord *conjord_une(conjord *a, conjord *b);
+conjord *conjord_subtrai(conjord *a, conjord *b);
+
+void conjord_imprime_rb();
 
 #endif
 
diff --git a/src/main.c b/src/main.c
index 2a3b16c..d3744d9 100644
--- a/src/main.c
+++ b/src/main.c
@@ -15,33 +15,10 @@
  */
 void imprime_meu_tipo(rb_n *);
 
-/**
- * funcao que adiciona alguns dados de teste
- */
-void adiciona_alguns_dados();
-
 /**
  * funcao main de teste separada do codigo da biblioteca como especificado
  */
 int main()
-{
-    adiciona_alguns_dados();
-}
-
-/**
- * definicao da funcao de impressao estipulado pelo cliente, aqui apenas um
- * exemplo
- */
-void imprime_meu_tipo(rb_n *n)
-{
-
-
-}
-
-/**
- * funcao que adiciona alguns dados de teste
- */
-void adiciona_alguns_dados()
 {
     /**
      * definicao de um tipo exemplo pelo o usuario
@@ -64,7 +41,7 @@ void adiciona_alguns_dados()
     /**
      * seta a funcao para impressao utiliza aqui a tecnica de ponteiro para funcao
      */
-    seta_imprime_elemento(imprime_meu_tipo);
+    rb_seta_impr_elem(imprime_meu_tipo);
 
     /**
      * cria noh raiz, utiliza a tecnica de macro pois simplifica e deixa
@@ -80,7 +57,10 @@ void adiciona_alguns_dados()
     mt1.telefone = (char *) malloc(sizeof("999999999") + 1);
     strncpy(mt1.telefone, "999999999", sizeof("999999999") + 1);
 
-    insere_elemento(&conjunto_a, 9, &mt1);
+    rb_ins_elem(&conjunto_a, 9, &mt1);
+
+    conjord *conj_a = conjord_cria();
+    printf("eh vazio %d", conjord_eh_vazio(conj_a));
 }
 
 int imprime_arvore(rb_n *a, short h)
@@ -111,4 +91,14 @@ int imprime_arvore(rb_n *a, short h)
     }
 }
 
+/**
+ * definicao da funcao de impressao estipulado pelo cliente, aqui apenas um
+ * exemplo
+ */
+void imprime_meu_tipo(rb_n *n)
+{
+
+
+}
+
 
diff --git a/src/makefile b/src/makefile
index bf6a1bd..6fe7410 100644
--- a/src/makefile
+++ b/src/makefile
@@ -3,14 +3,14 @@
 #
 
 C=gcc
-S=main.c conjunto_ordenado.c
-O=main.c conjunto_ordenado.o
+S=main.c conjunto_ordenado.c red_black.c
+O=main.o conjunto_ordenado.o red_black.o
 B=rodeme
 D=-g
 
 .c.o:
 	$(C) -c $(D) $<
-all: main.o conjunto_ordenado.o
+all: $(O) 
 	$(C) -o $(B) $(O)
 clean:
 	rm -f *.o $(B)
diff --git a/src/red_black.c b/src/red_black.c
new file mode 100644
index 0000000..83b4bbe
--- /dev/null
+++ b/src/red_black.c
@@ -0,0 +1,108 @@
+/**
+ * aluno: joilnen leite
+ * arquivo separado do main, como especificado 
+ * de implementacao das funcoes da redblack 
+ * utilizada no conjunto ordenado
+ */
+#include "red_black.h"
+#include <stdio.h>
+
+void (*rb_impr_elem)(rb_n *);
+
+int rb_ins_elem(rb_n *a, int k, void *e)
+{
+    rb_n *it = a;
+    printf("k %d it->k %d\n", k, it->k);
+    if((int)k == (int)(it->k))
+        return -1;
+    while (it)
+    {
+        if (k < it->k)
+            it = it->l;
+        else if (k > it->k)
+            it = it->r;
+        if (!it)
+        {
+            it = e;
+            it->k = k;
+            it->l = it->r = NULL;
+            it = NULL;
+        }
+    }
+    return 0;
+}
+
+int rb_exclui_elem(rb_n *a, int k)
+{
+    return 0;
+}
+
+rb_n* rb_intersec(rb_n *a, rb_n *b)
+{
+    return NULL;
+}
+
+rb_n* rb_une(rb_n *a, rb_n *b)
+{
+    return NULL;
+}
+
+rb_n* rb_subtrai(rb_n *a, rb_n *b)
+{
+    return NULL;
+}
+
+int rb_destroi(rb_n **a)
+{
+    return 0;
+}
+
+int rb_rot_esq(rb_n *r, rb_n *w)
+{
+    rb_n *v = w->r;
+    w->r = v->l;
+    if (v->l)
+        v->l->p = w;
+    v->p = w->p;
+    if (!w->p)
+        r = v;
+    else
+    {
+        if (w == w->p->l)
+            w->p->l = v;
+        else
+            w->p->r = v;
+    }
+    v->l = w;
+    w->p = v;
+
+    return 0;
+}
+
+int rb_rot_dir(rb_n *r, rb_n *w)
+{
+    rb_n *v = w->l;
+    w->l = v->r;
+    if (v->r)
+        v->r->p = w;
+    v->p = w->p;
+    if (!w->p)
+        r = v;
+    else
+    {
+        if (w == w->p->r)
+            w->p->r = v;
+        else
+            w->p->l = v;
+    }
+    v->r = w;
+    w->p = v;
+
+    return 0;
+}
+
+int rb_seta_impr_elem(void (*i)(rb_n *n))
+{
+    rb_impr_elem = i;
+}
+
diff --git a/src/red_black.h b/src/red_black.h
new file mode 100644
index 0000000..dd06325
--- /dev/null
+++ b/src/red_black.h
@@ -0,0 +1,65 @@
+#ifndef REDBLACK_H
+#define REDBLACK_H
+
+/**
+ * aluno: joilnen leite
+ */
+#include <stdlib.h>
+
+/**
+ * rubro negra
+ * 0 - todo noh eh vermelho ou preto
+ * 1 - raiz sempre preta
+ * 2 - noh NULL considerado noh externo preto
+ * 3 - vermelhos tem filhos pretos
+ * 4 - noh para suas folhas tem o mesmo numero de nohs preto
+ */
+
+/**
+ * composicao do noh da RB
+ * @rb_n noh red black
+ * @k chave (k de key)
+ * @c cor (c de color ou cor, 0-black, 1-red)
+ * @t tipo (t de tipo ou type)
+ * @d dado (de de data ou dados)
+ * @l @r @p l-eft filho a esquerda, r-ight filho a direta e p-arent, noh pai
+ */
+typedef struct rb_n {
+    int k;
+    char c:1;
+    void *d;
+    struct rb_n *l, *r, *p;
+} rb_n;
+
+/**
+ * cria o primeiro noh, o raiz da arvore rb
+ * serah o primeiro elemento criado na arvore
+ * e o primeiro do conjunto ordenado
+ */
+#define CRIA_CONJUNTO_ORDENDADO(a, key, dado) \
+    rb_n a; \
+    a.k = key; \
+    a.c = 0; \
+    a.d = &dado; \
+    a.p = a.l = a.r = NULL;
+
+unsigned int rb_nelem(rb_n *a);
+
+int rb_ins_elem(rb_n *a, int k, void *e);
+int rb_exclui_elem(rb_n *a, int k);
+int rb_exite_elem(rb_n *a, int k);
+
+rb_n* rb_intersec(rb_n *a, rb_n *b);
+rb_n* rb_une(rb_n *a, rb_n *b);
+rb_n* rb_subtrai(rb_n *a, rb_n *b);
+
+int rb_destroi(rb_n **a);
+
+int rb_troca_cor(rb_n *a);
+int rb_rot_esq(rb_n *r, rb_n *w);
+int rb_rot_dir(rb_n *r, rb_n *w);
+
+extern void (*rb_impr_elem)(rb_n *);
+int rb_seta_impr_elem(void (*i)(rb_n *n));
+
+#endif

commit c041733699cd48be8fa20ea17c05818bd2b8029d
Author: Joilnen <joilnen@gmail.com>
Date:   Fri Dec 17 17:34:49 2021 -0300

    deletado arquivo n utilizado

diff --git a/rd.h b/rd.h
deleted file mode 100644
index e69de29..0000000

commit 4f9bda9d86348ebbb9321d64f9adca5e1e00ac74
Author: Joilnen <joilnen@gmail.com>
Date:   Fri Dec 17 18:02:48 2021 -0300

    acentuando as palavras em portugues

diff --git a/LEIAME b/LEIAME
index 17b9ab4..9c99c20 100644
--- a/LEIAME
+++ b/LEIAME
@@ -1,10 +1,10 @@
-dentro do diretorio docs estao relatorios e arquivos
+dentro do diretorio docs estãoo relatórios e arquivos
 relacionados ao processo de desenvolvimento
 
-binario sera gerado no mesmo diretorio dos fontes,
-src, atraves do comando make local
-dentro daquele diretorio, binario nomeado, rodeme
-comando a ser utilizado 
+executável será gerado no mesmo diretório dos fontes,
+src, através do comando, make
+dentro daquele diretorio, executável nomeado, rodeme
+comandos a ser utilizado 
 
 make # para criar o binario
 make clean # para limpar, apagar objetos e binario

commit 2de82428748b3dee13cda5a9602f720f71f6cbce
Author: Joilnen <joilnen@gmail.com>
Date:   Fri Dec 17 18:27:36 2021 -0300

    uma comparacao de chaves

diff --git a/src/red_black.c b/src/red_black.c
index 83b4bbe..269668f 100644
--- a/src/red_black.c
+++ b/src/red_black.c
@@ -106,3 +106,4 @@ int rb_seta_impr_elem(void (*i)(rb_n *n))
     rb_impr_elem = i;
 }
 
+

commit bfeb9970eb1c1217637327a65d437731aa68fbd3
Author: Joilnen <joilnen@gmail.com>
Date:   Sat Dec 18 06:28:01 2021 -0300

    reescrevendo rb para ficar oculta em outra camada que serah o TAD

diff --git a/src/main.c b/src/main.c
index d3744d9..858819d 100644
--- a/src/main.c
+++ b/src/main.c
@@ -50,17 +50,20 @@ int main()
      * @parametro 1 chave do noh raiz
      * @parametro 2 dado criado neste noh, pode ser de qqr tipo
      */
-    CRIA_CONJUNTO_ORDENDADO(conjunto_a, 10, mt0);
+    rb_n *conjunto_a = rb_cr(10, &mt0);
 
     mt1.nome = (char *) malloc(sizeof("nome para teste") + 1);
     strncpy(mt1.nome, "nome para teste", sizeof("nome para teste") + 1);
     mt1.telefone = (char *) malloc(sizeof("999999999") + 1);
     strncpy(mt1.telefone, "999999999", sizeof("999999999") + 1);
 
-    rb_ins_elem(&conjunto_a, 9, &mt1);
+    rb_ins_elem(conjunto_a, 9, (meu_tipo *)&mt1);
 
+    /**
+     * testando apenas rb no momento
     conjord *conj_a = conjord_cria();
     printf("eh vazio %d", conjord_eh_vazio(conj_a));
+    */
 }
 
 int imprime_arvore(rb_n *a, short h)
diff --git a/src/red_black.c b/src/red_black.c
index 269668f..4967af2 100644
--- a/src/red_black.c
+++ b/src/red_black.c
@@ -9,6 +9,17 @@
 
 void (*rb_impr_elem)(rb_n *);
 
+rb_n* rb_cr(int key, void *dado)
+{
+    rb_n *a = (rb_n *) malloc(sizeof(rb_n));
+    a->k = key;
+    a->c = 0;
+    a->d = dado;
+    a->p = a->l = a->r = NULL;
+
+    return a;
+}
+
 int rb_ins_elem(rb_n *a, int k, void *e)
 {
     rb_n *it = a;
@@ -23,13 +34,16 @@ int rb_ins_elem(rb_n *a, int k, void *e)
             it = it->r;
         if (!it)
         {
-            it = e;
+            it = (rb_n *) malloc(sizeof(rb_n));
+            it->d = e;
             it->k = k;
             it->l = it->r = NULL;
             it = NULL;
+            return 0;
         }
     }
-    return 0;
+
+    return -1;
 }
 
 int rb_exclui_elem(rb_n *a, int k)
diff --git a/src/red_black.h b/src/red_black.h
index dd06325..fa661c7 100644
--- a/src/red_black.h
+++ b/src/red_black.h
@@ -36,12 +36,7 @@ typedef struct rb_n {
  * serah o primeiro elemento criado na arvore
  * e o primeiro do conjunto ordenado
  */
-#define CRIA_CONJUNTO_ORDENDADO(a, key, dado) \
-    rb_n a; \
-    a.k = key; \
-    a.c = 0; \
-    a.d = &dado; \
-    a.p = a.l = a.r = NULL;
+rb_n* rb_cr(int key, void *dado);
 
 unsigned int rb_nelem(rb_n *a);
 

commit 36248abc22a056b90f828d4580dd668c9e3fc08e
Author: Joilnen <joilnen@gmail.com>
Date:   Sat Dec 18 07:18:33 2021 -0300

    inserir e imprimir funcionando ainda bem rudimentarmente, mas ja funciona

diff --git a/src/main.c b/src/main.c
index 858819d..817bc54 100644
--- a/src/main.c
+++ b/src/main.c
@@ -28,11 +28,11 @@ int main()
         char *telefone;
     } meu_tipo;
 
-    meu_tipo mt0, mt1;
 
     /**
      * criacao do dado para o tipo do usuario
      */
+    meu_tipo mt0;
     mt0.nome = (char *) malloc(sizeof("nome para teste") + 1);
     strncpy(mt0.nome, "nome para teste", sizeof("nome para teste") + 1);
     mt0.telefone = (char *) malloc(sizeof("999999999") + 1);
@@ -52,12 +52,21 @@ int main()
      */
     rb_n *conjunto_a = rb_cr(10, &mt0);
 
+    meu_tipo mt1;
     mt1.nome = (char *) malloc(sizeof("nome para teste") + 1);
     strncpy(mt1.nome, "nome para teste", sizeof("nome para teste") + 1);
     mt1.telefone = (char *) malloc(sizeof("999999999") + 1);
     strncpy(mt1.telefone, "999999999", sizeof("999999999") + 1);
+    rb_ins_elem(conjunto_a, 9, &mt1);
 
-    rb_ins_elem(conjunto_a, 9, (meu_tipo *)&mt1);
+    meu_tipo mt2;
+    mt2.nome = (char *) malloc(sizeof("nome para teste") + 1);
+    strncpy(mt2.nome, "nome para teste", sizeof("nome para teste") + 1);
+    mt2.telefone = (char *) malloc(sizeof("999999999") + 1);
+    strncpy(mt2.telefone, "999999999", sizeof("999999999") + 1);
+    rb_ins_elem(conjunto_a, 11, &mt2);
+
+    rb_pr(conjunto_a);
 
     /**
      * testando apenas rb no momento
@@ -101,7 +110,6 @@ int imprime_arvore(rb_n *a, short h)
 void imprime_meu_tipo(rb_n *n)
 {
 
-
 }
 
 
diff --git a/src/red_black.c b/src/red_black.c
index 4967af2..c658162 100644
--- a/src/red_black.c
+++ b/src/red_black.c
@@ -24,21 +24,29 @@ int rb_ins_elem(rb_n *a, int k, void *e)
 {
     rb_n *it = a;
     printf("k %d it->k %d\n", k, it->k);
-    if((int)k == (int)(it->k))
-        return -1;
     while (it)
     {
+        rb_n *tmp = it;
+        char rl = 0;
         if (k < it->k)
-            it = it->l;
+            it = it->l, rl = 0 << 0;
         else if (k > it->k)
-            it = it->r;
+            it = it->r, rl = 1 << 0;
+        else return -1;
+
+        printf("rl %d\n", rl);
+
         if (!it)
         {
             it = (rb_n *) malloc(sizeof(rb_n));
             it->d = e;
             it->k = k;
             it->l = it->r = NULL;
-            it = NULL;
+
+            if (rl == 0)
+                tmp->l = it;
+            else if(rl == 1)
+                tmp->r = it;
             return 0;
         }
     }
@@ -120,4 +128,14 @@ int rb_seta_impr_elem(void (*i)(rb_n *n))
     rb_impr_elem = i;
 }
 
+void rb_pr(rb_n *a)
+{
+    if (a)
+    {
+        printf("k:%dc:%d\n", a->k, a->c);
+        rb_pr(a->l);
+        rb_pr(a->r);
+    }
+}
+
 
diff --git a/src/red_black.h b/src/red_black.h
index fa661c7..b16d42f 100644
--- a/src/red_black.h
+++ b/src/red_black.h
@@ -57,4 +57,6 @@ int rb_rot_dir(rb_n *r, rb_n *w);
 extern void (*rb_impr_elem)(rb_n *);
 int rb_seta_impr_elem(void (*i)(rb_n *n));
 
+void rb_pr(rb_n *a);
+
 #endif

commit e90e4e2fa485991daa656fb16ca4f655c898e815
Author: Joilnen <joilnen@gmail.com>
Date:   Sat Dec 18 13:32:42 2021 -0300

    adicionando doxygen para a documentacao auxiliar

diff --git a/.gitignore b/.gitignore
index 15638f0..03aa2e7 100644
--- a/.gitignore
+++ b/.gitignore
@@ -9,3 +9,5 @@ latex.out
 *.idx
 *.log
 *.out
+doc/latex
+doc/html
diff --git a/Doxyfile b/Doxyfile
new file mode 100644
index 0000000..4f86eef
--- /dev/null
+++ b/Doxyfile
@@ -0,0 +1,2642 @@
+# Doxyfile 1.9.2
+
+# This file describes the settings to be used by the documentation system
+# doxygen (www.doxygen.org) for a project.
+#
+# All text after a double hash (##) is considered a comment and is placed in
+# front of the TAG it is preceding.
+#
+# All text after a single hash (#) is considered a comment and will be ignored.
+# The format is:
+# TAG = value [value, ...]
+# For lists, items can also be appended using:
+# TAG += value [value, ...]
+# Values that contain spaces should be placed between quotes (\" \").
+
+#---------------------------------------------------------------------------
+# Project related configuration options
+#---------------------------------------------------------------------------
+
+# This tag specifies the encoding used for all characters in the configuration
+# file that follow. The default is UTF-8 which is also the encoding used for all
+# text before the first occurrence of this tag. Doxygen uses libiconv (or the
+# iconv built into libc) for the transcoding. See
+# https://www.gnu.org/software/libiconv/ for the list of possible encodings.
+# The default value is: UTF-8.
+
+DOXYFILE_ENCODING      = UTF-8
+
+# The PROJECT_NAME tag is a single word (or a sequence of words surrounded by
+# double-quotes, unless you are using Doxywizard) that should identify the
+# project for which the documentation is generated. This name is used in the
+# title of most generated pages and in a few other places.
+# The default value is: My Project.
+
+PROJECT_NAME           = "Conjunto Ordenado"
+
+# The PROJECT_NUMBER tag can be used to enter a project or revision number. This
+# could be handy for archiving the generated documentation or if some version
+# control system is used.
+
+PROJECT_NUMBER         =
+
+# Using the PROJECT_BRIEF tag one can provide an optional one line description
+# for a project that appears at the top of each page and should give viewer a
+# quick idea about the purpose of the project. Keep the description short.
+
+PROJECT_BRIEF          =
+
+# With the PROJECT_LOGO tag one can specify a logo or an icon that is included
+# in the documentation. The maximum height of the logo should not exceed 55
+# pixels and the maximum width should not exceed 200 pixels. Doxygen will copy
+# the logo to the output directory.
+
+PROJECT_LOGO           =
+
+# The OUTPUT_DIRECTORY tag is used to specify the (relative or absolute) path
+# into which the generated documentation will be written. If a relative path is
+# entered, it will be relative to the location where doxygen was started. If
+# left blank the current directory will be used.
+
+OUTPUT_DIRECTORY       = doc
+
+# If the CREATE_SUBDIRS tag is set to YES then doxygen will create 4096 sub-
+# directories (in 2 levels) under the output directory of each output format and
+# will distribute the generated files over these directories. Enabling this
+# option can be useful when feeding doxygen a huge amount of source files, where
+# putting all generated files in the same directory would otherwise causes
+# performance problems for the file system.
+# The default value is: NO.
+
+CREATE_SUBDIRS         = NO
+
+# If the ALLOW_UNICODE_NAMES tag is set to YES, doxygen will allow non-ASCII
+# characters to appear in the names of generated files. If set to NO, non-ASCII
+# characters will be escaped, for example _xE3_x81_x84 will be used for Unicode
+# U+3044.
+# The default value is: NO.
+
+ALLOW_UNICODE_NAMES    = NO
+
+# The OUTPUT_LANGUAGE tag is used to specify the language in which all
+# documentation generated by doxygen is written. Doxygen will use this
+# information to generate all constant output in the proper language.
+# Possible values are: Afrikaans, Arabic, Armenian, Brazilian, Catalan, Chinese,
+# Chinese-Traditional, Croatian, Czech, Danish, Dutch, English (United States),
+# Esperanto, Farsi (Persian), Finnish, French, German, Greek, Hungarian,
+# Indonesian, Italian, Japanese, Japanese-en (Japanese with English messages),
+# Korean, Korean-en (Korean with English messages), Latvian, Lithuanian,
+# Macedonian, Norwegian, Persian (Farsi), Polish, Portuguese, Romanian, Russian,
+# Serbian, Serbian-Cyrillic, Slovak, Slovene, Spanish, Swedish, Turkish,
+# Ukrainian and Vietnamese.
+# The default value is: English.
+
+OUTPUT_LANGUAGE        = Portuguese
+
+# If the BRIEF_MEMBER_DESC tag is set to YES, doxygen will include brief member
+# descriptions after the members that are listed in the file and class
+# documentation (similar to Javadoc). Set to NO to disable this.
+# The default value is: YES.
+
+BRIEF_MEMBER_DESC      = YES
+
+# If the REPEAT_BRIEF tag is set to YES, doxygen will prepend the brief
+# description of a member or function before the detailed description
+#
+# Note: If both HIDE_UNDOC_MEMBERS and BRIEF_MEMBER_DESC are set to NO, the
+# brief descriptions will be completely suppressed.
+# The default value is: YES.
+
+REPEAT_BRIEF           = YES
+
+# This tag implements a quasi-intelligent brief description abbreviator that is
+# used to form the text in various listings. Each string in this list, if found
+# as the leading text of the brief description, will be stripped from the text
+# and the result, after processing the whole list, is used as the annotated
+# text. Otherwise, the brief description is used as-is. If left blank, the
+# following values are used ($name is automatically replaced with the name of
+# the entity):The $name class, The $name widget, The $name file, is, provides,
+# specifies, contains, represents, a, an and the.
+
+ABBREVIATE_BRIEF       = "The $name class" \
+                         "The $name widget" \
+                         "The $name file" \
+                         is \
+                         provides \
+                         specifies \
+                         contains \
+                         represents \
+                         a \
+                         an \
+                         the
+
+# If the ALWAYS_DETAILED_SEC and REPEAT_BRIEF tags are both set to YES then
+# doxygen will generate a detailed section even if there is only a brief
+# description.
+# The default value is: NO.
+
+ALWAYS_DETAILED_SEC    = NO
+
+# If the INLINE_INHERITED_MEMB tag is set to YES, doxygen will show all
+# inherited members of a class in the documentation of that class as if those
+# members were ordinary class members. Constructors, destructors and assignment
+# operators of the base classes will not be shown.
+# The default value is: NO.
+
+INLINE_INHERITED_MEMB  = NO
+
+# If the FULL_PATH_NAMES tag is set to YES, doxygen will prepend the full path
+# before files name in the file list and in the header files. If set to NO the
+# shortest path that makes the file name unique will be used
+# The default value is: YES.
+
+FULL_PATH_NAMES        = YES
+
+# The STRIP_FROM_PATH tag can be used to strip a user-defined part of the path.
+# Stripping is only done if one of the specified strings matches the left-hand
+# part of the path. The tag can be used to show relative paths in the file list.
+# If left blank the directory from which doxygen is run is used as the path to
+# strip.
+#
+# Note that you can specify absolute paths here, but also relative paths, which
+# will be relative from the directory where doxygen is started.
+# This tag requires that the tag FULL_PATH_NAMES is set to YES.
+
+STRIP_FROM_PATH        =
+
+# The STRIP_FROM_INC_PATH tag can be used to strip a user-defined part of the
+# path mentioned in the documentation of a class, which tells the reader which
+# header file to include in order to use a class. If left blank only the name of
+# the header file containing the class definition is used. Otherwise one should
+# specify the list of include paths that are normally passed to the compiler
+# using the -I flag.
+
+STRIP_FROM_INC_PATH    =
+
+# If the SHORT_NAMES tag is set to YES, doxygen will generate much shorter (but
+# less readable) file names. This can be useful is your file systems doesn't
+# support long names like on DOS, Mac, or CD-ROM.
+# The default value is: NO.
+
+SHORT_NAMES            = NO
+
+# If the JAVADOC_AUTOBRIEF tag is set to YES then doxygen will interpret the
+# first line (until the first dot) of a Javadoc-style comment as the brief
+# description. If set to NO, the Javadoc-style will behave just like regular Qt-
+# style comments (thus requiring an explicit @brief command for a brief
+# description.)
+# The default value is: NO.
+
+JAVADOC_AUTOBRIEF      = NO
+
+# If the JAVADOC_BANNER tag is set to YES then doxygen will interpret a line
+# such as
+# /***************
+# as being the beginning of a Javadoc-style comment "banner". If set to NO, the
+# Javadoc-style will behave just like regular comments and it will not be
+# interpreted by doxygen.
+# The default value is: NO.
+
+JAVADOC_BANNER         = NO
+
+# If the QT_AUTOBRIEF tag is set to YES then doxygen will interpret the first
+# line (until the first dot) of a Qt-style comment as the brief description. If
+# set to NO, the Qt-style will behave just like regular Qt-style comments (thus
+# requiring an explicit \brief command for a brief description.)
+# The default value is: NO.
+
+QT_AUTOBRIEF           = NO
+
+# The MULTILINE_CPP_IS_BRIEF tag can be set to YES to make doxygen treat a
+# multi-line C++ special comment block (i.e. a block of //! or /// comments) as
+# a brief description. This used to be the default behavior. The new default is
+# to treat a multi-line C++ comment block as a detailed description. Set this
+# tag to YES if you prefer the old behavior instead.
+#
+# Note that setting this tag to YES also means that rational rose comments are
+# not recognized any more.
+# The default value is: NO.
+
+MULTILINE_CPP_IS_BRIEF = NO
+
+# By default Python docstrings are displayed as preformatted text and doxygen's
+# special commands cannot be used. By setting PYTHON_DOCSTRING to NO the
+# doxygen's special commands can be used and the contents of the docstring
+# documentation blocks is shown as doxygen documentation.
+# The default value is: YES.
+
+PYTHON_DOCSTRING       = NO
+
+# If the INHERIT_DOCS tag is set to YES then an undocumented member inherits the
+# documentation from any documented member that it re-implements.
+# The default value is: YES.
+
+INHERIT_DOCS           = YES
+
+# If the SEPARATE_MEMBER_PAGES tag is set to YES then doxygen will produce a new
+# page for each member. If set to NO, the documentation of a member will be part
+# of the file/class/namespace that contains it.
+# The default value is: NO.
+
+SEPARATE_MEMBER_PAGES  = NO
+
+# The TAB_SIZE tag can be used to set the number of spaces in a tab. Doxygen
+# uses this value to replace tabs by spaces in code fragments.
+# Minimum value: 1, maximum value: 16, default value: 4.
+
+TAB_SIZE               = 4
+
+# This tag can be used to specify a number of aliases that act as commands in
+# the documentation. An alias has the form:
+# name=value
+# For example adding
+# "sideeffect=@par Side Effects:^^"
+# will allow you to put the command \sideeffect (or @sideeffect) in the
+# documentation, which will result in a user-defined paragraph with heading
+# "Side Effects:". Note that you cannot put \n's in the value part of an alias
+# to insert newlines (in the resulting output). You can put ^^ in the value part
+# of an alias to insert a newline as if a physical newline was in the original
+# file. When you need a literal { or } or , in the value part of an alias you
+# have to escape them by means of a backslash (\), this can lead to conflicts
+# with the commands \{ and \} for these it is advised to use the version @{ and
+# @} or use a double escape (\\{ and \\})
+
+ALIASES                =
+
+# Set the OPTIMIZE_OUTPUT_FOR_C tag to YES if your project consists of C sources
+# only. Doxygen will then generate output that is more tailored for C. For
+# instance, some of the names that are used will be different. The list of all
+# members will be omitted, etc.
+# The default value is: NO.
+
+OPTIMIZE_OUTPUT_FOR_C  = YES
+
+# Set the OPTIMIZE_OUTPUT_JAVA tag to YES if your project consists of Java or
+# Python sources only. Doxygen will then generate output that is more tailored
+# for that language. For instance, namespaces will be presented as packages,
+# qualified scopes will look different, etc.
+# The default value is: NO.
+
+OPTIMIZE_OUTPUT_JAVA   = NO
+
+# Set the OPTIMIZE_FOR_FORTRAN tag to YES if your project consists of Fortran
+# sources. Doxygen will then generate output that is tailored for Fortran.
+# The default value is: NO.
+
+OPTIMIZE_FOR_FORTRAN   = NO
+
+# Set the OPTIMIZE_OUTPUT_VHDL tag to YES if your project consists of VHDL
+# sources. Doxygen will then generate output that is tailored for VHDL.
+# The default value is: NO.
+
+OPTIMIZE_OUTPUT_VHDL   = NO
+
+# Set the OPTIMIZE_OUTPUT_SLICE tag to YES if your project consists of Slice
+# sources only. Doxygen will then generate output that is more tailored for that
+# language. For instance, namespaces will be presented as modules, types will be
+# separated into more groups, etc.
+# The default value is: NO.
+
+OPTIMIZE_OUTPUT_SLICE  = NO
+
+# Doxygen selects the parser to use depending on the extension of the files it
+# parses. With this tag you can assign which parser to use for a given
+# extension. Doxygen has a built-in mapping, but you can override or extend it
+# using this tag. The format is ext=language, where ext is a file extension, and
+# language is one of the parsers supported by doxygen: IDL, Java, JavaScript,
+# Csharp (C#), C, C++, Lex, D, PHP, md (Markdown), Objective-C, Python, Slice,
+# VHDL, Fortran (fixed format Fortran: FortranFixed, free formatted Fortran:
+# FortranFree, unknown formatted Fortran: Fortran. In the later case the parser
+# tries to guess whether the code is fixed or free formatted code, this is the
+# default for Fortran type files). For instance to make doxygen treat .inc files
+# as Fortran files (default is PHP), and .f files as C (default is Fortran),
+# use: inc=Fortran f=C.
+#
+# Note: For files without extension you can use no_extension as a placeholder.
+#
+# Note that for custom extensions you also need to set FILE_PATTERNS otherwise
+# the files are not read by doxygen. When specifying no_extension you should add
+# * to the FILE_PATTERNS.
+#
+# Note see also the list of default file extension mappings.
+
+EXTENSION_MAPPING      =
+
+# If the MARKDOWN_SUPPORT tag is enabled then doxygen pre-processes all comments
+# according to the Markdown format, which allows for more readable
+# documentation. See https://daringfireball.net/projects/markdown/ for details.
+# The output of markdown processing is further processed by doxygen, so you can
+# mix doxygen, HTML, and XML commands with Markdown formatting. Disable only in
+# case of backward compatibilities issues.
+# The default value is: YES.
+
+MARKDOWN_SUPPORT       = YES
+
+# When the TOC_INCLUDE_HEADINGS tag is set to a non-zero value, all headings up
+# to that level are automatically included in the table of contents, even if
+# they do not have an id attribute.
+# Note: This feature currently applies only to Markdown headings.
+# Minimum value: 0, maximum value: 99, default value: 5.
+# This tag requires that the tag MARKDOWN_SUPPORT is set to YES.
+
+TOC_INCLUDE_HEADINGS   = 5
+
+# When enabled doxygen tries to link words that correspond to documented
+# classes, or namespaces to their corresponding documentation. Such a link can
+# be prevented in individual cases by putting a % sign in front of the word or
+# globally by setting AUTOLINK_SUPPORT to NO.
+# The default value is: YES.
+
+AUTOLINK_SUPPORT       = YES
+
+# If you use STL classes (i.e. std::string, std::vector, etc.) but do not want
+# to include (a tag file for) the STL sources as input, then you should set this
+# tag to YES in order to let doxygen match functions declarations and
+# definitions whose arguments contain STL classes (e.g. func(std::string);
+# versus func(std::string) {}). This also make the inheritance and collaboration
+# diagrams that involve STL classes more complete and accurate.
+# The default value is: NO.
+
+BUILTIN_STL_SUPPORT    = NO
+
+# If you use Microsoft's C++/CLI language, you should set this option to YES to
+# enable parsing support.
+# The default value is: NO.
+
+CPP_CLI_SUPPORT        = NO
+
+# Set the SIP_SUPPORT tag to YES if your project consists of sip (see:
+# https://www.riverbankcomputing.com/software/sip/intro) sources only. Doxygen
+# will parse them like normal C++ but will assume all classes use public instead
+# of private inheritance when no explicit protection keyword is present.
+# The default value is: NO.
+
+SIP_SUPPORT            = NO
+
+# For Microsoft's IDL there are propget and propput attributes to indicate
+# getter and setter methods for a property. Setting this option to YES will make
+# doxygen to replace the get and set methods by a property in the documentation.
+# This will only work if the methods are indeed getting or setting a simple
+# type. If this is not the case, or you want to show the methods anyway, you
+# should set this option to NO.
+# The default value is: YES.
+
+IDL_PROPERTY_SUPPORT   = YES
+
+# If member grouping is used in the documentation and the DISTRIBUTE_GROUP_DOC
+# tag is set to YES then doxygen will reuse the documentation of the first
+# member in the group (if any) for the other members of the group. By default
+# all members of a group must be documented explicitly.
+# The default value is: NO.
+
+DISTRIBUTE_GROUP_DOC   = NO
+
+# If one adds a struct or class to a group and this option is enabled, then also
+# any nested class or struct is added to the same group. By default this option
+# is disabled and one has to add nested compounds explicitly via \ingroup.
+# The default value is: NO.
+
+GROUP_NESTED_COMPOUNDS = NO
+
+# Set the SUBGROUPING tag to YES to allow class member groups of the same type
+# (for instance a group of public functions) to be put as a subgroup of that
+# type (e.g. under the Public Functions section). Set it to NO to prevent
+# subgrouping. Alternatively, this can be done per class using the
+# \nosubgrouping command.
+# The default value is: YES.
+
+SUBGROUPING            = YES
+
+# When the INLINE_GROUPED_CLASSES tag is set to YES, classes, structs and unions
+# are shown inside the group in which they are included (e.g. using \ingroup)
+# instead of on a separate page (for HTML and Man pages) or section (for LaTeX
+# and RTF).
+#
+# Note that this feature does not work in combination with
+# SEPARATE_MEMBER_PAGES.
+# The default value is: NO.
+
+INLINE_GROUPED_CLASSES = NO
+
+# When the INLINE_SIMPLE_STRUCTS tag is set to YES, structs, classes, and unions
+# with only public data fields or simple typedef fields will be shown inline in
+# the documentation of the scope in which they are defined (i.e. file,
+# namespace, or group documentation), provided this scope is documented. If set
+# to NO, structs, classes, and unions are shown on a separate page (for HTML and
+# Man pages) or section (for LaTeX and RTF).
+# The default value is: NO.
+
+INLINE_SIMPLE_STRUCTS  = NO
+
+# When TYPEDEF_HIDES_STRUCT tag is enabled, a typedef of a struct, union, or
+# enum is documented as struct, union, or enum with the name of the typedef. So
+# typedef struct TypeS {} TypeT, will appear in the documentation as a struct
+# with name TypeT. When disabled the typedef will appear as a member of a file,
+# namespace, or class. And the struct will be named TypeS. This can typically be
+# useful for C code in case the coding convention dictates that all compound
+# types are typedef'ed and only the typedef is referenced, never the tag name.
+# The default value is: NO.
+
+TYPEDEF_HIDES_STRUCT   = NO
+
+# The size of the symbol lookup cache can be set using LOOKUP_CACHE_SIZE. This
+# cache is used to resolve symbols given their name and scope. Since this can be
+# an expensive process and often the same symbol appears multiple times in the
+# code, doxygen keeps a cache of pre-resolved symbols. If the cache is too small
+# doxygen will become slower. If the cache is too large, memory is wasted. The
+# cache size is given by this formula: 2^(16+LOOKUP_CACHE_SIZE). The valid range
+# is 0..9, the default is 0, corresponding to a cache size of 2^16=65536
+# symbols. At the end of a run doxygen will report the cache usage and suggest
+# the optimal cache size from a speed point of view.
+# Minimum value: 0, maximum value: 9, default value: 0.
+
+LOOKUP_CACHE_SIZE      = 0
+
+# The NUM_PROC_THREADS specifies the number threads doxygen is allowed to use
+# during processing. When set to 0 doxygen will based this on the number of
+# cores available in the system. You can set it explicitly to a value larger
+# than 0 to get more control over the balance between CPU load and processing
+# speed. At this moment only the input processing can be done using multiple
+# threads. Since this is still an experimental feature the default is set to 1,
+# which effectively disables parallel processing. Please report any issues you
+# encounter. Generating dot graphs in parallel is controlled by the
+# DOT_NUM_THREADS setting.
+# Minimum value: 0, maximum value: 32, default value: 1.
+
+NUM_PROC_THREADS       = 1
+
+#---------------------------------------------------------------------------
+# Build related configuration options
+#---------------------------------------------------------------------------
+
+# If the EXTRACT_ALL tag is set to YES, doxygen will assume all entities in
+# documentation are documented, even if no documentation was available. Private
+# class members and static file members will be hidden unless the
+# EXTRACT_PRIVATE respectively EXTRACT_STATIC tags are set to YES.
+# Note: This will also disable the warnings about undocumented members that are
+# normally produced when WARNINGS is set to YES.
+# The default value is: NO.
+
+EXTRACT_ALL            = YES
+
+# If the EXTRACT_PRIVATE tag is set to YES, all private members of a class will
+# be included in the documentation.
+# The default value is: NO.
+
+EXTRACT_PRIVATE        = NO
+
+# If the EXTRACT_PRIV_VIRTUAL tag is set to YES, documented private virtual
+# methods of a class will be included in the documentation.
+# The default value is: NO.
+
+EXTRACT_PRIV_VIRTUAL   = NO
+
+# If the EXTRACT_PACKAGE tag is set to YES, all members with package or internal
+# scope will be included in the documentation.
+# The default value is: NO.
+
+EXTRACT_PACKAGE        = NO
+
+# If the EXTRACT_STATIC tag is set to YES, all static members of a file will be
+# included in the documentation.
+# The default value is: NO.
+
+EXTRACT_STATIC         = NO
+
+# If the EXTRACT_LOCAL_CLASSES tag is set to YES, classes (and structs) defined
+# locally in source files will be included in the documentation. If set to NO,
+# only classes defined in header files are included. Does not have any effect
+# for Java sources.
+# The default value is: YES.
+
+EXTRACT_LOCAL_CLASSES  = YES
+
+# This flag is only useful for Objective-C code. If set to YES, local methods,
+# which are defined in the implementation section but not in the interface are
+# included in the documentation. If set to NO, only methods in the interface are
+# included.
+# The default value is: NO.
+
+EXTRACT_LOCAL_METHODS  = NO
+
+# If this flag is set to YES, the members of anonymous namespaces will be
+# extracted and appear in the documentation as a namespace called
+# 'anonymous_namespace{file}', where file will be replaced with the base name of
+# the file that contains the anonymous namespace. By default anonymous namespace
+# are hidden.
+# The default value is: NO.
+
+EXTRACT_ANON_NSPACES   = NO
+
+# If this flag is set to YES, the name of an unnamed parameter in a declaration
+# will be determined by the corresponding definition. By default unnamed
+# parameters remain unnamed in the output.
+# The default value is: YES.
+
+RESOLVE_UNNAMED_PARAMS = YES
+
+# If the HIDE_UNDOC_MEMBERS tag is set to YES, doxygen will hide all
+# undocumented members inside documented classes or files. If set to NO these
+# members will be included in the various overviews, but no documentation
+# section is generated. This option has no effect if EXTRACT_ALL is enabled.
+# The default value is: NO.
+
+HIDE_UNDOC_MEMBERS     = NO
+
+# If the HIDE_UNDOC_CLASSES tag is set to YES, doxygen will hide all
+# undocumented classes that are normally visible in the class hierarchy. If set
+# to NO, these classes will be included in the various overviews. This option
+# has no effect if EXTRACT_ALL is enabled.
+# The default value is: NO.
+
+HIDE_UNDOC_CLASSES     = NO
+
+# If the HIDE_FRIEND_COMPOUNDS tag is set to YES, doxygen will hide all friend
+# declarations. If set to NO, these declarations will be included in the
+# documentation.
+# The default value is: NO.
+
+HIDE_FRIEND_COMPOUNDS  = NO
+
+# If the HIDE_IN_BODY_DOCS tag is set to YES, doxygen will hide any
+# documentation blocks found inside the body of a function. If set to NO, these
+# blocks will be appended to the function's detailed documentation block.
+# The default value is: NO.
+
+HIDE_IN_BODY_DOCS      = NO
+
+# The INTERNAL_DOCS tag determines if documentation that is typed after a
+# \internal command is included. If the tag is set to NO then the documentation
+# will be excluded. Set it to YES to include the internal documentation.
+# The default value is: NO.
+
+INTERNAL_DOCS          = NO
+
+# With the correct setting of option CASE_SENSE_NAMES doxygen will better be
+# able to match the capabilities of the underlying filesystem. In case the
+# filesystem is case sensitive (i.e. it supports files in the same directory
+# whose names only differ in casing), the option must be set to YES to properly
+# deal with such files in case they appear in the input. For filesystems that
+# are not case sensitive the option should be be set to NO to properly deal with
+# output files written for symbols that only differ in casing, such as for two
+# classes, one named CLASS and the other named Class, and to also support
+# references to files without having to specify the exact matching casing. On
+# Windows (including Cygwin) and MacOS, users should typically set this option
+# to NO, whereas on Linux or other Unix flavors it should typically be set to
+# YES.
+# The default value is: system dependent.
+
+CASE_SENSE_NAMES       = YES
+
+# If the HIDE_SCOPE_NAMES tag is set to NO then doxygen will show members with
+# their full class and namespace scopes in the documentation. If set to YES, the
+# scope will be hidden.
+# The default value is: NO.
+
+HIDE_SCOPE_NAMES       = YES
+
+# If the HIDE_COMPOUND_REFERENCE tag is set to NO (default) then doxygen will
+# append additional text to a page's title, such as Class Reference. If set to
+# YES the compound reference will be hidden.
+# The default value is: NO.
+
+HIDE_COMPOUND_REFERENCE= NO
+
+# If the SHOW_HEADERFILE tag is set to YES then the documentation for a class
+# will show which file needs to be included to use the class.
+# The default value is: YES.
+
+SHOW_HEADERFILE        = YES
+
+# If the SHOW_INCLUDE_FILES tag is set to YES then doxygen will put a list of
+# the files that are included by a file in the documentation of that file.
+# The default value is: YES.
+
+SHOW_INCLUDE_FILES     = YES
+
+# If the SHOW_GROUPED_MEMB_INC tag is set to YES then Doxygen will add for each
+# grouped member an include statement to the documentation, telling the reader
+# which file to include in order to use the member.
+# The default value is: NO.
+
+SHOW_GROUPED_MEMB_INC  = NO
+
+# If the FORCE_LOCAL_INCLUDES tag is set to YES then doxygen will list include
+# files with double quotes in the documentation rather than with sharp brackets.
+# The default value is: NO.
+
+FORCE_LOCAL_INCLUDES   = NO
+
+# If the INLINE_INFO tag is set to YES then a tag [inline] is inserted in the
+# documentation for inline members.
+# The default value is: YES.
+
+INLINE_INFO            = YES
+
+# If the SORT_MEMBER_DOCS tag is set to YES then doxygen will sort the
+# (detailed) documentation of file and class members alphabetically by member
+# name. If set to NO, the members will appear in declaration order.
+# The default value is: YES.
+
+SORT_MEMBER_DOCS       = YES
+
+# If the SORT_BRIEF_DOCS tag is set to YES then doxygen will sort the brief
+# descriptions of file, namespace and class members alphabetically by member
+# name. If set to NO, the members will appear in declaration order. Note that
+# this will also influence the order of the classes in the class list.
+# The default value is: NO.
+
+SORT_BRIEF_DOCS        = NO
+
+# If the SORT_MEMBERS_CTORS_1ST tag is set to YES then doxygen will sort the
+# (brief and detailed) documentation of class members so that constructors and
+# destructors are listed first. If set to NO the constructors will appear in the
+# respective orders defined by SORT_BRIEF_DOCS and SORT_MEMBER_DOCS.
+# Note: If SORT_BRIEF_DOCS is set to NO this option is ignored for sorting brief
+# member documentation.
+# Note: If SORT_MEMBER_DOCS is set to NO this option is ignored for sorting
+# detailed member documentation.
+# The default value is: NO.
+
+SORT_MEMBERS_CTORS_1ST = NO
+
+# If the SORT_GROUP_NAMES tag is set to YES then doxygen will sort the hierarchy
+# of group names into alphabetical order. If set to NO the group names will
+# appear in their defined order.
+# The default value is: NO.
+
+SORT_GROUP_NAMES       = NO
+
+# If the SORT_BY_SCOPE_NAME tag is set to YES, the class list will be sorted by
+# fully-qualified names, including namespaces. If set to NO, the class list will
+# be sorted only by class name, not including the namespace part.
+# Note: This option is not very useful if HIDE_SCOPE_NAMES is set to YES.
+# Note: This option applies only to the class list, not to the alphabetical
+# list.
+# The default value is: NO.
+
+SORT_BY_SCOPE_NAME     = NO
+
+# If the STRICT_PROTO_MATCHING option is enabled and doxygen fails to do proper
+# type resolution of all parameters of a function it will reject a match between
+# the prototype and the implementation of a member function even if there is
+# only one candidate or it is obvious which candidate to choose by doing a
+# simple string match. By disabling STRICT_PROTO_MATCHING doxygen will still
+# accept a match between prototype and implementation in such cases.
+# The default value is: NO.
+
+STRICT_PROTO_MATCHING  = NO
+
+# The GENERATE_TODOLIST tag can be used to enable (YES) or disable (NO) the todo
+# list. This list is created by putting \todo commands in the documentation.
+# The default value is: YES.
+
+GENERATE_TODOLIST      = YES
+
+# The GENERATE_TESTLIST tag can be used to enable (YES) or disable (NO) the test
+# list. This list is created by putting \test commands in the documentation.
+# The default value is: YES.
+
+GENERATE_TESTLIST      = YES
+
+# The GENERATE_BUGLIST tag can be used to enable (YES) or disable (NO) the bug
+# list. This list is created by putting \bug commands in the documentation.
+# The default value is: YES.
+
+GENERATE_BUGLIST       = YES
+
+# The GENERATE_DEPRECATEDLIST tag can be used to enable (YES) or disable (NO)
+# the deprecated list. This list is created by putting \deprecated commands in
+# the documentation.
+# The default value is: YES.
+
+GENERATE_DEPRECATEDLIST= YES
+
+# The ENABLED_SECTIONS tag can be used to enable conditional documentation
+# sections, marked by \if <section_label> ... \endif and \cond <section_label>
+# ... \endcond blocks.
+
+ENABLED_SECTIONS       =
+
+# The MAX_INITIALIZER_LINES tag determines the maximum number of lines that the
+# initial value of a variable or macro / define can have for it to appear in the
+# documentation. If the initializer consists of more lines than specified here
+# it will be hidden. Use a value of 0 to hide initializers completely. The
+# appearance of the value of individual variables and macros / defines can be
+# controlled using \showinitializer or \hideinitializer command in the
+# documentation regardless of this setting.
+# Minimum value: 0, maximum value: 10000, default value: 30.
+
+MAX_INITIALIZER_LINES  = 30
+
+# Set the SHOW_USED_FILES tag to NO to disable the list of files generated at
+# the bottom of the documentation of classes and structs. If set to YES, the
+# list will mention the files that were used to generate the documentation.
+# The default value is: YES.
+
+SHOW_USED_FILES        = YES
+
+# Set the SHOW_FILES tag to NO to disable the generation of the Files page. This
+# will remove the Files entry from the Quick Index and from the Folder Tree View
+# (if specified).
+# The default value is: YES.
+
+SHOW_FILES             = YES
+
+# Set the SHOW_NAMESPACES tag to NO to disable the generation of the Namespaces
+# page. This will remove the Namespaces entry from the Quick Index and from the
+# Folder Tree View (if specified).
+# The default value is: YES.
+
+SHOW_NAMESPACES        = YES
+
+# The FILE_VERSION_FILTER tag can be used to specify a program or script that
+# doxygen should invoke to get the current version for each file (typically from
+# the version control system). Doxygen will invoke the program by executing (via
+# popen()) the command command input-file, where command is the value of the
+# FILE_VERSION_FILTER tag, and input-file is the name of an input file provided
+# by doxygen. Whatever the program writes to standard output is used as the file
+# version. For an example see the documentation.
+
+FILE_VERSION_FILTER    =
+
+# The LAYOUT_FILE tag can be used to specify a layout file which will be parsed
+# by doxygen. The layout file controls the global structure of the generated
+# output files in an output format independent way. To create the layout file
+# that represents doxygen's defaults, run doxygen with the -l option. You can
+# optionally specify a file name after the option, if omitted DoxygenLayout.xml
+# will be used as the name of the layout file. See also section "Changing the
+# layout of pages" for information.
+#
+# Note that if you run doxygen from a directory containing a file called
+# DoxygenLayout.xml, doxygen will parse it automatically even if the LAYOUT_FILE
+# tag is left empty.
+
+LAYOUT_FILE            = DoxygenLayout.xml
+
+# The CITE_BIB_FILES tag can be used to specify one or more bib files containing
+# the reference definitions. This must be a list of .bib files. The .bib
+# extension is automatically appended if omitted. This requires the bibtex tool
+# to be installed. See also https://en.wikipedia.org/wiki/BibTeX for more info.
+# For LaTeX the style of the bibliography can be controlled using
+# LATEX_BIB_STYLE. To use this feature you need bibtex and perl available in the
+# search path. See also \cite for info how to create references.
+
+CITE_BIB_FILES         =
+
+#---------------------------------------------------------------------------
+# Configuration options related to warning and progress messages
+#---------------------------------------------------------------------------
+
+# The QUIET tag can be used to turn on/off the messages that are generated to
+# standard output by doxygen. If QUIET is set to YES this implies that the
+# messages are off.
+# The default value is: NO.
+
+QUIET                  = NO
+
+# The WARNINGS tag can be used to turn on/off the warning messages that are
+# generated to standard error (stderr) by doxygen. If WARNINGS is set to YES
+# this implies that the warnings are on.
+#
+# Tip: Turn warnings on while writing the documentation.
+# The default value is: YES.
+
+WARNINGS               = YES
+
+# If the WARN_IF_UNDOCUMENTED tag is set to YES then doxygen will generate
+# warnings for undocumented members. If EXTRACT_ALL is set to YES then this flag
+# will automatically be disabled.
+# The default value is: YES.
+
+WARN_IF_UNDOCUMENTED   = YES
+
+# If the WARN_IF_DOC_ERROR tag is set to YES, doxygen will generate warnings for
+# potential errors in the documentation, such as documenting some parameters in
+# a documented function twice, or documenting parameters that don't exist or
+# using markup commands wrongly.
+# The default value is: YES.
+
+WARN_IF_DOC_ERROR      = YES
+
+# If WARN_IF_INCOMPLETE_DOC is set to YES, doxygen will warn about incomplete
+# function parameter documentation. If set to NO, doxygen will accept that some
+# parameters have no documentation without warning.
+# The default value is: YES.
+
+WARN_IF_INCOMPLETE_DOC = YES
+
+# This WARN_NO_PARAMDOC option can be enabled to get warnings for functions that
+# are documented, but have no documentation for their parameters or return
+# value. If set to NO, doxygen will only warn about wrong parameter
+# documentation, but not about the absence of documentation. If EXTRACT_ALL is
+# set to YES then this flag will automatically be disabled. See also
+# WARN_IF_INCOMPLETE_DOC
+# The default value is: NO.
+
+WARN_NO_PARAMDOC       = NO
+
+# If the WARN_AS_ERROR tag is set to YES then doxygen will immediately stop when
+# a warning is encountered. If the WARN_AS_ERROR tag is set to FAIL_ON_WARNINGS
+# then doxygen will continue running as if WARN_AS_ERROR tag is set to NO, but
+# at the end of the doxygen process doxygen will return with a non-zero status.
+# Possible values are: NO, YES and FAIL_ON_WARNINGS.
+# The default value is: NO.
+
+WARN_AS_ERROR          = NO
+
+# The WARN_FORMAT tag determines the format of the warning messages that doxygen
+# can produce. The string should contain the $file, $line, and $text tags, which
+# will be replaced by the file and line number from which the warning originated
+# and the warning text. Optionally the format may contain $version, which will
+# be replaced by the version of the file (if it could be obtained via
+# FILE_VERSION_FILTER)
+# The default value is: $file:$line: $text.
+
+WARN_FORMAT            = "$file:$line: $text"
+
+# The WARN_LOGFILE tag can be used to specify a file to which warning and error
+# messages should be written. If left blank the output is written to standard
+# error (stderr).
+
+WARN_LOGFILE           =
+
+#---------------------------------------------------------------------------
+# Configuration options related to the input files
+#---------------------------------------------------------------------------
+
+# The INPUT tag is used to specify the files and/or directories that contain
+# documented source files. You may enter file names like myfile.cpp or
+# directories like /usr/src/myproject. Separate the files or directories with
+# spaces. See also FILE_PATTERNS and EXTENSION_MAPPING
+# Note: If this tag is empty the current directory is searched.
+
+INPUT                  = src
+
+# This tag can be used to specify the character encoding of the source files
+# that doxygen parses. Internally doxygen uses the UTF-8 encoding. Doxygen uses
+# libiconv (or the iconv built into libc) for the transcoding. See the libiconv
+# documentation (see:
+# https://www.gnu.org/software/libiconv/) for the list of possible encodings.
+# The default value is: UTF-8.
+
+INPUT_ENCODING         = UTF-8
+
+# If the value of the INPUT tag contains directories, you can use the
+# FILE_PATTERNS tag to specify one or more wildcard patterns (like *.cpp and
+# *.h) to filter out the source-files in the directories.
+#
+# Note that for custom extensions or not directly supported extensions you also
+# need to set EXTENSION_MAPPING for the extension otherwise the files are not
+# read by doxygen.
+#
+# Note the list of default checked file patterns might differ from the list of
+# default file extension mappings.
+#
+# If left blank the following patterns are tested:*.c, *.cc, *.cxx, *.cpp,
+# *.c++, *.java, *.ii, *.ixx, *.ipp, *.i++, *.inl, *.idl, *.ddl, *.odl, *.h,
+# *.hh, *.hxx, *.hpp, *.h++, *.l, *.cs, *.d, *.php, *.php4, *.php5, *.phtml,
+# *.inc, *.m, *.markdown, *.md, *.mm, *.dox (to be provided as doxygen C
+# comment), *.py, *.pyw, *.f90, *.f95, *.f03, *.f08, *.f18, *.f, *.for, *.vhd,
+# *.vhdl, *.ucf, *.qsf and *.ice.
+
+FILE_PATTERNS          = *.c \
+                         *.cc \
+                         *.cxx \
+                         *.cpp \
+                         *.c++ \
+                         *.java \
+                         *.ii \
+                         *.ixx \
+                         *.ipp \
+                         *.i++ \
+                         *.inl \
+                         *.idl \
+                         *.ddl \
+                         *.odl \
+                         *.h \
+                         *.hh \
+                         *.hxx \
+                         *.hpp \
+                         *.h++ \
+                         *.l \
+                         *.cs \
+                         *.d \
+                         *.php \
+                         *.php4 \
+                         *.php5 \
+                         *.phtml \
+                         *.inc \
+                         *.m \
+                         *.markdown \
+                         *.md \
+                         *.mm \
+                         *.dox \
+                         *.py \
+                         *.pyw \
+                         *.f90 \
+                         *.f95 \
+                         *.f03 \
+                         *.f08 \
+                         *.f18 \
+                         *.f \
+                         *.for \
+                         *.vhd \
+                         *.vhdl \
+                         *.ucf \
+                         *.qsf \
+                         *.ice
+
+# The RECURSIVE tag can be used to specify whether or not subdirectories should
+# be searched for input files as well.
+# The default value is: NO.
+
+RECURSIVE              = YES
+
+# The EXCLUDE tag can be used to specify files and/or directories that should be
+# excluded from the INPUT source files. This way you can easily exclude a
+# subdirectory from a directory tree whose root is specified with the INPUT tag.
+#
+# Note that relative paths are relative to the directory from which doxygen is
+# run.
+
+EXCLUDE                =
+
+# The EXCLUDE_SYMLINKS tag can be used to select whether or not files or
+# directories that are symbolic links (a Unix file system feature) are excluded
+# from the input.
+# The default value is: NO.
+
+EXCLUDE_SYMLINKS       = NO
+
+# If the value of the INPUT tag contains directories, you can use the
+# EXCLUDE_PATTERNS tag to specify one or more wildcard patterns to exclude
+# certain files from those directories.
+#
+# Note that the wildcards are matched against the file with absolute path, so to
+# exclude all test directories for example use the pattern */test/*
+
+EXCLUDE_PATTERNS       =
+
+# The EXCLUDE_SYMBOLS tag can be used to specify one or more symbol names
+# (namespaces, classes, functions, etc.) that should be excluded from the
+# output. The symbol name can be a fully qualified name, a word, or if the
+# wildcard * is used, a substring. Examples: ANamespace, AClass,
+# AClass::ANamespace, ANamespace::*Test
+#
+# Note that the wildcards are matched against the file with absolute path, so to
+# exclude all test directories use the pattern */test/*
+
+EXCLUDE_SYMBOLS        =
+
+# The EXAMPLE_PATH tag can be used to specify one or more files or directories
+# that contain example code fragments that are included (see the \include
+# command).
+
+EXAMPLE_PATH           =
+
+# If the value of the EXAMPLE_PATH tag contains directories, you can use the
+# EXAMPLE_PATTERNS tag to specify one or more wildcard pattern (like *.cpp and
+# *.h) to filter out the source-files in the directories. If left blank all
+# files are included.
+
+EXAMPLE_PATTERNS       = *
+
+# If the EXAMPLE_RECURSIVE tag is set to YES then subdirectories will be
+# searched for input files to be used with the \include or \dontinclude commands
+# irrespective of the value of the RECURSIVE tag.
+# The default value is: NO.
+
+EXAMPLE_RECURSIVE      = NO
+
+# The IMAGE_PATH tag can be used to specify one or more files or directories
+# that contain images that are to be included in the documentation (see the
+# \image command).
+
+IMAGE_PATH             =
+
+# The INPUT_FILTER tag can be used to specify a program that doxygen should
+# invoke to filter for each input file. Doxygen will invoke the filter program
+# by executing (via popen()) the command:
+#
+# <filter> <input-file>
+#
+# where <filter> is the value of the INPUT_FILTER tag, and <input-file> is the
+# name of an input file. Doxygen will then use the output that the filter
+# program writes to standard output. If FILTER_PATTERNS is specified, this tag
+# will be ignored.
+#
+# Note that the filter must not add or remove lines; it is applied before the
+# code is scanned, but not when the output code is generated. If lines are added
+# or removed, the anchors will not be placed correctly.
+#
+# Note that for custom extensions or not directly supported extensions you also
+# need to set EXTENSION_MAPPING for the extension otherwise the files are not
+# properly processed by doxygen.
+
+INPUT_FILTER           =
+
+# The FILTER_PATTERNS tag can be used to specify filters on a per file pattern
+# basis. Doxygen will compare the file name with each pattern and apply the
+# filter if there is a match. The filters are a list of the form: pattern=filter
+# (like *.cpp=my_cpp_filter). See INPUT_FILTER for further information on how
+# filters are used. If the FILTER_PATTERNS tag is empty or if none of the
+# patterns match the file name, INPUT_FILTER is applied.
+#
+# Note that for custom extensions or not directly supported extensions you also
+# need to set EXTENSION_MAPPING for the extension otherwise the files are not
+# properly processed by doxygen.
+
+FILTER_PATTERNS        =
+
+# If the FILTER_SOURCE_FILES tag is set to YES, the input filter (if set using
+# INPUT_FILTER) will also be used to filter the input files that are used for
+# producing the source files to browse (i.e. when SOURCE_BROWSER is set to YES).
+# The default value is: NO.
+
+FILTER_SOURCE_FILES    = NO
+
+# The FILTER_SOURCE_PATTERNS tag can be used to specify source filters per file
+# pattern. A pattern will override the setting for FILTER_PATTERN (if any) and
+# it is also possible to disable source filtering for a specific pattern using
+# *.ext= (so without naming a filter).
+# This tag requires that the tag FILTER_SOURCE_FILES is set to YES.
+
+FILTER_SOURCE_PATTERNS =
+
+# If the USE_MDFILE_AS_MAINPAGE tag refers to the name of a markdown file that
+# is part of the input, its contents will be placed on the main page
+# (index.html). This can be useful if you have a project on for instance GitHub
+# and want to reuse the introduction page also for the doxygen output.
+
+USE_MDFILE_AS_MAINPAGE =
+
+#---------------------------------------------------------------------------
+# Configuration options related to source browsing
+#---------------------------------------------------------------------------
+
+# If the SOURCE_BROWSER tag is set to YES then a list of source files will be
+# generated. Documented entities will be cross-referenced with these sources.
+#
+# Note: To get rid of all source code in the generated output, make sure that
+# also VERBATIM_HEADERS is set to NO.
+# The default value is: NO.
+
+SOURCE_BROWSER         = YES
+
+# Setting the INLINE_SOURCES tag to YES will include the body of functions,
+# classes and enums directly into the documentation.
+# The default value is: NO.
+
+INLINE_SOURCES         = NO
+
+# Setting the STRIP_CODE_COMMENTS tag to YES will instruct doxygen to hide any
+# special comment blocks from generated source code fragments. Normal C, C++ and
+# Fortran comments will always remain visible.
+# The default value is: YES.
+
+STRIP_CODE_COMMENTS    = YES
+
+# If the REFERENCED_BY_RELATION tag is set to YES then for each documented
+# entity all documented functions referencing it will be listed.
+# The default value is: NO.
+
+REFERENCED_BY_RELATION = NO
+
+# If the REFERENCES_RELATION tag is set to YES then for each documented function
+# all documented entities called/used by that function will be listed.
+# The default value is: NO.
+
+REFERENCES_RELATION    = NO
+
+# If the REFERENCES_LINK_SOURCE tag is set to YES and SOURCE_BROWSER tag is set
+# to YES then the hyperlinks from functions in REFERENCES_RELATION and
+# REFERENCED_BY_RELATION lists will link to the source code. Otherwise they will
+# link to the documentation.
+# The default value is: YES.
+
+REFERENCES_LINK_SOURCE = YES
+
+# If SOURCE_TOOLTIPS is enabled (the default) then hovering a hyperlink in the
+# source code will show a tooltip with additional information such as prototype,
+# brief description and links to the definition and documentation. Since this
+# will make the HTML file larger and loading of large files a bit slower, you
+# can opt to disable this feature.
+# The default value is: YES.
+# This tag requires that the tag SOURCE_BROWSER is set to YES.
+
+SOURCE_TOOLTIPS        = YES
+
+# If the USE_HTAGS tag is set to YES then the references to source code will
+# point to the HTML generated by the htags(1) tool instead of doxygen built-in
+# source browser. The htags tool is part of GNU's global source tagging system
+# (see https://www.gnu.org/software/global/global.html). You will need version
+# 4.8.6 or higher.
+#
+# To use it do the following:
+# - Install the latest version of global
+# - Enable SOURCE_BROWSER and USE_HTAGS in the configuration file
+# - Make sure the INPUT points to the root of the source tree
+# - Run doxygen as normal
+#
+# Doxygen will invoke htags (and that will in turn invoke gtags), so these
+# tools must be available from the command line (i.e. in the search path).
+#
+# The result: instead of the source browser generated by doxygen, the links to
+# source code will now point to the output of htags.
+# The default value is: NO.
+# This tag requires that the tag SOURCE_BROWSER is set to YES.
+
+USE_HTAGS              = NO
+
+# If the VERBATIM_HEADERS tag is set the YES then doxygen will generate a
+# verbatim copy of the header file for each class for which an include is
+# specified. Set to NO to disable this.
+# See also: Section \class.
+# The default value is: YES.
+
+VERBATIM_HEADERS       = YES
+
+#---------------------------------------------------------------------------
+# Configuration options related to the alphabetical class index
+#---------------------------------------------------------------------------
+
+# If the ALPHABETICAL_INDEX tag is set to YES, an alphabetical index of all
+# compounds will be generated. Enable this if the project contains a lot of
+# classes, structs, unions or interfaces.
+# The default value is: YES.
+
+ALPHABETICAL_INDEX     = YES
+
+# In case all classes in a project start with a common prefix, all classes will
+# be put under the same header in the alphabetical index. The IGNORE_PREFIX tag
+# can be used to specify a prefix (or a list of prefixes) that should be ignored
+# while generating the index headers.
+# This tag requires that the tag ALPHABETICAL_INDEX is set to YES.
+
+IGNORE_PREFIX          =
+
+#---------------------------------------------------------------------------
+# Configuration options related to the HTML output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_HTML tag is set to YES, doxygen will generate HTML output
+# The default value is: YES.
+
+GENERATE_HTML          = YES
+
+# The HTML_OUTPUT tag is used to specify where the HTML docs will be put. If a
+# relative path is entered the value of OUTPUT_DIRECTORY will be put in front of
+# it.
+# The default directory is: html.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+HTML_OUTPUT            = html
+
+# The HTML_FILE_EXTENSION tag can be used to specify the file extension for each
+# generated HTML page (for example: .htm, .php, .asp).
+# The default value is: .html.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+HTML_FILE_EXTENSION    = .html
+
+# The HTML_HEADER tag can be used to specify a user-defined HTML header file for
+# each generated HTML page. If the tag is left blank doxygen will generate a
+# standard header.
+#
+# To get valid HTML the header file that includes any scripts and style sheets
+# that doxygen needs, which is dependent on the configuration options used (e.g.
+# the setting GENERATE_TREEVIEW). It is highly recommended to start with a
+# default header using
+# doxygen -w html new_header.html new_footer.html new_stylesheet.css
+# YourConfigFile
+# and then modify the file new_header.html. See also section "Doxygen usage"
+# for information on how to generate the default header that doxygen normally
+# uses.
+# Note: The header is subject to change so you typically have to regenerate the
+# default header when upgrading to a newer version of doxygen. For a description
+# of the possible markers and block names see the documentation.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+HTML_HEADER            =
+
+# The HTML_FOOTER tag can be used to specify a user-defined HTML footer for each
+# generated HTML page. If the tag is left blank doxygen will generate a standard
+# footer. See HTML_HEADER for more information on how to generate a default
+# footer and what special commands can be used inside the footer. See also
+# section "Doxygen usage" for information on how to generate the default footer
+# that doxygen normally uses.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+HTML_FOOTER            =
+
+# The HTML_STYLESHEET tag can be used to specify a user-defined cascading style
+# sheet that is used by each HTML page. It can be used to fine-tune the look of
+# the HTML output. If left blank doxygen will generate a default style sheet.
+# See also section "Doxygen usage" for information on how to generate the style
+# sheet that doxygen normally uses.
+# Note: It is recommended to use HTML_EXTRA_STYLESHEET instead of this tag, as
+# it is more robust and this tag (HTML_STYLESHEET) will in the future become
+# obsolete.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+HTML_STYLESHEET        =
+
+# The HTML_EXTRA_STYLESHEET tag can be used to specify additional user-defined
+# cascading style sheets that are included after the standard style sheets
+# created by doxygen. Using this option one can overrule certain style aspects.
+# This is preferred over using HTML_STYLESHEET since it does not replace the
+# standard style sheet and is therefore more robust against future updates.
+# Doxygen will copy the style sheet files to the output directory.
+# Note: The order of the extra style sheet files is of importance (e.g. the last
+# style sheet in the list overrules the setting of the previous ones in the
+# list). For an example see the documentation.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+HTML_EXTRA_STYLESHEET  =
+
+# The HTML_EXTRA_FILES tag can be used to specify one or more extra images or
+# other source files which should be copied to the HTML output directory. Note
+# that these files will be copied to the base HTML output directory. Use the
+# $relpath^ marker in the HTML_HEADER and/or HTML_FOOTER files to load these
+# files. In the HTML_STYLESHEET file, use the file name only. Also note that the
+# files will be copied as-is; there are no commands or markers available.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+HTML_EXTRA_FILES       =
+
+# The HTML_COLORSTYLE_HUE tag controls the color of the HTML output. Doxygen
+# will adjust the colors in the style sheet and background images according to
+# this color. Hue is specified as an angle on a color-wheel, see
+# https://en.wikipedia.org/wiki/Hue for more information. For instance the value
+# 0 represents red, 60 is yellow, 120 is green, 180 is cyan, 240 is blue, 300
+# purple, and 360 is red again.
+# Minimum value: 0, maximum value: 359, default value: 220.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+HTML_COLORSTYLE_HUE    = 234
+
+# The HTML_COLORSTYLE_SAT tag controls the purity (or saturation) of the colors
+# in the HTML output. For a value of 0 the output will use gray-scales only. A
+# value of 255 will produce the most vivid colors.
+# Minimum value: 0, maximum value: 255, default value: 100.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+HTML_COLORSTYLE_SAT    = 48
+
+# The HTML_COLORSTYLE_GAMMA tag controls the gamma correction applied to the
+# luminance component of the colors in the HTML output. Values below 100
+# gradually make the output lighter, whereas values above 100 make the output
+# darker. The value divided by 100 is the actual gamma applied, so 80 represents
+# a gamma of 0.8, The value 220 represents a gamma of 2.2, and 100 does not
+# change the gamma.
+# Minimum value: 40, maximum value: 240, default value: 80.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+HTML_COLORSTYLE_GAMMA  = 158
+
+# If the HTML_TIMESTAMP tag is set to YES then the footer of each generated HTML
+# page will contain the date and time when the page was generated. Setting this
+# to YES can help to show when doxygen was last run and thus if the
+# documentation is up to date.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+HTML_TIMESTAMP         = NO
+
+# If the HTML_DYNAMIC_MENUS tag is set to YES then the generated HTML
+# documentation will contain a main index with vertical navigation menus that
+# are dynamically created via JavaScript. If disabled, the navigation index will
+# consists of multiple levels of tabs that are statically embedded in every HTML
+# page. Disable this option to support browsers that do not have JavaScript,
+# like the Qt help browser.
+# The default value is: YES.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+HTML_DYNAMIC_MENUS     = YES
+
+# If the HTML_DYNAMIC_SECTIONS tag is set to YES then the generated HTML
+# documentation will contain sections that can be hidden and shown after the
+# page has loaded.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+HTML_DYNAMIC_SECTIONS  = NO
+
+# With HTML_INDEX_NUM_ENTRIES one can control the preferred number of entries
+# shown in the various tree structured indices initially; the user can expand
+# and collapse entries dynamically later on. Doxygen will expand the tree to
+# such a level that at most the specified number of entries are visible (unless
+# a fully collapsed tree already exceeds this amount). So setting the number of
+# entries 1 will produce a full collapsed tree by default. 0 is a special value
+# representing an infinite number of entries and will result in a full expanded
+# tree by default.
+# Minimum value: 0, maximum value: 9999, default value: 100.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+HTML_INDEX_NUM_ENTRIES = 100
+
+# If the GENERATE_DOCSET tag is set to YES, additional index files will be
+# generated that can be used as input for Apple's Xcode 3 integrated development
+# environment (see:
+# https://developer.apple.com/xcode/), introduced with OSX 10.5 (Leopard). To
+# create a documentation set, doxygen will generate a Makefile in the HTML
+# output directory. Running make will produce the docset in that directory and
+# running make install will install the docset in
+# ~/Library/Developer/Shared/Documentation/DocSets so that Xcode will find it at
+# startup. See https://developer.apple.com/library/archive/featuredarticles/Doxy
+# genXcode/_index.html for more information.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+GENERATE_DOCSET        = NO
+
+# This tag determines the name of the docset feed. A documentation feed provides
+# an umbrella under which multiple documentation sets from a single provider
+# (such as a company or product suite) can be grouped.
+# The default value is: Doxygen generated docs.
+# This tag requires that the tag GENERATE_DOCSET is set to YES.
+
+DOCSET_FEEDNAME        = 
+
+# This tag specifies a string that should uniquely identify the documentation
+# set bundle. This should be a reverse domain-name style string, e.g.
+# com.mycompany.MyDocSet. Doxygen will append .docset to the name.
+# The default value is: org.doxygen.Project.
+# This tag requires that the tag GENERATE_DOCSET is set to YES.
+
+DOCSET_BUNDLE_ID       = org.doxygen.Project
+
+# The DOCSET_PUBLISHER_ID tag specifies a string that should uniquely identify
+# the documentation publisher. This should be a reverse domain-name style
+# string, e.g. com.mycompany.MyDocSet.documentation.
+# The default value is: org.doxygen.Publisher.
+# This tag requires that the tag GENERATE_DOCSET is set to YES.
+
+DOCSET_PUBLISHER_ID    = org.doxygen.Publisher
+
+# The DOCSET_PUBLISHER_NAME tag identifies the documentation publisher.
+# The default value is: Publisher.
+# This tag requires that the tag GENERATE_DOCSET is set to YES.
+
+DOCSET_PUBLISHER_NAME  = Publisher
+
+# If the GENERATE_HTMLHELP tag is set to YES then doxygen generates three
+# additional HTML index files: index.hhp, index.hhc, and index.hhk. The
+# index.hhp is a project file that can be read by Microsoft's HTML Help Workshop
+# on Windows. In the beginning of 2021 Microsoft took the original page, with
+# a.o. the download links, offline the HTML help workshop was already many years
+# in maintenance mode). You can download the HTML help workshop from the web
+# archives at Installation executable (see:
+# http://web.archive.org/web/20160201063255/http://download.microsoft.com/downlo
+# ad/0/A/9/0A939EF6-E31C-430F-A3DF-DFAE7960D564/htmlhelp.exe).
+#
+# The HTML Help Workshop contains a compiler that can convert all HTML output
+# generated by doxygen into a single compiled HTML file (.chm). Compiled HTML
+# files are now used as the Windows 98 help format, and will replace the old
+# Windows help format (.hlp) on all Windows platforms in the future. Compressed
+# HTML files also contain an index, a table of contents, and you can search for
+# words in the documentation. The HTML workshop also contains a viewer for
+# compressed HTML files.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+GENERATE_HTMLHELP      = NO
+
+# The CHM_FILE tag can be used to specify the file name of the resulting .chm
+# file. You can add a path in front of the file if the result should not be
+# written to the html output directory.
+# This tag requires that the tag GENERATE_HTMLHELP is set to YES.
+
+CHM_FILE               =
+
+# The HHC_LOCATION tag can be used to specify the location (absolute path
+# including file name) of the HTML help compiler (hhc.exe). If non-empty,
+# doxygen will try to run the HTML help compiler on the generated index.hhp.
+# The file has to be specified with full path.
+# This tag requires that the tag GENERATE_HTMLHELP is set to YES.
+
+HHC_LOCATION           =
+
+# The GENERATE_CHI flag controls if a separate .chi index file is generated
+# (YES) or that it should be included in the main .chm file (NO).
+# The default value is: NO.
+# This tag requires that the tag GENERATE_HTMLHELP is set to YES.
+
+GENERATE_CHI           = NO
+
+# The CHM_INDEX_ENCODING is used to encode HtmlHelp index (hhk), content (hhc)
+# and project file content.
+# This tag requires that the tag GENERATE_HTMLHELP is set to YES.
+
+CHM_INDEX_ENCODING     =
+
+# The BINARY_TOC flag controls whether a binary table of contents is generated
+# (YES) or a normal table of contents (NO) in the .chm file. Furthermore it
+# enables the Previous and Next buttons.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_HTMLHELP is set to YES.
+
+BINARY_TOC             = NO
+
+# The TOC_EXPAND flag can be set to YES to add extra items for group members to
+# the table of contents of the HTML help documentation and to the tree view.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_HTMLHELP is set to YES.
+
+TOC_EXPAND             = NO
+
+# If the GENERATE_QHP tag is set to YES and both QHP_NAMESPACE and
+# QHP_VIRTUAL_FOLDER are set, an additional index file will be generated that
+# can be used as input for Qt's qhelpgenerator to generate a Qt Compressed Help
+# (.qch) of the generated HTML documentation.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+GENERATE_QHP           = NO
+
+# If the QHG_LOCATION tag is specified, the QCH_FILE tag can be used to specify
+# the file name of the resulting .qch file. The path specified is relative to
+# the HTML output folder.
+# This tag requires that the tag GENERATE_QHP is set to YES.
+
+QCH_FILE               =
+
+# The QHP_NAMESPACE tag specifies the namespace to use when generating Qt Help
+# Project output. For more information please see Qt Help Project / Namespace
+# (see:
+# https://doc.qt.io/archives/qt-4.8/qthelpproject.html#namespace).
+# The default value is: org.doxygen.Project.
+# This tag requires that the tag GENERATE_QHP is set to YES.
+
+QHP_NAMESPACE          = org.doxygen.Project
+
+# The QHP_VIRTUAL_FOLDER tag specifies the namespace to use when generating Qt
+# Help Project output. For more information please see Qt Help Project / Virtual
+# Folders (see:
+# https://doc.qt.io/archives/qt-4.8/qthelpproject.html#virtual-folders).
+# The default value is: doc.
+# This tag requires that the tag GENERATE_QHP is set to YES.
+
+QHP_VIRTUAL_FOLDER     = doc
+
+# If the QHP_CUST_FILTER_NAME tag is set, it specifies the name of a custom
+# filter to add. For more information please see Qt Help Project / Custom
+# Filters (see:
+# https://doc.qt.io/archives/qt-4.8/qthelpproject.html#custom-filters).
+# This tag requires that the tag GENERATE_QHP is set to YES.
+
+QHP_CUST_FILTER_NAME   =
+
+# The QHP_CUST_FILTER_ATTRS tag specifies the list of the attributes of the
+# custom filter to add. For more information please see Qt Help Project / Custom
+# Filters (see:
+# https://doc.qt.io/archives/qt-4.8/qthelpproject.html#custom-filters).
+# This tag requires that the tag GENERATE_QHP is set to YES.
+
+QHP_CUST_FILTER_ATTRS  =
+
+# The QHP_SECT_FILTER_ATTRS tag specifies the list of the attributes this
+# project's filter section matches. Qt Help Project / Filter Attributes (see:
+# https://doc.qt.io/archives/qt-4.8/qthelpproject.html#filter-attributes).
+# This tag requires that the tag GENERATE_QHP is set to YES.
+
+QHP_SECT_FILTER_ATTRS  =
+
+# The QHG_LOCATION tag can be used to specify the location (absolute path
+# including file name) of Qt's qhelpgenerator. If non-empty doxygen will try to
+# run qhelpgenerator on the generated .qhp file.
+# This tag requires that the tag GENERATE_QHP is set to YES.
+
+QHG_LOCATION           =
+
+# If the GENERATE_ECLIPSEHELP tag is set to YES, additional index files will be
+# generated, together with the HTML files, they form an Eclipse help plugin. To
+# install this plugin and make it available under the help contents menu in
+# Eclipse, the contents of the directory containing the HTML and XML files needs
+# to be copied into the plugins directory of eclipse. The name of the directory
+# within the plugins directory should be the same as the ECLIPSE_DOC_ID value.
+# After copying Eclipse needs to be restarted before the help appears.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+GENERATE_ECLIPSEHELP   = NO
+
+# A unique identifier for the Eclipse help plugin. When installing the plugin
+# the directory name containing the HTML and XML files should also have this
+# name. Each documentation set should have its own identifier.
+# The default value is: org.doxygen.Project.
+# This tag requires that the tag GENERATE_ECLIPSEHELP is set to YES.
+
+ECLIPSE_DOC_ID         = org.doxygen.Project
+
+# If you want full control over the layout of the generated HTML pages it might
+# be necessary to disable the index and replace it with your own. The
+# DISABLE_INDEX tag can be used to turn on/off the condensed index (tabs) at top
+# of each HTML page. A value of NO enables the index and the value YES disables
+# it. Since the tabs in the index contain the same information as the navigation
+# tree, you can set this option to YES if you also set GENERATE_TREEVIEW to YES.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+DISABLE_INDEX          = NO
+
+# The GENERATE_TREEVIEW tag is used to specify whether a tree-like index
+# structure should be generated to display hierarchical information. If the tag
+# value is set to YES, a side panel will be generated containing a tree-like
+# index structure (just like the one that is generated for HTML Help). For this
+# to work a browser that supports JavaScript, DHTML, CSS and frames is required
+# (i.e. any modern browser). Windows users are probably better off using the
+# HTML help feature. Via custom style sheets (see HTML_EXTRA_STYLESHEET) one can
+# further fine tune the look of the index (see "Fine-tuning the output"). As an
+# example, the default style sheet generated by doxygen has an example that
+# shows how to put an image at the root of the tree instead of the PROJECT_NAME.
+# Since the tree basically has the same information as the tab index, you could
+# consider setting DISABLE_INDEX to YES when enabling this option.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+GENERATE_TREEVIEW      = NO
+
+# When both GENERATE_TREEVIEW and DISABLE_INDEX are set to YES, then the
+# FULL_SIDEBAR option determines if the side bar is limited to only the treeview
+# area (value NO) or if it should extend to the full height of the window (value
+# YES). Setting this to YES gives a layout similar to
+# https://docs.readthedocs.io with more room for contents, but less room for the
+# project logo, title, and description. If either GENERATOR_TREEVIEW or
+# DISABLE_INDEX is set to NO, this option has no effect.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+FULL_SIDEBAR           = NO
+
+# The ENUM_VALUES_PER_LINE tag can be used to set the number of enum values that
+# doxygen will group on one line in the generated HTML documentation.
+#
+# Note that a value of 0 will completely suppress the enum values from appearing
+# in the overview section.
+# Minimum value: 0, maximum value: 20, default value: 4.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+ENUM_VALUES_PER_LINE   = 4
+
+# If the treeview is enabled (see GENERATE_TREEVIEW) then this tag can be used
+# to set the initial width (in pixels) of the frame in which the tree is shown.
+# Minimum value: 0, maximum value: 1500, default value: 250.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+TREEVIEW_WIDTH         = 250
+
+# If the EXT_LINKS_IN_WINDOW option is set to YES, doxygen will open links to
+# external symbols imported via tag files in a separate window.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+EXT_LINKS_IN_WINDOW    = NO
+
+# If the HTML_FORMULA_FORMAT option is set to svg, doxygen will use the pdf2svg
+# tool (see https://github.com/dawbarton/pdf2svg) or inkscape (see
+# https://inkscape.org) to generate formulas as SVG images instead of PNGs for
+# the HTML output. These images will generally look nicer at scaled resolutions.
+# Possible values are: png (the default) and svg (looks nicer but requires the
+# pdf2svg or inkscape tool).
+# The default value is: png.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+HTML_FORMULA_FORMAT    = png
+
+# Use this tag to change the font size of LaTeX formulas included as images in
+# the HTML documentation. When you change the font size after a successful
+# doxygen run you need to manually remove any form_*.png images from the HTML
+# output directory to force them to be regenerated.
+# Minimum value: 8, maximum value: 50, default value: 10.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+FORMULA_FONTSIZE       = 10
+
+# Use the FORMULA_TRANSPARENT tag to determine whether or not the images
+# generated for formulas are transparent PNGs. Transparent PNGs are not
+# supported properly for IE 6.0, but are supported on all modern browsers.
+#
+# Note that when changing this option you need to delete any form_*.png files in
+# the HTML output directory before the changes have effect.
+# The default value is: YES.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+FORMULA_TRANSPARENT    = YES
+
+# The FORMULA_MACROFILE can contain LaTeX \newcommand and \renewcommand commands
+# to create new LaTeX commands to be used in formulas as building blocks. See
+# the section "Including formulas" for details.
+
+FORMULA_MACROFILE      =
+
+# Enable the USE_MATHJAX option to render LaTeX formulas using MathJax (see
+# https://www.mathjax.org) which uses client side JavaScript for the rendering
+# instead of using pre-rendered bitmaps. Use this if you do not have LaTeX
+# installed or if you want to formulas look prettier in the HTML output. When
+# enabled you may also need to install MathJax separately and configure the path
+# to it using the MATHJAX_RELPATH option.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+USE_MATHJAX            = NO
+
+# With MATHJAX_VERSION it is possible to specify the MathJax version to be used.
+# Note that the different versions of MathJax have different requirements with
+# regards to the different settings, so it is possible that also other MathJax
+# settings have to be changed when switching between the different MathJax
+# versions.
+# Possible values are: MathJax_2 and MathJax_3.
+# The default value is: MathJax_2.
+# This tag requires that the tag USE_MATHJAX is set to YES.
+
+MATHJAX_VERSION        = MathJax_2
+
+# When MathJax is enabled you can set the default output format to be used for
+# the MathJax output. For more details about the output format see MathJax
+# version 2 (see:
+# http://docs.mathjax.org/en/v2.7-latest/output.html) and MathJax version 3
+# (see:
+# http://docs.mathjax.org/en/latest/web/components/output.html).
+# Possible values are: HTML-CSS (which is slower, but has the best
+# compatibility. This is the name for Mathjax version 2, for MathJax version 3
+# this will be translated into chtml), NativeMML (i.e. MathML. Only supported
+# for NathJax 2. For MathJax version 3 chtml will be used instead.), chtml (This
+# is the name for Mathjax version 3, for MathJax version 2 this will be
+# translated into HTML-CSS) and SVG.
+# The default value is: HTML-CSS.
+# This tag requires that the tag USE_MATHJAX is set to YES.
+
+MATHJAX_FORMAT         = HTML-CSS
+
+# When MathJax is enabled you need to specify the location relative to the HTML
+# output directory using the MATHJAX_RELPATH option. The destination directory
+# should contain the MathJax.js script. For instance, if the mathjax directory
+# is located at the same level as the HTML output directory, then
+# MATHJAX_RELPATH should be ../mathjax. The default value points to the MathJax
+# Content Delivery Network so you can quickly see the result without installing
+# MathJax. However, it is strongly recommended to install a local copy of
+# MathJax from https://www.mathjax.org before deployment. The default value is:
+# - in case of MathJax version 2: https://cdn.jsdelivr.net/npm/mathjax@2
+# - in case of MathJax version 3: https://cdn.jsdelivr.net/npm/mathjax@3
+# This tag requires that the tag USE_MATHJAX is set to YES.
+
+MATHJAX_RELPATH        =
+
+# The MATHJAX_EXTENSIONS tag can be used to specify one or more MathJax
+# extension names that should be enabled during MathJax rendering. For example
+# for MathJax version 2 (see
+# https://docs.mathjax.org/en/v2.7-latest/tex.html#tex-and-latex-extensions):
+# MATHJAX_EXTENSIONS = TeX/AMSmath TeX/AMSsymbols
+# For example for MathJax version 3 (see
+# http://docs.mathjax.org/en/latest/input/tex/extensions/index.html):
+# MATHJAX_EXTENSIONS = ams
+# This tag requires that the tag USE_MATHJAX is set to YES.
+
+MATHJAX_EXTENSIONS     =
+
+# The MATHJAX_CODEFILE tag can be used to specify a file with javascript pieces
+# of code that will be used on startup of the MathJax code. See the MathJax site
+# (see:
+# http://docs.mathjax.org/en/v2.7-latest/output.html) for more details. For an
+# example see the documentation.
+# This tag requires that the tag USE_MATHJAX is set to YES.
+
+MATHJAX_CODEFILE       =
+
+# When the SEARCHENGINE tag is enabled doxygen will generate a search box for
+# the HTML output. The underlying search engine uses javascript and DHTML and
+# should work on any modern browser. Note that when using HTML help
+# (GENERATE_HTMLHELP), Qt help (GENERATE_QHP), or docsets (GENERATE_DOCSET)
+# there is already a search function so this one should typically be disabled.
+# For large projects the javascript based search engine can be slow, then
+# enabling SERVER_BASED_SEARCH may provide a better solution. It is possible to
+# search using the keyboard; to jump to the search box use <access key> + S
+# (what the <access key> is depends on the OS and browser, but it is typically
+# <CTRL>, <ALT>/<option>, or both). Inside the search box use the <cursor down
+# key> to jump into the search results window, the results can be navigated
+# using the <cursor keys>. Press <Enter> to select an item or <escape> to cancel
+# the search. The filter options can be selected when the cursor is inside the
+# search box by pressing <Shift>+<cursor down>. Also here use the <cursor keys>
+# to select a filter and <Enter> or <escape> to activate or cancel the filter
+# option.
+# The default value is: YES.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+SEARCHENGINE           = YES
+
+# When the SERVER_BASED_SEARCH tag is enabled the search engine will be
+# implemented using a web server instead of a web client using JavaScript. There
+# are two flavors of web server based searching depending on the EXTERNAL_SEARCH
+# setting. When disabled, doxygen will generate a PHP script for searching and
+# an index file used by the script. When EXTERNAL_SEARCH is enabled the indexing
+# and searching needs to be provided by external tools. See the section
+# "External Indexing and Searching" for details.
+# The default value is: NO.
+# This tag requires that the tag SEARCHENGINE is set to YES.
+
+SERVER_BASED_SEARCH    = NO
+
+# When EXTERNAL_SEARCH tag is enabled doxygen will no longer generate the PHP
+# script for searching. Instead the search results are written to an XML file
+# which needs to be processed by an external indexer. Doxygen will invoke an
+# external search engine pointed to by the SEARCHENGINE_URL option to obtain the
+# search results.
+#
+# Doxygen ships with an example indexer (doxyindexer) and search engine
+# (doxysearch.cgi) which are based on the open source search engine library
+# Xapian (see:
+# https://xapian.org/).
+#
+# See the section "External Indexing and Searching" for details.
+# The default value is: NO.
+# This tag requires that the tag SEARCHENGINE is set to YES.
+
+EXTERNAL_SEARCH        = NO
+
+# The SEARCHENGINE_URL should point to a search engine hosted by a web server
+# which will return the search results when EXTERNAL_SEARCH is enabled.
+#
+# Doxygen ships with an example indexer (doxyindexer) and search engine
+# (doxysearch.cgi) which are based on the open source search engine library
+# Xapian (see:
+# https://xapian.org/). See the section "External Indexing and Searching" for
+# details.
+# This tag requires that the tag SEARCHENGINE is set to YES.
+
+SEARCHENGINE_URL       =
+
+# When SERVER_BASED_SEARCH and EXTERNAL_SEARCH are both enabled the unindexed
+# search data is written to a file for indexing by an external tool. With the
+# SEARCHDATA_FILE tag the name of this file can be specified.
+# The default file is: searchdata.xml.
+# This tag requires that the tag SEARCHENGINE is set to YES.
+
+SEARCHDATA_FILE        = searchdata.xml
+
+# When SERVER_BASED_SEARCH and EXTERNAL_SEARCH are both enabled the
+# EXTERNAL_SEARCH_ID tag can be used as an identifier for the project. This is
+# useful in combination with EXTRA_SEARCH_MAPPINGS to search through multiple
+# projects and redirect the results back to the right project.
+# This tag requires that the tag SEARCHENGINE is set to YES.
+
+EXTERNAL_SEARCH_ID     =
+
+# The EXTRA_SEARCH_MAPPINGS tag can be used to enable searching through doxygen
+# projects other than the one defined by this configuration file, but that are
+# all added to the same external search index. Each project needs to have a
+# unique id set via EXTERNAL_SEARCH_ID. The search mapping then maps the id of
+# to a relative location where the documentation can be found. The format is:
+# EXTRA_SEARCH_MAPPINGS = tagname1=loc1 tagname2=loc2 ...
+# This tag requires that the tag SEARCHENGINE is set to YES.
+
+EXTRA_SEARCH_MAPPINGS  =
+
+#---------------------------------------------------------------------------
+# Configuration options related to the LaTeX output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_LATEX tag is set to YES, doxygen will generate LaTeX output.
+# The default value is: YES.
+
+GENERATE_LATEX         = YES
+
+# The LATEX_OUTPUT tag is used to specify where the LaTeX docs will be put. If a
+# relative path is entered the value of OUTPUT_DIRECTORY will be put in front of
+# it.
+# The default directory is: latex.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+LATEX_OUTPUT           = latex
+
+# The LATEX_CMD_NAME tag can be used to specify the LaTeX command name to be
+# invoked.
+#
+# Note that when not enabling USE_PDFLATEX the default is latex when enabling
+# USE_PDFLATEX the default is pdflatex and when in the later case latex is
+# chosen this is overwritten by pdflatex. For specific output languages the
+# default can have been set differently, this depends on the implementation of
+# the output language.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+LATEX_CMD_NAME         =
+
+# The MAKEINDEX_CMD_NAME tag can be used to specify the command name to generate
+# index for LaTeX.
+# Note: This tag is used in the Makefile / make.bat.
+# See also: LATEX_MAKEINDEX_CMD for the part in the generated output file
+# (.tex).
+# The default file is: makeindex.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+MAKEINDEX_CMD_NAME     = makeindex
+
+# The LATEX_MAKEINDEX_CMD tag can be used to specify the command name to
+# generate index for LaTeX. In case there is no backslash (\) as first character
+# it will be automatically added in the LaTeX code.
+# Note: This tag is used in the generated output file (.tex).
+# See also: MAKEINDEX_CMD_NAME for the part in the Makefile / make.bat.
+# The default value is: makeindex.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+LATEX_MAKEINDEX_CMD    = makeindex
+
+# If the COMPACT_LATEX tag is set to YES, doxygen generates more compact LaTeX
+# documents. This may be useful for small projects and may help to save some
+# trees in general.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+COMPACT_LATEX          = NO
+
+# The PAPER_TYPE tag can be used to set the paper type that is used by the
+# printer.
+# Possible values are: a4 (210 x 297 mm), letter (8.5 x 11 inches), legal (8.5 x
+# 14 inches) and executive (7.25 x 10.5 inches).
+# The default value is: a4.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+PAPER_TYPE             = a4
+
+# The EXTRA_PACKAGES tag can be used to specify one or more LaTeX package names
+# that should be included in the LaTeX output. The package can be specified just
+# by its name or with the correct syntax as to be used with the LaTeX
+# \usepackage command. To get the times font for instance you can specify :
+# EXTRA_PACKAGES=times or EXTRA_PACKAGES={times}
+# To use the option intlimits with the amsmath package you can specify:
+# EXTRA_PACKAGES=[intlimits]{amsmath}
+# If left blank no extra packages will be included.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+EXTRA_PACKAGES         =
+
+# The LATEX_HEADER tag can be used to specify a user-defined LaTeX header for
+# the generated LaTeX document. The header should contain everything until the
+# first chapter. If it is left blank doxygen will generate a standard header. It
+# is highly recommended to start with a default header using
+# doxygen -w latex new_header.tex new_footer.tex new_stylesheet.sty
+# and then modify the file new_header.tex. See also section "Doxygen usage" for
+# information on how to generate the default header that doxygen normally uses.
+#
+# Note: Only use a user-defined header if you know what you are doing!
+# Note: The header is subject to change so you typically have to regenerate the
+# default header when upgrading to a newer version of doxygen. The following
+# commands have a special meaning inside the header (and footer): For a
+# description of the possible markers and block names see the documentation.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+LATEX_HEADER           = header.tex
+
+# The LATEX_FOOTER tag can be used to specify a user-defined LaTeX footer for
+# the generated LaTeX document. The footer should contain everything after the
+# last chapter. If it is left blank doxygen will generate a standard footer. See
+# LATEX_HEADER for more information on how to generate a default footer and what
+# special commands can be used inside the footer. See also section "Doxygen
+# usage" for information on how to generate the default footer that doxygen
+# normally uses. Note: Only use a user-defined footer if you know what you are
+# doing!
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+LATEX_FOOTER           =
+
+# The LATEX_EXTRA_STYLESHEET tag can be used to specify additional user-defined
+# LaTeX style sheets that are included after the standard style sheets created
+# by doxygen. Using this option one can overrule certain style aspects. Doxygen
+# will copy the style sheet files to the output directory.
+# Note: The order of the extra style sheet files is of importance (e.g. the last
+# style sheet in the list overrules the setting of the previous ones in the
+# list).
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+LATEX_EXTRA_STYLESHEET =
+
+# The LATEX_EXTRA_FILES tag can be used to specify one or more extra images or
+# other source files which should be copied to the LATEX_OUTPUT output
+# directory. Note that the files will be copied as-is; there are no commands or
+# markers available.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+LATEX_EXTRA_FILES      =
+
+# If the PDF_HYPERLINKS tag is set to YES, the LaTeX that is generated is
+# prepared for conversion to PDF (using ps2pdf or pdflatex). The PDF file will
+# contain links (just like the HTML output) instead of page references. This
+# makes the output suitable for online browsing using a PDF viewer.
+# The default value is: YES.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+PDF_HYPERLINKS         = YES
+
+# If the USE_PDFLATEX tag is set to YES, doxygen will use the engine as
+# specified with LATEX_CMD_NAME to generate the PDF file directly from the LaTeX
+# files. Set this option to YES, to get a higher quality PDF documentation.
+#
+# See also section LATEX_CMD_NAME for selecting the engine.
+# The default value is: YES.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+USE_PDFLATEX           = YES
+
+# If the LATEX_BATCHMODE tag is set to YES, doxygen will add the \batchmode
+# command to the generated LaTeX files. This will instruct LaTeX to keep running
+# if errors occur, instead of asking the user for help.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+LATEX_BATCHMODE        = NO
+
+# If the LATEX_HIDE_INDICES tag is set to YES then doxygen will not include the
+# index chapters (such as File Index, Compound Index, etc.) in the output.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+LATEX_HIDE_INDICES     = NO
+
+# The LATEX_BIB_STYLE tag can be used to specify the style to use for the
+# bibliography, e.g. plainnat, or ieeetr. See
+# https://en.wikipedia.org/wiki/BibTeX and \cite for more info.
+# The default value is: plain.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+LATEX_BIB_STYLE        = plain
+
+# If the LATEX_TIMESTAMP tag is set to YES then the footer of each generated
+# page will contain the date and time when the page was generated. Setting this
+# to NO can help when comparing the output of multiple runs.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+LATEX_TIMESTAMP        = NO
+
+# The LATEX_EMOJI_DIRECTORY tag is used to specify the (relative or absolute)
+# path from which the emoji images will be read. If a relative path is entered,
+# it will be relative to the LATEX_OUTPUT directory. If left blank the
+# LATEX_OUTPUT directory will be used.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+LATEX_EMOJI_DIRECTORY  =
+
+#---------------------------------------------------------------------------
+# Configuration options related to the RTF output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_RTF tag is set to YES, doxygen will generate RTF output. The
+# RTF output is optimized for Word 97 and may not look too pretty with other RTF
+# readers/editors.
+# The default value is: NO.
+
+GENERATE_RTF           = NO
+
+# The RTF_OUTPUT tag is used to specify where the RTF docs will be put. If a
+# relative path is entered the value of OUTPUT_DIRECTORY will be put in front of
+# it.
+# The default directory is: rtf.
+# This tag requires that the tag GENERATE_RTF is set to YES.
+
+RTF_OUTPUT             = rtf
+
+# If the COMPACT_RTF tag is set to YES, doxygen generates more compact RTF
+# documents. This may be useful for small projects and may help to save some
+# trees in general.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_RTF is set to YES.
+
+COMPACT_RTF            = NO
+
+# If the RTF_HYPERLINKS tag is set to YES, the RTF that is generated will
+# contain hyperlink fields. The RTF file will contain links (just like the HTML
+# output) instead of page references. This makes the output suitable for online
+# browsing using Word or some other Word compatible readers that support those
+# fields.
+#
+# Note: WordPad (write) and others do not support links.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_RTF is set to YES.
+
+RTF_HYPERLINKS         = NO
+
+# Load stylesheet definitions from file. Syntax is similar to doxygen's
+# configuration file, i.e. a series of assignments. You only have to provide
+# replacements, missing definitions are set to their default value.
+#
+# See also section "Doxygen usage" for information on how to generate the
+# default style sheet that doxygen normally uses.
+# This tag requires that the tag GENERATE_RTF is set to YES.
+
+RTF_STYLESHEET_FILE    =
+
+# Set optional variables used in the generation of an RTF document. Syntax is
+# similar to doxygen's configuration file. A template extensions file can be
+# generated using doxygen -e rtf extensionFile.
+# This tag requires that the tag GENERATE_RTF is set to YES.
+
+RTF_EXTENSIONS_FILE    =
+
+#---------------------------------------------------------------------------
+# Configuration options related to the man page output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_MAN tag is set to YES, doxygen will generate man pages for
+# classes and files.
+# The default value is: NO.
+
+GENERATE_MAN           = NO
+
+# The MAN_OUTPUT tag is used to specify where the man pages will be put. If a
+# relative path is entered the value of OUTPUT_DIRECTORY will be put in front of
+# it. A directory man3 will be created inside the directory specified by
+# MAN_OUTPUT.
+# The default directory is: man.
+# This tag requires that the tag GENERATE_MAN is set to YES.
+
+MAN_OUTPUT             = man
+
+# The MAN_EXTENSION tag determines the extension that is added to the generated
+# man pages. In case the manual section does not start with a number, the number
+# 3 is prepended. The dot (.) at the beginning of the MAN_EXTENSION tag is
+# optional.
+# The default value is: .3.
+# This tag requires that the tag GENERATE_MAN is set to YES.
+
+MAN_EXTENSION          = .3
+
+# The MAN_SUBDIR tag determines the name of the directory created within
+# MAN_OUTPUT in which the man pages are placed. If defaults to man followed by
+# MAN_EXTENSION with the initial . removed.
+# This tag requires that the tag GENERATE_MAN is set to YES.
+
+MAN_SUBDIR             =
+
+# If the MAN_LINKS tag is set to YES and doxygen generates man output, then it
+# will generate one additional man file for each entity documented in the real
+# man page(s). These additional files only source the real man page, but without
+# them the man command would be unable to find the correct page.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_MAN is set to YES.
+
+MAN_LINKS              = NO
+
+#---------------------------------------------------------------------------
+# Configuration options related to the XML output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_XML tag is set to YES, doxygen will generate an XML file that
+# captures the structure of the code including all documentation.
+# The default value is: NO.
+
+GENERATE_XML           = NO
+
+# The XML_OUTPUT tag is used to specify where the XML pages will be put. If a
+# relative path is entered the value of OUTPUT_DIRECTORY will be put in front of
+# it.
+# The default directory is: xml.
+# This tag requires that the tag GENERATE_XML is set to YES.
+
+XML_OUTPUT             = xml
+
+# If the XML_PROGRAMLISTING tag is set to YES, doxygen will dump the program
+# listings (including syntax highlighting and cross-referencing information) to
+# the XML output. Note that enabling this will significantly increase the size
+# of the XML output.
+# The default value is: YES.
+# This tag requires that the tag GENERATE_XML is set to YES.
+
+XML_PROGRAMLISTING     = YES
+
+# If the XML_NS_MEMB_FILE_SCOPE tag is set to YES, doxygen will include
+# namespace members in file scope as well, matching the HTML output.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_XML is set to YES.
+
+XML_NS_MEMB_FILE_SCOPE = NO
+
+#---------------------------------------------------------------------------
+# Configuration options related to the DOCBOOK output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_DOCBOOK tag is set to YES, doxygen will generate Docbook files
+# that can be used to generate PDF.
+# The default value is: NO.
+
+GENERATE_DOCBOOK       = NO
+
+# The DOCBOOK_OUTPUT tag is used to specify where the Docbook pages will be put.
+# If a relative path is entered the value of OUTPUT_DIRECTORY will be put in
+# front of it.
+# The default directory is: docbook.
+# This tag requires that the tag GENERATE_DOCBOOK is set to YES.
+
+DOCBOOK_OUTPUT         = docbook
+
+#---------------------------------------------------------------------------
+# Configuration options for the AutoGen Definitions output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_AUTOGEN_DEF tag is set to YES, doxygen will generate an
+# AutoGen Definitions (see http://autogen.sourceforge.net/) file that captures
+# the structure of the code including all documentation. Note that this feature
+# is still experimental and incomplete at the moment.
+# The default value is: NO.
+
+GENERATE_AUTOGEN_DEF   = NO
+
+#---------------------------------------------------------------------------
+# Configuration options related to Sqlite3 output
+#---------------------------------------------------------------------------
+
+#---------------------------------------------------------------------------
+# Configuration options related to the Perl module output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_PERLMOD tag is set to YES, doxygen will generate a Perl module
+# file that captures the structure of the code including all documentation.
+#
+# Note that this feature is still experimental and incomplete at the moment.
+# The default value is: NO.
+
+GENERATE_PERLMOD       = NO
+
+# If the PERLMOD_LATEX tag is set to YES, doxygen will generate the necessary
+# Makefile rules, Perl scripts and LaTeX code to be able to generate PDF and DVI
+# output from the Perl module output.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_PERLMOD is set to YES.
+
+PERLMOD_LATEX          = NO
+
+# If the PERLMOD_PRETTY tag is set to YES, the Perl module output will be nicely
+# formatted so it can be parsed by a human reader. This is useful if you want to
+# understand what is going on. On the other hand, if this tag is set to NO, the
+# size of the Perl module output will be much smaller and Perl will parse it
+# just the same.
+# The default value is: YES.
+# This tag requires that the tag GENERATE_PERLMOD is set to YES.
+
+PERLMOD_PRETTY         = YES
+
+# The names of the make variables in the generated doxyrules.make file are
+# prefixed with the string contained in PERLMOD_MAKEVAR_PREFIX. This is useful
+# so different doxyrules.make files included by the same Makefile don't
+# overwrite each other's variables.
+# This tag requires that the tag GENERATE_PERLMOD is set to YES.
+
+PERLMOD_MAKEVAR_PREFIX =
+
+#---------------------------------------------------------------------------
+# Configuration options related to the preprocessor
+#---------------------------------------------------------------------------
+
+# If the ENABLE_PREPROCESSING tag is set to YES, doxygen will evaluate all
+# C-preprocessor directives found in the sources and include files.
+# The default value is: YES.
+
+ENABLE_PREPROCESSING   = YES
+
+# If the MACRO_EXPANSION tag is set to YES, doxygen will expand all macro names
+# in the source code. If set to NO, only conditional compilation will be
+# performed. Macro expansion can be done in a controlled way by setting
+# EXPAND_ONLY_PREDEF to YES.
+# The default value is: NO.
+# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.
+
+MACRO_EXPANSION        = NO
+
+# If the EXPAND_ONLY_PREDEF and MACRO_EXPANSION tags are both set to YES then
+# the macro expansion is limited to the macros specified with the PREDEFINED and
+# EXPAND_AS_DEFINED tags.
+# The default value is: NO.
+# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.
+
+EXPAND_ONLY_PREDEF     = NO
+
+# If the SEARCH_INCLUDES tag is set to YES, the include files in the
+# INCLUDE_PATH will be searched if a #include is found.
+# The default value is: YES.
+# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.
+
+SEARCH_INCLUDES        = YES
+
+# The INCLUDE_PATH tag can be used to specify one or more directories that
+# contain include files that are not input files but should be processed by the
+# preprocessor.
+# This tag requires that the tag SEARCH_INCLUDES is set to YES.
+
+INCLUDE_PATH           =
+
+# You can use the INCLUDE_FILE_PATTERNS tag to specify one or more wildcard
+# patterns (like *.h and *.hpp) to filter out the header-files in the
+# directories. If left blank, the patterns specified with FILE_PATTERNS will be
+# used.
+# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.
+
+INCLUDE_FILE_PATTERNS  =
+
+# The PREDEFINED tag can be used to specify one or more macro names that are
+# defined before the preprocessor is started (similar to the -D option of e.g.
+# gcc). The argument of the tag is a list of macros of the form: name or
+# name=definition (no spaces). If the definition and the "=" are omitted, "=1"
+# is assumed. To prevent a macro definition from being undefined via #undef or
+# recursively expanded use the := operator instead of the = operator.
+# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.
+
+PREDEFINED             =
+
+# If the MACRO_EXPANSION and EXPAND_ONLY_PREDEF tags are set to YES then this
+# tag can be used to specify a list of macro names that should be expanded. The
+# macro definition that is found in the sources will be used. Use the PREDEFINED
+# tag if you want to use a different macro definition that overrules the
+# definition found in the source code.
+# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.
+
+EXPAND_AS_DEFINED      =
+
+# If the SKIP_FUNCTION_MACROS tag is set to YES then doxygen's preprocessor will
+# remove all references to function-like macros that are alone on a line, have
+# an all uppercase name, and do not end with a semicolon. Such function macros
+# are typically used for boiler-plate code, and will confuse the parser if not
+# removed.
+# The default value is: YES.
+# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.
+
+SKIP_FUNCTION_MACROS   = YES
+
+#---------------------------------------------------------------------------
+# Configuration options related to external references
+#---------------------------------------------------------------------------
+
+# The TAGFILES tag can be used to specify one or more tag files. For each tag
+# file the location of the external documentation should be added. The format of
+# a tag file without this location is as follows:
+# TAGFILES = file1 file2 ...
+# Adding location for the tag files is done as follows:
+# TAGFILES = file1=loc1 "file2 = loc2" ...
+# where loc1 and loc2 can be relative or absolute paths or URLs. See the
+# section "Linking to external documentation" for more information about the use
+# of tag files.
+# Note: Each tag file must have a unique name (where the name does NOT include
+# the path). If a tag file is not located in the directory in which doxygen is
+# run, you must also specify the path to the tagfile here.
+
+TAGFILES               =
+
+# When a file name is specified after GENERATE_TAGFILE, doxygen will create a
+# tag file that is based on the input files it reads. See section "Linking to
+# external documentation" for more information about the usage of tag files.
+
+GENERATE_TAGFILE       =
+
+# If the ALLEXTERNALS tag is set to YES, all external class will be listed in
+# the class index. If set to NO, only the inherited external classes will be
+# listed.
+# The default value is: NO.
+
+ALLEXTERNALS           = NO
+
+# If the EXTERNAL_GROUPS tag is set to YES, all external groups will be listed
+# in the modules index. If set to NO, only the current project's groups will be
+# listed.
+# The default value is: YES.
+
+EXTERNAL_GROUPS        = YES
+
+# If the EXTERNAL_PAGES tag is set to YES, all external pages will be listed in
+# the related pages index. If set to NO, only the current project's pages will
+# be listed.
+# The default value is: YES.
+
+EXTERNAL_PAGES         = YES
+
+#---------------------------------------------------------------------------
+# Configuration options related to the dot tool
+#---------------------------------------------------------------------------
+
+# If the CLASS_DIAGRAMS tag is set to YES, doxygen will generate a class diagram
+# (in HTML and LaTeX) for classes with base or super classes. Setting the tag to
+# NO turns the diagrams off. Note that this option also works with HAVE_DOT
+# disabled, but it is recommended to install and use dot, since it yields more
+# powerful graphs.
+# The default value is: YES.
+
+CLASS_DIAGRAMS         = YES
+
+# You can include diagrams made with dia in doxygen documentation. Doxygen will
+# then run dia to produce the diagram and insert it in the documentation. The
+# DIA_PATH tag allows you to specify the directory where the dia binary resides.
+# If left empty dia is assumed to be found in the default search path.
+
+DIA_PATH               =
+
+# If set to YES the inheritance and collaboration graphs will hide inheritance
+# and usage relations if the target is undocumented or is not a class.
+# The default value is: YES.
+
+HIDE_UNDOC_RELATIONS   = YES
+
+# If you set the HAVE_DOT tag to YES then doxygen will assume the dot tool is
+# available from the path. This tool is part of Graphviz (see:
+# http://www.graphviz.org/), a graph visualization toolkit from AT&T and Lucent
+# Bell Labs. The other options in this section have no effect if this option is
+# set to NO
+# The default value is: NO.
+
+HAVE_DOT               = NO
+
+# The DOT_NUM_THREADS specifies the number of dot invocations doxygen is allowed
+# to run in parallel. When set to 0 doxygen will base this on the number of
+# processors available in the system. You can set it explicitly to a value
+# larger than 0 to get control over the balance between CPU load and processing
+# speed.
+# Minimum value: 0, maximum value: 32, default value: 0.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+DOT_NUM_THREADS        = 0
+
+# When you want a differently looking font in the dot files that doxygen
+# generates you can specify the font name using DOT_FONTNAME. You need to make
+# sure dot is able to find the font, which can be done by putting it in a
+# standard location or by setting the DOTFONTPATH environment variable or by
+# setting DOT_FONTPATH to the directory containing the font.
+# The default value is: Helvetica.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+DOT_FONTNAME           = Helvetica
+
+# The DOT_FONTSIZE tag can be used to set the size (in points) of the font of
+# dot graphs.
+# Minimum value: 4, maximum value: 24, default value: 10.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+DOT_FONTSIZE           = 10
+
+# By default doxygen will tell dot to use the default font as specified with
+# DOT_FONTNAME. If you specify a different font using DOT_FONTNAME you can set
+# the path where dot can find it using this tag.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+DOT_FONTPATH           =
+
+# If the CLASS_GRAPH tag is set to YES then doxygen will generate a graph for
+# each documented class showing the direct and indirect inheritance relations.
+# Setting this tag to YES will force the CLASS_DIAGRAMS tag to NO.
+# The default value is: YES.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+CLASS_GRAPH            = YES
+
+# If the COLLABORATION_GRAPH tag is set to YES then doxygen will generate a
+# graph for each documented class showing the direct and indirect implementation
+# dependencies (inheritance, containment, and class references variables) of the
+# class with other documented classes.
+# The default value is: YES.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+COLLABORATION_GRAPH    = YES
+
+# If the GROUP_GRAPHS tag is set to YES then doxygen will generate a graph for
+# groups, showing the direct groups dependencies.
+# The default value is: YES.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+GROUP_GRAPHS           = YES
+
+# If the UML_LOOK tag is set to YES, doxygen will generate inheritance and
+# collaboration diagrams in a style similar to the OMG's Unified Modeling
+# Language.
+# The default value is: NO.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+UML_LOOK               = NO
+
+# If the UML_LOOK tag is enabled, the fields and methods are shown inside the
+# class node. If there are many fields or methods and many nodes the graph may
+# become too big to be useful. The UML_LIMIT_NUM_FIELDS threshold limits the
+# number of items for each type to make the size more manageable. Set this to 0
+# for no limit. Note that the threshold may be exceeded by 50% before the limit
+# is enforced. So when you set the threshold to 10, up to 15 fields may appear,
+# but if the number exceeds 15, the total amount of fields shown is limited to
+# 10.
+# Minimum value: 0, maximum value: 100, default value: 10.
+# This tag requires that the tag UML_LOOK is set to YES.
+
+UML_LIMIT_NUM_FIELDS   = 10
+
+# If the DOT_UML_DETAILS tag is set to NO, doxygen will show attributes and
+# methods without types and arguments in the UML graphs. If the DOT_UML_DETAILS
+# tag is set to YES, doxygen will add type and arguments for attributes and
+# methods in the UML graphs. If the DOT_UML_DETAILS tag is set to NONE, doxygen
+# will not generate fields with class member information in the UML graphs. The
+# class diagrams will look similar to the default class diagrams but using UML
+# notation for the relationships.
+# Possible values are: NO, YES and NONE.
+# The default value is: NO.
+# This tag requires that the tag UML_LOOK is set to YES.
+
+DOT_UML_DETAILS        = NO
+
+# The DOT_WRAP_THRESHOLD tag can be used to set the maximum number of characters
+# to display on a single line. If the actual line length exceeds this threshold
+# significantly it will wrapped across multiple lines. Some heuristics are apply
+# to avoid ugly line breaks.
+# Minimum value: 0, maximum value: 1000, default value: 17.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+DOT_WRAP_THRESHOLD     = 17
+
+# If the TEMPLATE_RELATIONS tag is set to YES then the inheritance and
+# collaboration graphs will show the relations between templates and their
+# instances.
+# The default value is: NO.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+TEMPLATE_RELATIONS     = NO
+
+# If the INCLUDE_GRAPH, ENABLE_PREPROCESSING and SEARCH_INCLUDES tags are set to
+# YES then doxygen will generate a graph for each documented file showing the
+# direct and indirect include dependencies of the file with other documented
+# files.
+# The default value is: YES.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+INCLUDE_GRAPH          = YES
+
+# If the INCLUDED_BY_GRAPH, ENABLE_PREPROCESSING and SEARCH_INCLUDES tags are
+# set to YES then doxygen will generate a graph for each documented file showing
+# the direct and indirect include dependencies of the file with other documented
+# files.
+# The default value is: YES.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+INCLUDED_BY_GRAPH      = YES
+
+# If the CALL_GRAPH tag is set to YES then doxygen will generate a call
+# dependency graph for every global function or class method.
+#
+# Note that enabling this option will significantly increase the time of a run.
+# So in most cases it will be better to enable call graphs for selected
+# functions only using the \callgraph command. Disabling a call graph can be
+# accomplished by means of the command \hidecallgraph.
+# The default value is: NO.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+CALL_GRAPH             = NO
+
+# If the CALLER_GRAPH tag is set to YES then doxygen will generate a caller
+# dependency graph for every global function or class method.
+#
+# Note that enabling this option will significantly increase the time of a run.
+# So in most cases it will be better to enable caller graphs for selected
+# functions only using the \callergraph command. Disabling a caller graph can be
+# accomplished by means of the command \hidecallergraph.
+# The default value is: NO.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+CALLER_GRAPH           = NO
+
+# If the GRAPHICAL_HIERARCHY tag is set to YES then doxygen will graphical
+# hierarchy of all classes instead of a textual one.
+# The default value is: YES.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+GRAPHICAL_HIERARCHY    = YES
+
+# If the DIRECTORY_GRAPH tag is set to YES then doxygen will show the
+# dependencies a directory has on other directories in a graphical way. The
+# dependency relations are determined by the #include relations between the
+# files in the directories.
+# The default value is: YES.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+DIRECTORY_GRAPH        = YES
+
+# The DOT_IMAGE_FORMAT tag can be used to set the image format of the images
+# generated by dot. For an explanation of the image formats see the section
+# output formats in the documentation of the dot tool (Graphviz (see:
+# http://www.graphviz.org/)).
+# Note: If you choose svg you need to set HTML_FILE_EXTENSION to xhtml in order
+# to make the SVG files visible in IE 9+ (other browsers do not have this
+# requirement).
+# Possible values are: png, jpg, gif, svg, png:gd, png:gd:gd, png:cairo,
+# png:cairo:gd, png:cairo:cairo, png:cairo:gdiplus, png:gdiplus and
+# png:gdiplus:gdiplus.
+# The default value is: png.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+DOT_IMAGE_FORMAT       = png
+
+# If DOT_IMAGE_FORMAT is set to svg, then this option can be set to YES to
+# enable generation of interactive SVG images that allow zooming and panning.
+#
+# Note that this requires a modern browser other than Internet Explorer. Tested
+# and working are Firefox, Chrome, Safari, and Opera.
+# Note: For IE 9+ you need to set HTML_FILE_EXTENSION to xhtml in order to make
+# the SVG files visible. Older versions of IE do not have SVG support.
+# The default value is: NO.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+INTERACTIVE_SVG        = NO
+
+# The DOT_PATH tag can be used to specify the path where the dot tool can be
+# found. If left blank, it is assumed the dot tool can be found in the path.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+DOT_PATH               =
+
+# The DOTFILE_DIRS tag can be used to specify one or more directories that
+# contain dot files that are included in the documentation (see the \dotfile
+# command).
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+DOTFILE_DIRS           =
+
+# The MSCFILE_DIRS tag can be used to specify one or more directories that
+# contain msc files that are included in the documentation (see the \mscfile
+# command).
+
+MSCFILE_DIRS           =
+
+# The DIAFILE_DIRS tag can be used to specify one or more directories that
+# contain dia files that are included in the documentation (see the \diafile
+# command).
+
+DIAFILE_DIRS           =
+
+# When using plantuml, the PLANTUML_JAR_PATH tag should be used to specify the
+# path where java can find the plantuml.jar file. If left blank, it is assumed
+# PlantUML is not used or called during a preprocessing step. Doxygen will
+# generate a warning when it encounters a \startuml command in this case and
+# will not generate output for the diagram.
+
+PLANTUML_JAR_PATH      =
+
+# When using plantuml, the PLANTUML_CFG_FILE tag can be used to specify a
+# configuration file for plantuml.
+
+PLANTUML_CFG_FILE      =
+
+# When using plantuml, the specified paths are searched for files specified by
+# the !include statement in a plantuml block.
+
+PLANTUML_INCLUDE_PATH  =
+
+# The DOT_GRAPH_MAX_NODES tag can be used to set the maximum number of nodes
+# that will be shown in the graph. If the number of nodes in a graph becomes
+# larger than this value, doxygen will truncate the graph, which is visualized
+# by representing a node as a red box. Note that doxygen if the number of direct
+# children of the root node in a graph is already larger than
+# DOT_GRAPH_MAX_NODES then the graph will not be shown at all. Also note that
+# the size of a graph can be further restricted by MAX_DOT_GRAPH_DEPTH.
+# Minimum value: 0, maximum value: 10000, default value: 50.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+DOT_GRAPH_MAX_NODES    = 50
+
+# The MAX_DOT_GRAPH_DEPTH tag can be used to set the maximum depth of the graphs
+# generated by dot. A depth value of 3 means that only nodes reachable from the
+# root by following a path via at most 3 edges will be shown. Nodes that lay
+# further from the root node will be omitted. Note that setting this option to 1
+# or 2 may greatly reduce the computation time needed for large code bases. Also
+# note that the size of a graph can be further restricted by
+# DOT_GRAPH_MAX_NODES. Using a depth of 0 means no depth restriction.
+# Minimum value: 0, maximum value: 1000, default value: 0.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+MAX_DOT_GRAPH_DEPTH    = 0
+
+# Set the DOT_TRANSPARENT tag to YES to generate images with a transparent
+# background. This is disabled by default, because dot on Windows does not seem
+# to support this out of the box.
+#
+# Warning: Depending on the platform used, enabling this option may lead to
+# badly anti-aliased labels on the edges of a graph (i.e. they become hard to
+# read).
+# The default value is: NO.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+DOT_TRANSPARENT        = NO
+
+# Set the DOT_MULTI_TARGETS tag to YES to allow dot to generate multiple output
+# files in one run (i.e. multiple -o and -T options on the command line). This
+# makes dot run faster, but since only newer versions of dot (>1.8.10) support
+# this, this feature is disabled by default.
+# The default value is: NO.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+DOT_MULTI_TARGETS      = NO
+
+# If the GENERATE_LEGEND tag is set to YES doxygen will generate a legend page
+# explaining the meaning of the various boxes and arrows in the dot generated
+# graphs.
+# The default value is: YES.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+GENERATE_LEGEND        = YES
+
+# If the DOT_CLEANUP tag is set to YES, doxygen will remove the intermediate
+# files that are used to generate the various graphs.
+#
+# Note: This setting is not only used for dot files but also for msc temporary
+# files.
+# The default value is: YES.
+
+DOT_CLEANUP            = YES
diff --git a/doxygen.sty b/doxygen.sty
new file mode 100644
index 0000000..326f830
--- /dev/null
+++ b/doxygen.sty
@@ -0,0 +1,589 @@
+% stylesheet for doxygen 1.9.2
+\NeedsTeXFormat{LaTeX2e}
+\ProvidesPackage{doxygen}
+
+% Packages used by this style file
+\RequirePackage{alltt}
+%%\RequirePackage{array} %% moved to refman.tex due to workaround for LaTex 2019 version and unmaintained tabu package
+\RequirePackage{calc}
+\RequirePackage{float}
+%%\RequirePackage{ifthen} %% moved to refman.tex due to workaround for LaTex 2019 version and unmaintained tabu package
+\RequirePackage{verbatim}
+\RequirePackage[table]{xcolor}
+\RequirePackage{longtable_doxygen}
+\RequirePackage{tabu_doxygen}
+\RequirePackage{fancyvrb}
+\RequirePackage{tabularx}
+\RequirePackage{multicol}
+\RequirePackage{multirow}
+\RequirePackage{hanging}
+\RequirePackage{ifpdf}
+\RequirePackage{adjustbox}
+\RequirePackage{amssymb}
+\RequirePackage{stackengine}
+\RequirePackage{enumitem}
+\RequirePackage{alphalph}
+\RequirePackage[normalem]{ulem} % for strikeout, but don't modify emphasis
+
+%---------- Internal commands used in this style file ----------------
+
+\newcommand{\ensurespace}[1]{%
+  \begingroup%
+    \setlength{\dimen@}{#1}%
+    \vskip\z@\@plus\dimen@%
+    \penalty -100\vskip\z@\@plus -\dimen@%
+    \vskip\dimen@%
+    \penalty 9999%
+    \vskip -\dimen@%
+    \vskip\z@skip% hide the previous |\vskip| from |\addvspace|
+  \endgroup%
+}
+
+\newcommand{\DoxyHorRuler}[1]{%
+  \setlength{\parskip}{0ex plus 0ex minus 0ex}%
+  \ifthenelse{#1=0}%
+  {%
+    \hrule%
+  }%
+  {%
+    \hrulefilll%
+  }%
+}
+\newcommand{\DoxyLabelFont}{}
+\newcommand{\entrylabel}[1]{%
+  {%
+    \parbox[b]{\labelwidth-4pt}{%
+      \makebox[0pt][l]{\DoxyLabelFont#1}%
+      \vspace{1.5\baselineskip}%
+    }%
+  }%
+}
+
+\newenvironment{DoxyDesc}[1]{%
+  \ensurespace{4\baselineskip}%
+  \begin{list}{}{%
+    \settowidth{\labelwidth}{20pt}%
+    %\setlength{\parsep}{0pt}%
+    \setlength{\itemsep}{0pt}%
+    \setlength{\leftmargin}{\labelwidth+\labelsep}%
+    \renewcommand{\makelabel}{\entrylabel}%
+  }%
+  \item[#1]%
+}{%
+  \end{list}%
+}
+
+\newsavebox{\xrefbox}
+\newlength{\xreflength}
+\newcommand{\xreflabel}[1]{%
+  \sbox{\xrefbox}{#1}%
+  \setlength{\xreflength}{\wd\xrefbox}%
+  \ifthenelse{\xreflength>\labelwidth}{%
+    \begin{minipage}{\textwidth}%
+      \setlength{\parindent}{0pt}%
+      \hangindent=15pt\bfseries #1\vspace{1.2\itemsep}%
+    \end{minipage}%
+  }{%
+   \parbox[b]{\labelwidth}{\makebox[0pt][l]{\textbf{#1}}}%
+  }%
+}
+
+%---------- Commands used by doxygen LaTeX output generator ----------
+
+% Used by <pre> ... </pre>
+\newenvironment{DoxyPre}{%
+  \small%
+  \begin{alltt}%
+}{%
+  \end{alltt}%
+  \normalsize%
+}
+% Necessary for redefining not defined characters, i.e. "Replacement Character" in tex output.
+\newlength{\CodeWidthChar}
+\newlength{\CodeHeightChar}
+\settowidth{\CodeWidthChar}{?}
+\settoheight{\CodeHeightChar}{?}
+% Necessary for hanging indent
+\newlength{\DoxyCodeWidth}
+
+\newcommand\DoxyCodeLine[1]{\hangpara{\DoxyCodeWidth}{1}{#1}\par}
+
+\newcommand\NiceSpace{%
+     \discretionary{}{\kern\fontdimen2\font}{\kern\fontdimen2\font}%
+}
+
+% Used by @code ... @endcode
+\newenvironment{DoxyCode}[1]{%
+  \par%
+  \scriptsize%
+  \normalfont\ttfamily%
+  \rightskip0pt plus 1fil%
+  \settowidth{\DoxyCodeWidth}{000000}%
+  \settowidth{\CodeWidthChar}{?}%
+  \settoheight{\CodeHeightChar}{?}%
+  \setlength{\parskip}{0ex plus 0ex minus 0ex}%
+  \ifthenelse{\equal{#1}{0}}
+  {
+    {\lccode`~32 \lowercase{\global\let~}\NiceSpace}\obeyspaces%
+  }
+  {
+    {\lccode`~32 \lowercase{\global\let~}}\obeyspaces%
+  }
+
+}{%
+  \normalfont%
+  \normalsize%
+  \settowidth{\CodeWidthChar}{?}%
+  \settoheight{\CodeHeightChar}{?}%
+}
+
+% Redefining not defined characters, i.e. "Replacement Character" in tex output.
+\def\ucr{\adjustbox{width=\CodeWidthChar,height=\CodeHeightChar}{\stackinset{c}{}{c}{-.2pt}{%
+   \textcolor{white}{\sffamily\bfseries\small ?}}{%
+   \rotatebox{45}{$\blacksquare$}}}}
+
+% Used by @example, @include, @includelineno and @dontinclude
+\newenvironment{DoxyCodeInclude}[1]{%
+	\DoxyCode{#1}%
+}{%
+  \endDoxyCode%
+}
+
+% Used by @verbatim ... @endverbatim
+\newenvironment{DoxyVerb}{%
+  \footnotesize%
+  \verbatim%
+}{%
+  \endverbatim%
+  \normalsize%
+}
+
+% Used by @verbinclude
+\newenvironment{DoxyVerbInclude}{%
+  \DoxyVerb%
+}{%
+  \endDoxyVerb%
+}
+
+% Used by numbered lists (using '-#' or <ol> ... </ol>)
+\newenvironment{DoxyEnumerate}{%
+  \enumerate%
+}{%
+  \endenumerate%
+}
+
+% Used by bullet lists (using '-', @li, @arg, or <ul> ... </ul>)
+\newenvironment{DoxyItemize}{%
+  \itemize%
+}{%
+  \enditemize%
+}
+
+% Used by description lists (using <dl> ... </dl>)
+\newenvironment{DoxyDescription}{%
+  \description%
+}{%
+  \enddescription%
+}
+
+% Used by @image, @dotfile, @dot ... @enddot, and @msc ... @endmsc
+% (only if caption is specified)
+\newenvironment{DoxyImage}{%
+  \begin{figure}[H]%
+    \centering%
+}{%
+  \end{figure}%
+}
+
+% Used by @image, @dotfile, @dot ... @enddot, and @msc ... @endmsc
+% (only if no caption is specified)
+\newenvironment{DoxyImageNoCaption}{%
+  \begin{center}%
+}{%
+  \end{center}%
+}
+
+% Used by @image
+% (only if inline is specified)
+\newenvironment{DoxyInlineImage}{%
+}{%
+}
+
+% Used by @attention
+\newenvironment{DoxyAttention}[1]{%
+  \begin{DoxyDesc}{#1}%
+}{%
+  \end{DoxyDesc}%
+}
+
+% Used by @author and @authors
+\newenvironment{DoxyAuthor}[1]{%
+  \begin{DoxyDesc}{#1}%
+}{%
+  \end{DoxyDesc}%
+}
+
+% Used by @date
+\newenvironment{DoxyDate}[1]{%
+  \begin{DoxyDesc}{#1}%
+}{%
+  \end{DoxyDesc}%
+}
+
+% Used by @invariant
+\newenvironment{DoxyInvariant}[1]{%
+  \begin{DoxyDesc}{#1}%
+}{%
+  \end{DoxyDesc}%
+}
+
+% Used by @note
+\newenvironment{DoxyNote}[1]{%
+  \begin{DoxyDesc}{#1}%
+}{%
+  \end{DoxyDesc}%
+}
+
+% Used by @post
+\newenvironment{DoxyPostcond}[1]{%
+  \begin{DoxyDesc}{#1}%
+}{%
+  \end{DoxyDesc}%
+}
+
+% Used by @pre
+\newenvironment{DoxyPrecond}[1]{%
+  \begin{DoxyDesc}{#1}%
+}{%
+  \end{DoxyDesc}%
+}
+
+% Used by @copyright
+\newenvironment{DoxyCopyright}[1]{%
+  \begin{DoxyDesc}{#1}%
+}{%
+  \end{DoxyDesc}%
+}
+
+% Used by @remark
+\newenvironment{DoxyRemark}[1]{%
+  \begin{DoxyDesc}{#1}%
+}{%
+  \end{DoxyDesc}%
+}
+
+% Used by @return and @returns
+\newenvironment{DoxyReturn}[1]{%
+  \begin{DoxyDesc}{#1}%
+}{%
+  \end{DoxyDesc}%
+}
+
+% Used by @since
+\newenvironment{DoxySince}[1]{%
+  \begin{DoxyDesc}{#1}%
+}{%
+  \end{DoxyDesc}%
+}
+
+% Used by @see
+\newenvironment{DoxySeeAlso}[1]{%
+  \begin{DoxyDesc}{#1}%
+}{%
+  \end{DoxyDesc}%
+}
+
+% Used by @version
+\newenvironment{DoxyVersion}[1]{%
+  \begin{DoxyDesc}{#1}%
+}{%
+  \end{DoxyDesc}%
+}
+
+% Used by @warning
+\newenvironment{DoxyWarning}[1]{%
+  \begin{DoxyDesc}{#1}%
+}{%
+  \end{DoxyDesc}%
+}
+
+% Used by @internal
+\newenvironment{DoxyInternal}[1]{%
+  \paragraph*{#1}%
+}{%
+}
+
+% Used by @par and @paragraph
+\newenvironment{DoxyParagraph}[1]{%
+  \begin{DoxyDesc}{#1}%
+}{%
+  \end{DoxyDesc}%
+}
+
+% Used by parameter lists
+\newenvironment{DoxyParams}[2][]{%
+    \tabulinesep=1mm%
+    \par%
+    \ifthenelse{\equal{#1}{}}%
+      {\begin{longtabu*}spread 0pt [l]{|X[-1,l]|X[-1,l]|}}% name + description
+    {\ifthenelse{\equal{#1}{1}}%
+      {\begin{longtabu*}spread 0pt [l]{|X[-1,l]|X[-1,l]|X[-1,l]|}}% in/out + name + desc
+      {\begin{longtabu*}spread 0pt [l]{|X[-1,l]|X[-1,l]|X[-1,l]|X[-1,l]|}}% in/out + type + name + desc
+    }
+    \multicolumn{2}{l}{\hspace{-6pt}\bfseries\fontseries{bc}\selectfont\color{darkgray} #2}\\[1ex]%
+    \hline%
+    \endfirsthead%
+    \multicolumn{2}{l}{\hspace{-6pt}\bfseries\fontseries{bc}\selectfont\color{darkgray} #2}\\[1ex]%
+    \hline%
+    \endhead%
+}{%
+    \end{longtabu*}%
+    \vspace{6pt}%
+}
+
+% Used for fields of simple structs
+\newenvironment{DoxyFields}[1]{%
+    \tabulinesep=1mm%
+    \par%
+    \begin{longtabu*}spread 0pt [l]{|X[-1,r]|X[-1,l]|X[-1,l]|}%
+    \multicolumn{3}{l}{\hspace{-6pt}\bfseries\fontseries{bc}\selectfont\color{darkgray} #1}\\[1ex]%
+    \hline%
+    \endfirsthead%
+    \multicolumn{3}{l}{\hspace{-6pt}\bfseries\fontseries{bc}\selectfont\color{darkgray} #1}\\[1ex]%
+    \hline%
+    \endhead%
+}{%
+    \end{longtabu*}%
+    \vspace{6pt}%
+}
+
+% Used for fields simple class style enums
+\newenvironment{DoxyEnumFields}[1]{%
+    \tabulinesep=1mm%
+    \par%
+    \begin{longtabu*}spread 0pt [l]{|X[-1,r]|X[-1,l]|}%
+    \multicolumn{2}{l}{\hspace{-6pt}\bfseries\fontseries{bc}\selectfont\color{darkgray} #1}\\[1ex]%
+    \hline%
+    \endfirsthead%
+    \multicolumn{2}{l}{\hspace{-6pt}\bfseries\fontseries{bc}\selectfont\color{darkgray} #1}\\[1ex]%
+    \hline%
+    \endhead%
+}{%
+    \end{longtabu*}%
+    \vspace{6pt}%
+}
+
+% Used for parameters within a detailed function description
+\newenvironment{DoxyParamCaption}{%
+  \renewcommand{\item}[2][]{\\ \hspace*{2.0cm} ##1 {\em ##2}}% 
+}{%
+}
+
+% Used by return value lists
+\newenvironment{DoxyRetVals}[1]{%
+    \tabulinesep=1mm%
+    \par%
+    \begin{longtabu*}spread 0pt [l]{|X[-1,r]|X[-1,l]|}%
+    \multicolumn{2}{l}{\hspace{-6pt}\bfseries\fontseries{bc}\selectfont\color{darkgray} #1}\\[1ex]%
+    \hline%
+    \endfirsthead%
+    \multicolumn{2}{l}{\hspace{-6pt}\bfseries\fontseries{bc}\selectfont\color{darkgray} #1}\\[1ex]%
+    \hline%
+    \endhead%
+}{%
+    \end{longtabu*}%
+    \vspace{6pt}%
+}
+
+% Used by exception lists
+\newenvironment{DoxyExceptions}[1]{%
+    \tabulinesep=1mm%
+    \par%
+    \begin{longtabu*}spread 0pt [l]{|X[-1,r]|X[-1,l]|}%
+    \multicolumn{2}{l}{\hspace{-6pt}\bfseries\fontseries{bc}\selectfont\color{darkgray} #1}\\[1ex]%
+    \hline%
+    \endfirsthead%
+    \multicolumn{2}{l}{\hspace{-6pt}\bfseries\fontseries{bc}\selectfont\color{darkgray} #1}\\[1ex]%
+    \hline%
+    \endhead%
+}{%
+    \end{longtabu*}%
+    \vspace{6pt}%
+}
+
+% Used by template parameter lists
+\newenvironment{DoxyTemplParams}[1]{%
+    \tabulinesep=1mm%
+    \par%
+    \begin{longtabu*}spread 0pt [l]{|X[-1,r]|X[-1,l]|}%
+    \multicolumn{2}{l}{\hspace{-6pt}\bfseries\fontseries{bc}\selectfont\color{darkgray} #1}\\[1ex]%
+    \hline%
+    \endfirsthead%
+    \multicolumn{2}{l}{\hspace{-6pt}\bfseries\fontseries{bc}\selectfont\color{darkgray} #1}\\[1ex]%
+    \hline%
+    \endhead%
+}{%
+    \end{longtabu*}%
+    \vspace{6pt}%
+}
+
+% Used for member lists
+\newenvironment{DoxyCompactItemize}{%
+  \begin{itemize}%
+    \setlength{\itemsep}{-3pt}%
+    \setlength{\parsep}{0pt}%
+    \setlength{\topsep}{0pt}%
+    \setlength{\partopsep}{0pt}%
+}{%
+  \end{itemize}%
+}
+
+% Used for member descriptions
+\newenvironment{DoxyCompactList}{%
+  \begin{list}{}{%
+    \setlength{\leftmargin}{0.5cm}%
+    \setlength{\itemsep}{0pt}%
+    \setlength{\parsep}{0pt}%
+    \setlength{\topsep}{0pt}%
+    \renewcommand{\makelabel}{\hfill}%
+  }%
+}{%
+  \end{list}%
+}
+
+% Used for reference lists (@bug, @deprecated, @todo, etc.)
+\newenvironment{DoxyRefList}{%
+  \begin{list}{}{%
+    \setlength{\labelwidth}{10pt}%
+    \setlength{\leftmargin}{\labelwidth}%
+    \addtolength{\leftmargin}{\labelsep}%
+    \renewcommand{\makelabel}{\xreflabel}%
+  }%
+}{%
+  \end{list}%
+}
+
+% Used by @bug, @deprecated, @todo, etc.
+\newenvironment{DoxyRefDesc}[1]{%
+  \begin{list}{}{%
+    \renewcommand\makelabel[1]{\textbf{##1}}%
+    \settowidth\labelwidth{\makelabel{#1}}%
+    \setlength\leftmargin{\labelwidth+\labelsep}%
+  }%
+}{%
+  \end{list}%
+}
+
+% Used by parameter lists and simple sections
+\newenvironment{Desc}
+{\begin{list}{}{%
+    \settowidth{\labelwidth}{20pt}%
+    \setlength{\parsep}{0pt}%
+    \setlength{\itemsep}{0pt}%
+    \setlength{\leftmargin}{\labelwidth+\labelsep}%
+    \renewcommand{\makelabel}{\entrylabel}%
+  }
+}{%
+  \end{list}%
+}
+
+% Used by tables
+\newcommand{\PBS}[1]{\let\temp=\\#1\let\\=\temp}%
+\newenvironment{TabularC}[1]%
+{\tabulinesep=1mm
+\begin{longtabu*}spread 0pt [c]{*#1{|X[-1]}|}}%
+{\end{longtabu*}\par}%
+
+\newenvironment{TabularNC}[1]%
+{\begin{tabu}spread 0pt [l]{*#1{|X[-1]}|}}%
+{\end{tabu}\par}%
+
+% Used for member group headers
+\newenvironment{Indent}{%
+  \begin{list}{}{%
+    \setlength{\leftmargin}{0.5cm}%
+  }%
+  \item[]\ignorespaces%
+}{%
+  \unskip%
+  \end{list}%
+}
+
+% Used when hyperlinks are turned off
+\newcommand{\doxyref}[3]{%
+  \textbf{#1} (\textnormal{#2}\,\pageref{#3})%
+}
+
+% Used to link to a table when hyperlinks are turned on
+\newcommand{\doxytablelink}[2]{%
+  \ref{#1}%
+}
+
+% Used to link to a table when hyperlinks are turned off
+\newcommand{\doxytableref}[3]{%
+  \ref{#3}%
+}
+
+% Used by @addindex
+\newcommand{\lcurly}{\{}
+\newcommand{\rcurly}{\}}
+
+% Colors used for syntax highlighting
+\definecolor{comment}{rgb}{0.5,0.0,0.0}
+\definecolor{keyword}{rgb}{0.0,0.5,0.0}
+\definecolor{keywordtype}{rgb}{0.38,0.25,0.125}
+\definecolor{keywordflow}{rgb}{0.88,0.5,0.0}
+\definecolor{preprocessor}{rgb}{0.5,0.38,0.125}
+\definecolor{stringliteral}{rgb}{0.0,0.125,0.25}
+\definecolor{charliteral}{rgb}{0.0,0.5,0.5}
+\definecolor{vhdldigit}{rgb}{1.0,0.0,1.0}
+\definecolor{vhdlkeyword}{rgb}{0.43,0.0,0.43}
+\definecolor{vhdllogic}{rgb}{1.0,0.0,0.0}
+\definecolor{vhdlchar}{rgb}{0.0,0.0,0.0}
+
+% Color used for table heading
+\newcommand{\tableheadbgcolor}{lightgray}%
+
+% Version of hypertarget with correct landing location
+\newcommand{\Hypertarget}[1]{\Hy@raisedlink{\hypertarget{#1}{}}}
+
+% possibility to have sections etc. be within the margins
+% unfortunately had to copy part of book.cls and add \raggedright
+\makeatletter
+\newcommand\doxysection{\@startsection {section}{1}{\z@}%
+                                   {-3.5ex \@plus -1ex \@minus -.2ex}%
+                                   {2.3ex \@plus.2ex}%
+                                   {\raggedright\normalfont\Large\bfseries}}
+\newcommand\doxysubsection{\@startsection{subsection}{2}{\z@}%
+                                     {-3.25ex\@plus -1ex \@minus -.2ex}%
+                                     {1.5ex \@plus .2ex}%
+                                     {\raggedright\normalfont\large\bfseries}}
+\newcommand\doxysubsubsection{\@startsection{subsubsection}{3}{\z@}%
+                                     {-3.25ex\@plus -1ex \@minus -.2ex}%
+                                     {1.5ex \@plus .2ex}%
+                                     {\raggedright\normalfont\normalsize\bfseries}}
+\newcommand\doxyparagraph{\@startsection{paragraph}{4}{\z@}%
+                                    {3.25ex \@plus1ex \@minus.2ex}%
+                                    {-1em}%
+                                    {\raggedright\normalfont\normalsize\bfseries}}
+\newcommand\doxysubparagraph{\@startsection{subparagraph}{5}{\parindent}%
+                                       {3.25ex \@plus1ex \@minus .2ex}%
+                                       {-1em}%
+                                      {\raggedright\normalfont\normalsize\bfseries}}
+\makeatother
+% Define caption that is also suitable in a table
+\makeatletter
+\def\doxyfigcaption{%
+\H@refstepcounter{figure}%
+\@dblarg{\@caption{figure}}}
+\makeatother
+
+% Define alpha enumarative names for counters > 26
+\makeatletter
+\def\enumalphalphcnt#1{\expandafter\@enumalphalphcnt\csname c@#1\endcsname}
+\def\@enumalphalphcnt#1{\alphalph{#1}}
+\def\enumAlphAlphcnt#1{\expandafter\@enumAlphAlphcnt\csname c@#1\endcsname}
+\def\@enumAlphAlphcnt#1{\AlphAlph{#1}}
+\makeatother
+\AddEnumerateCounter{\enumalphalphcnt}{\@enumalphalphcnt}{aa}
+\AddEnumerateCounter{\enumAlphAlphcnt}{\@enumAlphAlphcnt}{AA}
diff --git a/footer.tex b/footer.tex
new file mode 100644
index 0000000..384988f
--- /dev/null
+++ b/footer.tex
@@ -0,0 +1,51 @@
+% Latex footer for doxygen 1.9.2
+%--- End generated contents ---
+
+%%BEGIN CITATIONS_PRESENT
+  % Bibliography
+  \newpage
+  \phantomsection
+
+%%BEGIN !PDF_HYPERLINKS
+   \clearemptydoublepage
+%%BEGIN COMPACT_LATEX
+   \addcontentsline{toc}{section}{$latexcitereference}
+%%END COMPACT_LATEX
+%%BEGIN !COMPACT_LATEX
+   \addcontentsline{toc}{chapter}{$latexcitereference}
+%%END !COMPACT_LATEX
+  \printindex
+%%END !PDF_HYPERLINKS
+
+  \bibliographystyle{$latexbibstyle}
+  \bibliography{$latexbibfiles}
+%%BEGIN PDF_HYPERLINKS
+%%BEGIN COMPACT_LATEX
+    \addcontentsline{toc}{section}{$latexcitereference}
+%%END COMPACT_LATEX
+%%BEGIN !COMPACT_LATEX
+    \addcontentsline{toc}{chapter}{$latexcitereference}
+%%END !COMPACT_LATEX
+%%END PDF_HYPERLINKS
+
+%%END CITATIONS_PRESENT
+
+% Index
+%%BEGIN !COMPACT_LATEX
+  \backmatter
+%%END !COMPACT_LATEX
+  \newpage
+  \phantomsection
+  \clearemptydoublepage
+%%BEGIN COMPACT_LATEX
+  \addcontentsline{toc}{section}{\indexname}
+%%END COMPACT_LATEX
+%%BEGIN !COMPACT_LATEX
+  \addcontentsline{toc}{chapter}{\indexname}
+%%END !COMPACT_LATEX
+  \printindex
+
+% Required for some languages (in combination with latexdocumentpre from the header)
+$latexdocumentpost
+\end{document}
+
diff --git a/header.tex b/header.tex
new file mode 100644
index 0000000..4a51e52
--- /dev/null
+++ b/header.tex
@@ -0,0 +1,250 @@
+% Latex header for doxygen 1.9.2
+  % Handle batch mode
+%%BEGIN LATEX_BATCHMODE
+  \batchmode
+%%END LATEX_BATCHMODE
+
+  % to overcome problems with too many open files
+  \let\mypdfximage\pdfximage\def\pdfximage{\immediate\mypdfximage}
+
+  % Set document class depending on configuration
+%%BEGIN COMPACT_LATEX
+  \documentclass[twoside]{article}
+%%END COMPACT_LATEX
+%%BEGIN !COMPACT_LATEX
+  \documentclass[twoside]{book}
+%%END !COMPACT_LATEX
+
+  %% moved from doxygen.sty due to workaround for LaTex 2019 version and unmaintained tabu package
+  \usepackage{ifthen}
+  \ifx\requestedLaTeXdate\undefined
+    \usepackage{array}
+  \else
+    \usepackage{array}[=2016-10-06]
+  \fi
+  %%
+
+  % Packages required by doxygen
+  \usepackage{fixltx2e} % for \textsubscript
+  \usepackage{doxygen}
+
+  $extralatexstylesheet
+
+  \usepackage{graphicx}
+  \usepackage[utf8]{inputenc}
+  \usepackage{makeidx}
+  \PassOptionsToPackage{warn}{textcomp}
+  \usepackage{textcomp}
+  \usepackage[nointegrals]{wasysym}
+  \usepackage{ifxetex}
+
+  % NLS support packages
+  $languagesupport
+
+  % Define default fonts
+  % Font selection
+%%BEGIN LATEX_FONTENC
+  \usepackage[$latexfontenc]{fontenc}
+%%END LATEX_FONTENC
+
+  % set main and monospaced font
+  $latexfont
+
+  \usepackage{sectsty}
+  \allsectionsfont{%
+    \fontseries{bc}\selectfont%
+    \color{darkgray}%
+  }
+  \renewcommand{\DoxyLabelFont}{%
+    \fontseries{bc}\selectfont%
+    \color{darkgray}%
+  }
+  \newcommand{\+}{\discretionary{\mbox{\scriptsize$\hookleftarrow$}}{}{}}
+
+   % Arguments of doxygenemoji:
+   % 1) ':<text>:' form of the emoji, already LaTeX-escaped
+   % 2) file with the name of the emoji without the .png extension
+   % in case image exist use this otherwise use the ':<text>:' form
+   \newcommand{\doxygenemoji}[2]{%
+     \IfFileExists{$latexemojidirectory/#2.png}{\raisebox{-0.1em}{\includegraphics[height=0.9em]{$latexemojidirectory/#2.png}}}{#1}%
+   }
+
+  % Page & text layout
+  \usepackage{geometry}
+  \geometry{%
+    $papertype,%
+    top=2.5cm,%
+    bottom=2.5cm,%
+    left=2.5cm,%
+    right=2.5cm%
+  }
+
+  % Allow a bit of overflow to go unnoticed by other means
+  \tolerance=750
+  \hfuzz=15pt
+  \hbadness=750
+  \setlength{\emergencystretch}{15pt}
+  \setlength{\parindent}{0cm}
+  \newcommand{\doxynormalparskip}{\setlength{\parskip}{3ex plus 2ex minus 2ex}}
+  \newcommand{\doxytocparskip}{\setlength{\parskip}{1ex plus 0ex minus 0ex}}
+  \doxynormalparskip
+  % Redefine paragraph/subparagraph environments, using sectsty fonts
+  \makeatletter
+  \renewcommand{\paragraph}{%
+    \@startsection{paragraph}{4}{0ex}{-1.0ex}{1.0ex}{%
+      \normalfont\normalsize\bfseries\SS@parafont%
+    }%
+  }
+  \renewcommand{\subparagraph}{%
+    \@startsection{subparagraph}{5}{0ex}{-1.0ex}{1.0ex}{%
+      \normalfont\normalsize\bfseries\SS@subparafont%
+    }%
+  }
+  \makeatother
+
+  \makeatletter
+  \newcommand\hrulefilll{\leavevmode\leaders\hrule\hskip 0pt plus 1filll\kern\z@}
+  \makeatother
+
+  % Headers & footers
+  \usepackage{fancyhdr}
+  \pagestyle{fancyplain}
+  \renewcommand{\footrulewidth}{0.4pt}
+
+  \fancypagestyle{fancyplain}{
+    \fancyhf{}
+    \fancyhead[LE, RO]{\bfseries\thepage}
+    \fancyhead[LO]{\bfseries\rightmark}
+    \fancyhead[RE]{\bfseries\leftmark}
+    % \fancyfoot[LO, RE]{\bfseries\scriptsize $generatedby Doxygen }
+  }
+
+  \fancypagestyle{plain}{
+    \fancyhf{}
+    % \fancyfoot[LO, RE]{\bfseries\scriptsize $generatedby Doxygen }
+    \renewcommand{\headrulewidth}{0pt}
+  }
+
+  \pagestyle{fancyplain}
+
+
+%%BEGIN !COMPACT_LATEX
+  \renewcommand{\chaptermark}[1]{%
+    \markboth{#1}{}%
+  }
+%%END !COMPACT_LATEX
+  \renewcommand{\sectionmark}[1]{%
+    \markright{\thesection\ #1}%
+  }
+
+  % ToC, LoF, LoT, bibliography, and index
+  % Indices & bibliography
+  \usepackage{natbib}
+  \usepackage[titles]{tocloft}
+  \setcounter{tocdepth}{3}
+  \setcounter{secnumdepth}{5}
+
+  % creating indexes
+  $makeindex
+
+  $extralatexpackages
+
+  $latexspecialformulachars
+
+%%BEGIN FORMULA_MACROFILE
+  \input{$formulamacrofile}
+%%END FORMULA_MACROFILE
+
+  % Hyperlinks
+%%BEGIN PDF_HYPERLINKS
+    % Hyperlinks (required, but should be loaded last)
+    \ifpdf
+      \usepackage[pdftex,pagebackref=true]{hyperref}
+    \else
+      \ifxetex
+        \usepackage[pagebackref=true]{hyperref}
+      \else
+        \usepackage[ps2pdf,pagebackref=true]{hyperref}
+      \fi
+    \fi
+
+    \hypersetup{%
+      colorlinks=true,%
+      linkcolor=blue,%
+      citecolor=blue,%
+      unicode%
+    }
+
+%%END PDF_HYPERLINKS
+
+  % Custom commands used by the header
+  % Custom commands
+  \newcommand{\clearemptydoublepage}{%
+    \newpage{\pagestyle{empty}\cleardoublepage}%
+  }
+
+  % caption style definition
+  \usepackage{caption}
+  \captionsetup{labelsep=space,justification=centering,font={bf},singlelinecheck=off,skip=4pt,position=top}
+
+
+  % in page table of contents
+  \usepackage{etoc}
+  \etocsettocstyle{\doxytocparskip}{\doxynormalparskip}
+
+  % prevent numbers overlap the titles in toc
+  \renewcommand{\numberline}[1]{#1~}
+
+% End of preamble, now comes the document contents
+%===== C O N T E N T S =====
+
+\begin{document}
+  \raggedbottom
+
+  $latexdocumentpre
+
+  % Titlepage & ToC
+%%BEGIN PDF_HYPERLINKS
+%%BEGIN USE_PDFLATEX
+    % To avoid duplicate page anchors due to reuse of same numbers for
+    % the index (be it as roman numbers)
+    \hypersetup{pageanchor=false,
+                bookmarksnumbered=true,
+                pdfencoding=unicode
+               }
+%%END USE_PDFLATEX
+%%END PDF_HYPERLINKS
+  \pagenumbering{alph}
+  \begin{titlepage}
+  \vspace*{7cm}
+  \begin{center}%
+  {\Large $title}\\
+  \vspace*{1cm}
+  {\large $generatedby Doxygen $doxygenversion}\\
+%%BEGIN LATEX_TIMESTAMP
+    \vspace*{0.5cm}
+    {\small $datetime}
+%%END LATEX_TIMESTAMP
+  \end{center}
+  \end{titlepage}
+
+%%BEGIN !COMPACT_LATEX
+  \clearemptydoublepage
+%%END !COMPACT_LATEX
+  \pagenumbering{roman}
+
+  \tableofcontents
+%%BEGIN !COMPACT_LATEX
+  \clearemptydoublepage
+%%END !COMPACT_LATEX
+  \pagenumbering{arabic}
+
+%%BEGIN PDF_HYPERLINKS
+%%BEGIN USE_PDFLATEX
+  % re-enable anchors again
+  \hypersetup{pageanchor=true}
+%%END USE_PDFLATEX
+%%END PDF_HYPERLINKS
+
+%--- Begin generated contents ---
+
diff --git a/src/red_black.c b/src/red_black.c
index c658162..dbe0d40 100644
--- a/src/red_black.c
+++ b/src/red_black.c
@@ -13,6 +13,7 @@ rb_n* rb_cr(int key, void *dado)
 {
     rb_n *a = (rb_n *) malloc(sizeof(rb_n));
     a->k = key;
+    /** raiz sempre colorido com preto */
     a->c = 0;
     a->d = dado;
     a->p = a->l = a->r = NULL;
@@ -41,6 +42,8 @@ int rb_ins_elem(rb_n *a, int k, void *e)
             it = (rb_n *) malloc(sizeof(rb_n));
             it->d = e;
             it->k = k;
+            /** cor vermelha por default na insercao */
+            it->c = 1;
             it->l = it->r = NULL;
 
             if (rl == 0)
diff --git a/src/red_black.h b/src/red_black.h
index b16d42f..4db5559 100644
--- a/src/red_black.h
+++ b/src/red_black.h
@@ -22,12 +22,14 @@
  * @c cor (c de color ou cor, 0-black, 1-red)
  * @t tipo (t de tipo ou type)
  * @d dado (de de data ou dados)
+ * @np numero de nohs pretos ateh a folha 
  * @l @r @p l-eft filho a esquerda, r-ight filho a direta e p-arent, noh pai
  */
 typedef struct rb_n {
     int k;
     char c:1;
     void *d;
+    unsigned int np;
     struct rb_n *l, *r, *p;
 } rb_n;
 

commit b89cc58e414bedb599010b7e6b231a61a87c16eb
Author: Joilnen <joilnen@gmail.com>
Date:   Sat Dec 18 14:21:28 2021 -0300

    lidando com o bit da coloracao do noh na rb

diff --git a/src/red_black.c b/src/red_black.c
index dbe0d40..75505bc 100644
--- a/src/red_black.c
+++ b/src/red_black.c
@@ -28,11 +28,11 @@ int rb_ins_elem(rb_n *a, int k, void *e)
     while (it)
     {
         rb_n *tmp = it;
-        char rl = 0;
+        int rl = 0;
         if (k < it->k)
-            it = it->l, rl = 0 << 0;
+            it = it->l, rl = !!0;
         else if (k > it->k)
-            it = it->r, rl = 1 << 0;
+            it = it->r, rl = !0;
         else return -1;
 
         printf("rl %d\n", rl);
@@ -46,9 +46,9 @@ int rb_ins_elem(rb_n *a, int k, void *e)
             it->c = 1;
             it->l = it->r = NULL;
 
-            if (rl == 0)
+            if (rl & 0)
                 tmp->l = it;
-            else if(rl == 1)
+            else 
                 tmp->r = it;
             return 0;
         }
diff --git a/src/red_black.h b/src/red_black.h
index 4db5559..cf4306a 100644
--- a/src/red_black.h
+++ b/src/red_black.h
@@ -27,7 +27,7 @@
  */
 typedef struct rb_n {
     int k;
-    char c:1;
+    unsigned char c:1;
     void *d;
     unsigned int np;
     struct rb_n *l, *r, *p;

commit c8b58499800984bac7f9912c9853ef92f5f19395
Author: Joilnen <joilnen@gmail.com>
Date:   Sat Dec 18 15:05:28 2021 -0300

    adicionando alguns comentarios para documentacao nos fontes

diff --git a/src/red_black.c b/src/red_black.c
index 75505bc..3cbb909 100644
--- a/src/red_black.c
+++ b/src/red_black.c
@@ -1,4 +1,4 @@
-/**
+/*
  * aluno: joilnen leite
  * arquivo separado do main, como especificado 
  * de implementacao das funcoes da redblack 
diff --git a/src/red_black.h b/src/red_black.h
index cf4306a..3cf9eca 100644
--- a/src/red_black.h
+++ b/src/red_black.h
@@ -1,12 +1,12 @@
 #ifndef REDBLACK_H
 #define REDBLACK_H
 
-/**
+/*
  * aluno: joilnen leite
  */
 #include <stdlib.h>
 
-/**
+/*
  * rubro negra
  * 0 - todo noh eh vermelho ou preto
  * 1 - raiz sempre preta
@@ -40,25 +40,91 @@ typedef struct rb_n {
  */
 rb_n* rb_cr(int key, void *dado);
 
+/**
+ * @a noh raiz da arvore
+ * retorna numero de elementos da arvore
+ */
 unsigned int rb_nelem(rb_n *a);
 
+/**
+ * @a noh raiz da arvore
+ * @k chave do elemento a ser inserido
+ * @e tipo genperico de dado a ser guardado neste noh
+ */
 int rb_ins_elem(rb_n *a, int k, void *e);
+
+/**
+ * @a noh raiz da arvore
+ * @k chave do elemento a ser excluido
+ */
 int rb_exclui_elem(rb_n *a, int k);
+
+/**
+ * @a noh raiz da arvore
+ * @k chave do elemento a ser checado
+ * retorna 0 se o lelemento nao existe na arvore
+ * ou diferente de zero caso exista
+ */
 int rb_exite_elem(rb_n *a, int k);
 
+/**
+ * @a noh raiz da arvore
+ * @b noh raiz da arvore a ser operada
+ * retorna ponteir para uma nova arvore fruto da interseccao
+ * das duas arvores @a  e @b
+ */
 rb_n* rb_intersec(rb_n *a, rb_n *b);
+
+/**
+ * @a noh raiz da arvore
+ * @b noh raiz da arvore a ser operada
+ * retorna ponteir para uma nova arvore fruto da uniao
+ * das duas arvores @a  e @b
+ */
 rb_n* rb_une(rb_n *a, rb_n *b);
+
+/**
+ * @a noh raiz da arvore
+ * @b noh raiz da arvore a ser operada
+ * retorna ponteir para uma nova arvore fruto da subtracao
+ * das duas arvores @a  e @b
+ */
 rb_n* rb_subtrai(rb_n *a, rb_n *b);
 
+/**
+ * deleta, e desaloca recursos de memoria
+ * para a arvore apontada por @a 
+ */
 int rb_destroi(rb_n **a);
 
+/**
+ * troca a cor de um noh apontado por @a
+ */
 int rb_troca_cor(rb_n *a);
+
+/**
+ * rotaciona subarvore a esquerda apartir do noh @a
+ */
 int rb_rot_esq(rb_n *r, rb_n *w);
+
+/**
+ * rotaciona subarvore a direita apartir do noh @a
+ */
 int rb_rot_dir(rb_n *r, rb_n *w);
 
-extern void (*rb_impr_elem)(rb_n *);
+/**
+ * imprime elemento como definido pelo o codigo cliente da biblioteca
+ */
+xtern void (*rb_impr_elem)(rb_n *);
+
+/**
+ * seta a rotina de impressao do dado criado pelo cliente
+ */
 int rb_seta_impr_elem(void (*i)(rb_n *n));
 
+/**
+ * imprime arvore @a
+ */
 void rb_pr(rb_n *a);
 
 #endif

commit cfa71cb32fd85286fdc6b4fc7981c4776c3180a4
Author: Joilnen <joilnen@gmail.com>
Date:   Sat Dec 18 16:05:59 2021 -0300

    melhorando a documentacao nos comentarios

diff --git a/src/red_black.c b/src/red_black.c
index 3cbb909..5e1efa9 100644
--- a/src/red_black.c
+++ b/src/red_black.c
@@ -13,7 +13,7 @@ rb_n* rb_cr(int key, void *dado)
 {
     rb_n *a = (rb_n *) malloc(sizeof(rb_n));
     a->k = key;
-    /** raiz sempre colorido com preto */
+    /** raiz sempre colorida com preto */
     a->c = 0;
     a->d = dado;
     a->p = a->l = a->r = NULL;
diff --git a/src/red_black.h b/src/red_black.h
index 3cf9eca..a5048cf 100644
--- a/src/red_black.h
+++ b/src/red_black.h
@@ -17,13 +17,14 @@
 
 /**
  * composicao do noh da RB
- * @rb_n noh red black
- * @k chave (k de key)
- * @c cor (c de color ou cor, 0-black, 1-red)
- * @t tipo (t de tipo ou type)
- * @d dado (de de data ou dados)
- * @np numero de nohs pretos ateh a folha 
- * @l @r @p l-eft filho a esquerda, r-ight filho a direta e p-arent, noh pai
+ * @param rb_n noh red black
+ * @param k chave (k de key)
+ * @param c cor (c de color ou cor, 0-black, 1-red)
+ * @param d dado (d de data ou dados)
+ * @param np numero de nohs pretos ateh a folha 
+ * @param l left, ponteiro para filho a esquerda
+ * @param r right, ponteiro para filho a direta
+ * @param p parent, ponteiro para noh pai
  */
 typedef struct rb_n {
     int k;
@@ -34,81 +35,80 @@ typedef struct rb_n {
 } rb_n;
 
 /**
- * cria o primeiro noh, o raiz da arvore rb
- * serah o primeiro elemento criado na arvore
- * e o primeiro do conjunto ordenado
+ * cria o primeiro noh, a raiz da arvore rb,
  */
 rb_n* rb_cr(int key, void *dado);
 
 /**
- * @a noh raiz da arvore
+ * @param a noh raiz da arvore
  * retorna numero de elementos da arvore
  */
 unsigned int rb_nelem(rb_n *a);
 
 /**
- * @a noh raiz da arvore
- * @k chave do elemento a ser inserido
- * @e tipo genperico de dado a ser guardado neste noh
+ * @param a noh raiz da arvore
+ * @param k chave do elemento a ser inserido
+ * @param e tipo generico de dado a ser guardado neste noh
  */
 int rb_ins_elem(rb_n *a, int k, void *e);
 
 /**
- * @a noh raiz da arvore
- * @k chave do elemento a ser excluido
+ * @param a noh raiz da arvore
+ * @param k chave do elemento a ser excluido
  */
 int rb_exclui_elem(rb_n *a, int k);
 
 /**
- * @a noh raiz da arvore
- * @k chave do elemento a ser checado
+ * @param a noh raiz da arvore
+ * @param k chave do elemento a ser checado
  * retorna 0 se o lelemento nao existe na arvore
  * ou diferente de zero caso exista
  */
 int rb_exite_elem(rb_n *a, int k);
 
 /**
- * @a noh raiz da arvore
- * @b noh raiz da arvore a ser operada
- * retorna ponteir para uma nova arvore fruto da interseccao
- * das duas arvores @a  e @b
+ * @param a noh raiz da arvore
+ * @param b noh raiz da arvore a ser operada
+ * @return retorna ponteiro para uma nova arvore fruto da interseccao
+ * das duas arvores @param a  e @param b
  */
 rb_n* rb_intersec(rb_n *a, rb_n *b);
 
 /**
- * @a noh raiz da arvore
- * @b noh raiz da arvore a ser operada
+ * @param a noh raiz da arvore
+ * @param b noh raiz da arvore a ser operada
  * retorna ponteir para uma nova arvore fruto da uniao
- * das duas arvores @a  e @b
+ * das duas arvores @param a  e @param b
  */
 rb_n* rb_une(rb_n *a, rb_n *b);
 
 /**
- * @a noh raiz da arvore
- * @b noh raiz da arvore a ser operada
+ * @param a noh raiz da arvore
+ * @param b noh raiz da arvore a ser operada
  * retorna ponteir para uma nova arvore fruto da subtracao
- * das duas arvores @a  e @b
+ * das duas arvores @param a  e @param b
  */
 rb_n* rb_subtrai(rb_n *a, rb_n *b);
 
 /**
  * deleta, e desaloca recursos de memoria
- * para a arvore apontada por @a 
+ * para a arvore apontada por @param a 
  */
 int rb_destroi(rb_n **a);
 
 /**
- * troca a cor de um noh apontado por @a
+ * troca a cor de um noh apontado por @param a
  */
 int rb_troca_cor(rb_n *a);
 
 /**
- * rotaciona subarvore a esquerda apartir do noh @a
+ * rotaciona subarvore a esquerda apartir do noh @param a
  */
 int rb_rot_esq(rb_n *r, rb_n *w);
 
 /**
- * rotaciona subarvore a direita apartir do noh @a
+ * rotaciona subarvore a direita apartir do noh
+ * @param a noh 
  */
 int rb_rot_dir(rb_n *r, rb_n *w);
 
@@ -123,7 +123,7 @@ xtern void (*rb_impr_elem)(rb_n *);
 int rb_seta_impr_elem(void (*i)(rb_n *n));
 
 /**
- * imprime arvore @a
+ * imprime arvore @param a
  */
 void rb_pr(rb_n *a);
 

commit a71d7223b5a14740b069b1129d63ff593b7e3095
Author: Joilnen <joilnen@gmail.com>
Date:   Sat Dec 18 16:12:33 2021 -0300

    conserdanto um pequeno erro de digitacao

diff --git a/src/red_black.h b/src/red_black.h
index a5048cf..c09ae56 100644
--- a/src/red_black.h
+++ b/src/red_black.h
@@ -115,7 +115,7 @@ int rb_rot_dir(rb_n *r, rb_n *w);
 /**
  * imprime elemento como definido pelo o codigo cliente da biblioteca
  */
-xtern void (*rb_impr_elem)(rb_n *);
+extern void (*rb_impr_elem)(rb_n *);
 
 /**
  * seta a rotina de impressao do dado criado pelo cliente

commit 407fbad6094efb087f5ea41fcfb424c1699a4216
Author: Joilnen <joilnen@gmail.com>
Date:   Sun Dec 19 00:36:30 2021 -0300

    changing makefile

diff --git a/src/makefile b/src/makefile
index 6fe7410..d201161 100644
--- a/src/makefile
+++ b/src/makefile
@@ -1,17 +1,17 @@
 #
-# Aluno: Joilnen Leite
+# Aluno: 
 #
 
 C=gcc
 S=main.c conjunto_ordenado.c red_black.c
 O=main.o conjunto_ordenado.o red_black.o
-B=rodeme
+E=rodeme
 D=-g
 
 .c.o:
 	$(C) -c $(D) $<
 all: $(O) 
-	$(C) -o $(B) $(O)
+	$(C) -o $(E) $(O)
 clean:
-	rm -f *.o $(B)
+	rm -f *.o $(E)
 
diff --git a/src/red_black.c b/src/red_black.c
index 5e1efa9..8b13789 100644
--- a/src/red_black.c
+++ b/src/red_black.c
@@ -1,144 +1 @@
-/*
- * aluno: joilnen leite
- * arquivo separado do main, como especificado 
- * de implementacao das funcoes da redblack 
- * utilizada no conjunto ordenado
- */
-#include "red_black.h"
-#include <stdio.h>
-
-void (*rb_impr_elem)(rb_n *);
-
-rb_n* rb_cr(int key, void *dado)
-{
-    rb_n *a = (rb_n *) malloc(sizeof(rb_n));
-    a->k = key;
-    /** raiz sempre colorida com preto */
-    a->c = 0;
-    a->d = dado;
-    a->p = a->l = a->r = NULL;
-
-    return a;
-}
-
-int rb_ins_elem(rb_n *a, int k, void *e)
-{
-    rb_n *it = a;
-    printf("k %d it->k %d\n", k, it->k);
-    while (it)
-    {
-        rb_n *tmp = it;
-        int rl = 0;
-        if (k < it->k)
-            it = it->l, rl = !!0;
-        else if (k > it->k)
-            it = it->r, rl = !0;
-        else return -1;
-
-        printf("rl %d\n", rl);
-
-        if (!it)
-        {
-            it = (rb_n *) malloc(sizeof(rb_n));
-            it->d = e;
-            it->k = k;
-            /** cor vermelha por default na insercao */
-            it->c = 1;
-            it->l = it->r = NULL;
-
-            if (rl & 0)
-                tmp->l = it;
-            else 
-                tmp->r = it;
-            return 0;
-        }
-    }
-
-    return -1;
-}
-
-int rb_exclui_elem(rb_n *a, int k)
-{
-    return 0;
-}
-
-rb_n* rb_intersec(rb_n *a, rb_n *b)
-{
-    return NULL;
-}
-
-rb_n* rb_une(rb_n *a, rb_n *b)
-{
-    return NULL;
-}
-
-rb_n* rb_subtrai(rb_n *a, rb_n *b)
-{
-    return NULL;
-}
-
-int rb_destroi(rb_n **a)
-{
-    return 0;
-}
-
-int rb_rot_esq(rb_n *r, rb_n *w)
-{
-    rb_n *v = w->r;
-    w->r = v->l;
-    if (v->l)
-        v->l->p = w;
-    v->p = w->p;
-    if (!w->p)
-        r = v;
-    else
-    {
-        if (w == w->p->l)
-            w->p->l = v;
-        else
-            w->p->r = v;
-    }
-    v->l = w;
-    w->p = v;
-
-    return 0;
-}
-
-int rb_rot_dir(rb_n *r, rb_n *w)
-{
-    rb_n *v = w->l;
-    w->l = v->r;
-    if (v->r)
-        v->r->p = w;
-    v->p = w->p;
-    if (!w->p)
-        r = v;
-    else
-    {
-        if (w == w->p->r)
-            w->p->r = v;
-        else
-            w->p->l = v;
-    }
-    v->r = w;
-    w->p = v;
-
-    return 0;
-}
-
-int rb_seta_impr_elem(void (*i)(rb_n *n))
-{
-    rb_impr_elem = i;
-}
-
-void rb_pr(rb_n *a)
-{
-    if (a)
-    {
-        printf("k:%dc:%d\n", a->k, a->c);
-        rb_pr(a->l);
-        rb_pr(a->r);
-    }
-}
-
 

commit 6f728d3673b2ac981c030adfd1fc87f88e4c0611
Author: Joilnen <joilnen@gmail.com>
Date:   Sun Dec 19 00:46:07 2021 -0300

    recuperando red_black.c foi perdido por algum problema no nvim

diff --git a/src/red_black.c b/src/red_black.c
index 8b13789..e0b04e8 100644
--- a/src/red_black.c
+++ b/src/red_black.c
@@ -1 +1,138 @@
+/*
+ * aluno: joilnen leite
+ * arquivo separado do main, como especificado 
+ * de implementacao das funcoes da redblack 
+ * utilizada no conjunto ordenado
+ */
+#include "red_black.h"
+#include <stdio.h>
+
+void (*rb_impr_elem)(rb_n *);
+
+rb_n* rb_cr(int key, void *dado)
+{
+    rb_n *a = (rb_n *) malloc(sizeof(rb_n));
+    a->k = key;
+    /** raiz sempre colorida com preto */
+    a->c = 0;
+    a->d = dado;
+    a->p = a->l = a->r = NULL;
+
+    return a;
+}
+
+int rb_ins_elem(rb_n *a, int k, void *e)
+{
+    rb_n *it = a;
+    printf("k %d it->k %d\n", k, it->k);
+    while (it)
+    {
+        rb_n *tmp = it;
+        int rl = 0;
+        if (k < it->k)
+            it = it->l, rl = !!0;
+        else if (k > it->k)
+            it = it->r, rl = !0;
+        else return -1;
+
+        printf("rl %d\n", rl);
+
+        if (!it)
+        {
+            it = (rb_n *) malloc(sizeof(rb_n));
+            it->d = e;
+            it->k = k;
+            /** cor vermelha por default na insercao */
+            it->c = 1;
+            it->l = it->r = NULL;
+
+            if (rl & 0)
+                tmp->l = it;
+            else 
+                tmp->r = it;
+            return 0;
+        }
+    }
+
+    return -1;
+}
+
+int rb_exclui_elem(rb_n *a, int k)
+{
+    return 0;
+}
+
+rb_n* rb_intersec(rb_n *a, rb_n *b)
+{
+    return NULL;
+}
+
+rb_n* rb_une(rb_n *a, rb_n *b)
+{
+    return NULL;
+}
+
+rb_n* rb_subtrai(rb_n *a, rb_n *b)
+{
+    return NULL;
+}
+
+int rb_destroi(rb_n **a)
+{
+    return 0;
+}
+
+int rb_rot_esq(rb_n *r, rb_n *w)
+{
+    rb_n *v = w->r;
+    w->r = v->l;
+    if (v->l)
+        v->l->p = w;
+    v->p = w->p;
+    if (!w->p)
+        r = v;
+    else if (w == w->p->l)
+        w->p->l = v;
+    else
+        w->p->r = v;
+    v->l = w;
+    w->p = v;
+
+    return 0;
+}
+
+int rb_rot_dir(rb_n *r, rb_n *w)
+{
+    rb_n *v = w->l;
+    w->l = v->r;
+    if (v->r)
+        v->r->p = w;
+    v->p = w->p;
+    if (!w->p)
+        r = v;
+    else if (w == w->p->r)
+        w->p->r = v;
+    else
+        w->p->l = v;
+    v->r = w;
+    w->p = v;
+
+    return 0;
+}
+
+int rb_seta_impr_elem(void (*i)(rb_n *n))
+{
+    rb_impr_elem = i;
+}
+
+void rb_pr(rb_n *a)
+{
+    if (a)
+    {
+        printf("k:%dc:%d\n", a->k, a->c);
+        rb_pr(a->l);
+        rb_pr(a->r);
+    }
+}
+
 

commit 9668c7ddd355dbd3e77431a1b4b6d7fd59e4dba5
Author: Joilnen <joilnen@gmail.com>
Date:   Sun Dec 19 08:01:31 2021 -0300

    insersao baseado no algoritmo mostrado em aula que eh o mesmo do cormen

diff --git a/src/red_black.c b/src/red_black.c
index e0b04e8..ed530c6 100644
--- a/src/red_black.c
+++ b/src/red_black.c
@@ -7,6 +7,13 @@
 #include "red_black.h"
 #include <stdio.h>
 
+/**
+ * definicao  do que eh considerado RED e BLACK
+ * neste codigo para maior clareza
+ */
+#define BLACK 0
+#define RED 1
+
 void (*rb_impr_elem)(rb_n *);
 
 rb_n* rb_cr(int key, void *dado)
@@ -14,7 +21,7 @@ rb_n* rb_cr(int key, void *dado)
     rb_n *a = (rb_n *) malloc(sizeof(rb_n));
     a->k = key;
     /** raiz sempre colorida com preto */
-    a->c = 0;
+    a->c = BLACK;
     a->d = dado;
     a->p = a->l = a->r = NULL;
 
@@ -57,6 +64,78 @@ int rb_ins_elem(rb_n *a, int k, void *e)
     return -1;
 }
 
+/**
+ * inclusao baseado no livro do cormen
+ */
+int rb_insert_cormen(rb_n *t, rb_n *z)
+{
+    rb_n *y = NULL;
+    rb_n *x = t;
+    while (x)
+    {
+        y = x;
+        if (z->k < x->k)
+            x = x->l;
+        else x = x->r;
+    }
+    z->p = y;
+    if (!y)
+        t = z;
+    else if (z->k < y->k)
+        y->l = z;
+    else
+        y->r = z;
+    z->l = z->r = NULL;
+    z->c = RED;
+    /** ajuste */
+    while (z->p->c == RED)
+    {
+        if (z->p == z->p->p->l)
+        {
+            y = z->p->p->r;
+            if (y->c == RED)
+            {
+                z->p->c = BLACK;
+                y->p->p->c = RED;
+                z = z->p->p;
+            }
+            else 
+            {
+                if (z == z->p->r)
+                {
+                    z = z->p;
+                    rb_rot_esq(t, z);
+                }
+                z->p->c = BLACK;
+                z->p->p->c = RED;
+                rb_rot_dir(t, z->p->p);
+            }
+        }
+        else
+        {
+            y = z->p->p->l;
+            if (y->c == RED)
+            {
+                z->p->c = BLACK;
+                y->p->p->c = RED;
+                z = z->p->p;
+            }
+            else 
+            {
+                if (z == z->p->l)
+                {
+                    z = z->p;
+                    rb_rot_dir(t, z);
+                }
+                z->p->c = BLACK;
+                z->p->p->c = RED;
+                rb_rot_esq(t, z->p->p);
+            }
+        }
+    }
+    t->c = BLACK;
+}
+
 int rb_exclui_elem(rb_n *a, int k)
 {
     return 0;
diff --git a/src/red_black.h b/src/red_black.h
index c09ae56..42c905b 100644
--- a/src/red_black.h
+++ b/src/red_black.h
@@ -52,6 +52,12 @@ unsigned int rb_nelem(rb_n *a);
  */
 int rb_ins_elem(rb_n *a, int k, void *e);
 
+/**
+ * @param a noh raiz da arvore
+ * @param b elemento a ser inserido
+ */
+int rb_insert_cormen(rb_n *t, rb_n *z);
+
 /**
  * @param a noh raiz da arvore
  * @param k chave do elemento a ser excluido

commit b11b5a14445c3a4e73b523c00740929d55d8dce6
Author: Joilnen <joilnen@gmail.com>
Date:   Sun Dec 19 08:52:11 2021 -0300

    funcoes baseadas no livro do cormen e nas nostas de aula da prof. Luciana Lee

diff --git a/src/red_black.c b/src/red_black.c
index ed530c6..4de5272 100644
--- a/src/red_black.c
+++ b/src/red_black.c
@@ -67,7 +67,7 @@ int rb_ins_elem(rb_n *a, int k, void *e)
 /**
  * inclusao baseado no livro do cormen
  */
-int rb_insert_cormen(rb_n *t, rb_n *z)
+int rb_insert(rb_n *t, rb_n *z)
 {
     rb_n *y = NULL;
     rb_n *x = t;
@@ -136,6 +136,140 @@ int rb_insert_cormen(rb_n *t, rb_n *z)
     t->c = BLACK;
 }
 
+/**
+ * fucnao que faz trocas auxiliares na delecao
+ */
+static int rb_transplant(rb_n *t, rb_n *u, rb_n *v)
+{
+    if (!u->p)
+        t = v;
+    else if (u == u->p->l)
+        u->p->l = v;
+    else
+        u->p->r = v;
+    v->p = u->p;
+}
+
+static rb_n *tree_minimum(rb_n *x)
+{
+    rb_n *a = x;
+    while (a->r)
+        a = a->r;
+    return a;
+}
+
+int rb_delete(rb_n *t, rb_n *z)
+{
+    rb_n *x;
+    rb_n *y = z;
+    unsigned char yoc = y->c;
+    if (!z->l)
+    {
+        x = z->r;
+        rb_transplant(t, z, z->r);
+    }
+    else if (!z->r)
+    {
+        x = z->l;
+        rb_transplant(t, z, z->l);
+    }
+    else
+    {
+        y = tree_minimum(z->r);
+        yoc = y->c;
+        x = y->r;
+        if (y->p == z)
+            x->p = y;
+        else
+        {
+            rb_transplant(t, y, y->r);
+            y->r = z->r;
+            y->r->p = y;
+        }
+        rb_transplant(t, z, y);
+        y->l = z->l;
+        y->l->p = y;
+        y->c = z->c;
+    }
+    if (yoc == BLACK)
+    {
+        rb_n *w;
+        while (x != t && x->c == BLACK)
+        {
+            if (x == x->p->l)
+            {
+                w = x->p->r;
+                if (w->c == RED)
+                {
+                    w->c = BLACK;
+                    x->p->c = RED;
+                    rb_rot_esq(t, x->p);
+                    w = x->p->r;
+                }
+
+                if (w->l->c == BLACK && w->r->c == BLACK)
+                {
+                    w->c = RED;
+                    x = x->p;
+                }
+                else
+                {
+                    if (w->r->c == BLACK)
+                    {
+                        w->l->c = BLACK;
+                        w->c = RED;
+                        rb_rot_dir(t, w);
+                        w = x->p->r;
+                    }
+
+                    w->c = x->p->c;
+                    x->p->c = BLACK;
+                    w->r->c = BLACK;
+                    rb_rot_esq(t, x->p);
+                    x = t;
+                }
+                
+
+            }
+            else 
+            {
+                w = x->p->l;
+                if (w->c == RED)
+                {
+                    w->c = BLACK;
+                    x->p->c = RED;
+                    rb_rot_esq(t, x->p);
+                    w = x->p->l;
+                }
+
+                if (w->r->c == BLACK && w->l->c == BLACK)
+                {
+                    w->c = RED;
+                    x = x->p;
+                }
+                else
+                {
+                    if (w->l->c == BLACK)
+                    {
+                        w->r->c = BLACK;
+                        w->c = RED;
+                        rb_rot_dir(t, w);
+                        w = x->p->l;
+                    }
+
+                    w->c = x->p->c;
+                    x->p->c = BLACK;
+                    w->l->c = BLACK;
+                    rb_rot_esq(t, x->p);
+                    x = t;
+                }
+            }
+        }
+    }
+        
+    return 0;
+}
+
 int rb_exclui_elem(rb_n *a, int k)
 {
     return 0;
diff --git a/src/red_black.h b/src/red_black.h
index 42c905b..1a97b13 100644
--- a/src/red_black.h
+++ b/src/red_black.h
@@ -56,7 +56,13 @@ int rb_ins_elem(rb_n *a, int k, void *e);
  * @param a noh raiz da arvore
  * @param b elemento a ser inserido
  */
-int rb_insert_cormen(rb_n *t, rb_n *z);
+int rb_insert(rb_n *t, rb_n *z);
+
+/**
+ * @param a noh raiz da arvore
+ * @param b elemento a ser deletado
+ */
+int rb_delete(rb_n *t, rb_n *z);
 
 /**
  * @param a noh raiz da arvore

commit b31da3f1a05d652cd2d844713c8be12443e16c64
Author: Joilnen <joilnen@gmail.com>
Date:   Sun Dec 19 17:52:40 2021 -0300

    rb aparentemente funcionando perfeitamente pra 3 nohs testados vou
    por um tag nesse codigo como alfa

diff --git a/src/main.c b/src/main.c
index 817bc54..7782288 100644
--- a/src/main.c
+++ b/src/main.c
@@ -57,15 +57,32 @@ int main()
     strncpy(mt1.nome, "nome para teste", sizeof("nome para teste") + 1);
     mt1.telefone = (char *) malloc(sizeof("999999999") + 1);
     strncpy(mt1.telefone, "999999999", sizeof("999999999") + 1);
-    rb_ins_elem(conjunto_a, 9, &mt1);
+    // rb_ins_elem(conjunto_a, 9, &mt1);
+
+    rb_n *novo_noh = (rb_n *) malloc (sizeof(rb_n));
+    novo_noh->k = 9;
+    novo_noh->c = 1;
+    novo_noh->d = &mt1;
+    novo_noh->l = novo_noh->r = novo_noh->p = NULL;
+
+    rb_insert(conjunto_a, novo_noh);
 
     meu_tipo mt2;
     mt2.nome = (char *) malloc(sizeof("nome para teste") + 1);
     strncpy(mt2.nome, "nome para teste", sizeof("nome para teste") + 1);
     mt2.telefone = (char *) malloc(sizeof("999999999") + 1);
     strncpy(mt2.telefone, "999999999", sizeof("999999999") + 1);
-    rb_ins_elem(conjunto_a, 11, &mt2);
+    // rb_ins_elem(conjunto_a, 11, &mt2);
 
+    novo_noh = (rb_n *) malloc (sizeof(rb_n));
+    novo_noh->k = 11;
+    novo_noh->c = 1;
+    novo_noh->d = &mt2;
+    novo_noh->l = novo_noh->r = novo_noh->p = NULL;
+    rb_insert(conjunto_a, novo_noh);
+
+    rb_pr(conjunto_a);
+    rb_delete(conjunto_a, novo_noh);
     rb_pr(conjunto_a);
 
     /**
diff --git a/src/red_black.c b/src/red_black.c
index 4de5272..83a4095 100644
--- a/src/red_black.c
+++ b/src/red_black.c
@@ -147,7 +147,8 @@ static int rb_transplant(rb_n *t, rb_n *u, rb_n *v)
         u->p->l = v;
     else
         u->p->r = v;
-    v->p = u->p;
+    if(v)
+        v->p = u->p;
 }
 
 static rb_n *tree_minimum(rb_n *x)
@@ -228,8 +229,6 @@ int rb_delete(rb_n *t, rb_n *z)
                     rb_rot_esq(t, x->p);
                     x = t;
                 }
-                
-
             }
             else 
             {
@@ -265,8 +264,8 @@ int rb_delete(rb_n *t, rb_n *z)
                 }
             }
         }
-    }
-        
+    } /* if (yoc == BLACK) */
+
     return 0;
 }
 

commit 6fb5208352001b15e465d02ad352403f22897e26
Author: Joilnen <joilnen@gmail.com>
Date:   Sun Dec 19 20:28:41 2021 -0300

    tentando consertar as totacoes, a insersao parece estar colorindo mas n tah rotacionando

diff --git a/src/main.c b/src/main.c
index 7782288..808a8aa 100644
--- a/src/main.c
+++ b/src/main.c
@@ -61,7 +61,7 @@ int main()
 
     rb_n *novo_noh = (rb_n *) malloc (sizeof(rb_n));
     novo_noh->k = 9;
-    novo_noh->c = 1;
+    novo_noh->c = RED;
     novo_noh->d = &mt1;
     novo_noh->l = novo_noh->r = novo_noh->p = NULL;
 
@@ -76,13 +76,56 @@ int main()
 
     novo_noh = (rb_n *) malloc (sizeof(rb_n));
     novo_noh->k = 11;
-    novo_noh->c = 1;
+    novo_noh->c = RED;
     novo_noh->d = &mt2;
     novo_noh->l = novo_noh->r = novo_noh->p = NULL;
     rb_insert(conjunto_a, novo_noh);
 
+    meu_tipo mt3;
+    mt3.nome = (char *) malloc(sizeof("nome para teste") + 1);
+    strncpy(mt3.nome, "nome para teste", sizeof("nome para teste") + 1);
+    mt3.telefone = (char *) malloc(sizeof("999999999") + 1);
+    strncpy(mt3.telefone, "999999999", sizeof("999999999") + 1);
+    // rb_ins_elem(conjunto_a, 11, &mt2);
+
+    novo_noh = (rb_n *) malloc (sizeof(rb_n));
+    novo_noh->k = 8;
+    novo_noh->c = RED;
+    novo_noh->d = &mt3;
+    novo_noh->l = novo_noh->r = novo_noh->p = NULL;
+    rb_insert(conjunto_a, novo_noh);
+
+    meu_tipo mt4;
+    mt4.nome = (char *) malloc(sizeof("nome para teste") + 1);
+    strncpy(mt4.nome, "nome para teste", sizeof("nome para teste") + 1);
+    mt4.telefone = (char *) malloc(sizeof("999999999") + 1);
+    strncpy(mt4.telefone, "999999999", sizeof("999999999") + 1);
+    // rb_ins_elem(conjunto_a, 11, &mt2);
+
+    novo_noh = (rb_n *) malloc (sizeof(rb_n));
+    novo_noh->k = 6;
+    novo_noh->c = RED;
+    novo_noh->d = &mt4;
+    novo_noh->l = novo_noh->r = novo_noh->p = NULL;
+    rb_insert(conjunto_a, novo_noh);
+
+    meu_tipo mt5;
+    mt5.nome = (char *) malloc(sizeof("nome para teste") + 1);
+    strncpy(mt5.nome, "nome para teste", sizeof("nome para teste") + 1);
+    mt5.telefone = (char *) malloc(sizeof("999999999") + 1);
+    strncpy(mt5.telefone, "999999999", sizeof("999999999") + 1);
+    // rb_ins_elem(conjunto_a, 11, &mt2);
+
+    novo_noh = (rb_n *) malloc (sizeof(rb_n));
+    novo_noh->k = 5;
+    novo_noh->c = RED;
+    novo_noh->d = &mt5;
+    novo_noh->l = novo_noh->r = novo_noh->p = NULL;
+    rb_insert(conjunto_a, novo_noh);
+
     rb_pr(conjunto_a);
     rb_delete(conjunto_a, novo_noh);
+    printf("\n");
     rb_pr(conjunto_a);
 
     /**
diff --git a/src/red_black.c b/src/red_black.c
index 83a4095..a1dd300 100644
--- a/src/red_black.c
+++ b/src/red_black.c
@@ -7,13 +7,6 @@
 #include "red_black.h"
 #include <stdio.h>
 
-/**
- * definicao  do que eh considerado RED e BLACK
- * neste codigo para maior clareza
- */
-#define BLACK 0
-#define RED 1
-
 void (*rb_impr_elem)(rb_n *);
 
 rb_n* rb_cr(int key, void *dado)
@@ -88,15 +81,15 @@ int rb_insert(rb_n *t, rb_n *z)
     z->l = z->r = NULL;
     z->c = RED;
     /** ajuste */
-    while (z->p->c == RED)
+    while (z && z->p && z->p->c == RED)
     {
         if (z->p == z->p->p->l)
         {
             y = z->p->p->r;
-            if (y->c == RED)
+            if (y && y->c == RED)
             {
                 z->p->c = BLACK;
-                y->p->p->c = RED;
+                y->c = RED;
                 z = z->p->p;
             }
             else 
@@ -104,20 +97,20 @@ int rb_insert(rb_n *t, rb_n *z)
                 if (z == z->p->r)
                 {
                     z = z->p;
-                    rb_rot_esq(t, z);
+                    rb_rot_esq(&t, z);
                 }
                 z->p->c = BLACK;
                 z->p->p->c = RED;
-                rb_rot_dir(t, z->p->p);
+                rb_rot_dir(&t, z->p->p);
             }
         }
         else
         {
             y = z->p->p->l;
-            if (y->c == RED)
+            if (y && y->c == RED)
             {
                 z->p->c = BLACK;
-                y->p->p->c = RED;
+                y->c = RED;
                 z = z->p->p;
             }
             else 
@@ -125,11 +118,11 @@ int rb_insert(rb_n *t, rb_n *z)
                 if (z == z->p->l)
                 {
                     z = z->p;
-                    rb_rot_dir(t, z);
+                    rb_rot_dir(&t, z);
                 }
                 z->p->c = BLACK;
                 z->p->p->c = RED;
-                rb_rot_esq(t, z->p->p);
+                rb_rot_esq(&t, z->p->p);
             }
         }
     }
@@ -204,7 +197,7 @@ int rb_delete(rb_n *t, rb_n *z)
                 {
                     w->c = BLACK;
                     x->p->c = RED;
-                    rb_rot_esq(t, x->p);
+                    rb_rot_esq(&t, x->p);
                     w = x->p->r;
                 }
 
@@ -219,14 +212,14 @@ int rb_delete(rb_n *t, rb_n *z)
                     {
                         w->l->c = BLACK;
                         w->c = RED;
-                        rb_rot_dir(t, w);
+                        rb_rot_dir(&t, w);
                         w = x->p->r;
                     }
 
                     w->c = x->p->c;
                     x->p->c = BLACK;
                     w->r->c = BLACK;
-                    rb_rot_esq(t, x->p);
+                    rb_rot_esq(&t, x->p);
                     x = t;
                 }
             }
@@ -237,7 +230,7 @@ int rb_delete(rb_n *t, rb_n *z)
                 {
                     w->c = BLACK;
                     x->p->c = RED;
-                    rb_rot_esq(t, x->p);
+                    rb_rot_esq(&t, x->p);
                     w = x->p->l;
                 }
 
@@ -252,14 +245,14 @@ int rb_delete(rb_n *t, rb_n *z)
                     {
                         w->r->c = BLACK;
                         w->c = RED;
-                        rb_rot_dir(t, w);
+                        rb_rot_dir(&t, w);
                         w = x->p->l;
                     }
 
                     w->c = x->p->c;
                     x->p->c = BLACK;
                     w->l->c = BLACK;
-                    rb_rot_esq(t, x->p);
+                    rb_rot_esq(&t, x->p);
                     x = t;
                 }
             }
@@ -294,7 +287,7 @@ int rb_destroi(rb_n **a)
     return 0;
 }
 
-int rb_rot_esq(rb_n *r, rb_n *w)
+int rb_rot_esq(rb_n **t, rb_n *w)
 {
     rb_n *v = w->r;
     w->r = v->l;
@@ -302,7 +295,7 @@ int rb_rot_esq(rb_n *r, rb_n *w)
         v->l->p = w;
     v->p = w->p;
     if (!w->p)
-        r = v;
+        *t = v;
     else if (w == w->p->l)
         w->p->l = v;
     else
@@ -313,7 +306,7 @@ int rb_rot_esq(rb_n *r, rb_n *w)
     return 0;
 }
 
-int rb_rot_dir(rb_n *r, rb_n *w)
+int rb_rot_dir(rb_n **t, rb_n *w)
 {
     rb_n *v = w->l;
     w->l = v->r;
@@ -321,7 +314,7 @@ int rb_rot_dir(rb_n *r, rb_n *w)
         v->r->p = w;
     v->p = w->p;
     if (!w->p)
-        r = v;
+        *t = v;
     else if (w == w->p->r)
         w->p->r = v;
     else
diff --git a/src/red_black.h b/src/red_black.h
index 1a97b13..f874138 100644
--- a/src/red_black.h
+++ b/src/red_black.h
@@ -6,6 +6,13 @@
  */
 #include <stdlib.h>
 
+/**
+ * definicao  do que eh considerado RED e BLACK
+ * neste codigo para maior clareza
+ */
+#define BLACK 0
+#define RED 1
+
 /*
  * rubro negra
  * 0 - todo noh eh vermelho ou preto
@@ -116,13 +123,13 @@ int rb_troca_cor(rb_n *a);
 /**
  * rotaciona subarvore a esquerda apartir do noh @param a
  */
-int rb_rot_esq(rb_n *r, rb_n *w);
+int rb_rot_esq(rb_n **t, rb_n *w);
 
 /**
  * rotaciona subarvore a direita apartir do noh
  * @param a noh 
  */
-int rb_rot_dir(rb_n *r, rb_n *w);
+int rb_rot_dir(rb_n **t, rb_n *w);
 
 /**
  * imprime elemento como definido pelo o codigo cliente da biblioteca

commit 314a4c50f8bda0bb4d97c44353ccc5423abf95fb
Author: Joilnen <joilnen@gmail.com>
Date:   Mon Dec 20 07:17:50 2021 -0300

    esmiucando a insersao e as rotacoes pra ver onde tah o erro

diff --git a/src/red_black.c b/src/red_black.c
index a1dd300..f3a2e2a 100644
--- a/src/red_black.c
+++ b/src/red_black.c
@@ -62,16 +62,39 @@ int rb_ins_elem(rb_n *a, int k, void *e)
  */
 int rb_insert(rb_n *t, rb_n *z)
 {
+    /**
+     * y receberah noh pai imediato do noh adicionado
+     * x eh um ponteiro temporario para iteracao feita 
+     * no loop while a seguir para chegar ao noh folha
+     */
     rb_n *y = NULL;
     rb_n *x = t;
+
+    /**
+     * itera para chegar no noh folha
+     * da posicao a ser inserido o novo noh
+     */
     while (x)
     {
         y = x;
         if (z->k < x->k)
             x = x->l;
-        else x = x->r;
+        else
+            x = x->r;
     }
+
+    /**
+     * seta noh pai para o noh adicionado
+     */
     z->p = y;
+
+    /**
+     * se esse noh adicionado eh unico y permance
+     * nulo que neste caso apontaria para o pai que eh nulo
+     * neste cenario torna o noh adicionado raiz
+     * caso n adiciona na esquera ou diretia de acordo
+     * com o valor da chave, noh recebe RED como padrao
+     */
     if (!y)
         t = z;
     else if (z->k < y->k)
@@ -80,6 +103,7 @@ int rb_insert(rb_n *t, rb_n *z)
         y->r = z;
     z->l = z->r = NULL;
     z->c = RED;
+
     /** ajuste */
     while (z && z->p && z->p->c == RED)
     {
@@ -130,7 +154,7 @@ int rb_insert(rb_n *t, rb_n *z)
 }
 
 /**
- * fucnao que faz trocas auxiliares na delecao
+ * funcao que faz trocas auxiliares na delecao
  */
 static int rb_transplant(rb_n *t, rb_n *u, rb_n *v)
 {
@@ -147,8 +171,8 @@ static int rb_transplant(rb_n *t, rb_n *u, rb_n *v)
 static rb_n *tree_minimum(rb_n *x)
 {
     rb_n *a = x;
-    while (a->r)
-        a = a->r;
+    while (a->l)
+        a = a->l;
     return a;
 }
 
@@ -157,6 +181,7 @@ int rb_delete(rb_n *t, rb_n *z)
     rb_n *x;
     rb_n *y = z;
     unsigned char yoc = y->c;
+
     if (!z->l)
     {
         x = z->r;
@@ -287,40 +312,40 @@ int rb_destroi(rb_n **a)
     return 0;
 }
 
-int rb_rot_esq(rb_n **t, rb_n *w)
+int rb_rot_esq(rb_n **t, rb_n *x)
 {
-    rb_n *v = w->r;
-    w->r = v->l;
-    if (v->l)
-        v->l->p = w;
-    v->p = w->p;
-    if (!w->p)
-        *t = v;
-    else if (w == w->p->l)
-        w->p->l = v;
+    rb_n *y = x->r;
+    x->r = y->l;
+    if (y->l)
+        y->l->p = x;
+    y->p = x->p;
+    if (!x->p)
+        *t = y;
+    else if (x == x->p->l)
+        x->p->l = y;
     else
-        w->p->r = v;
-    v->l = w;
-    w->p = v;
+        x->p->r = y;
+    y->l = x;
+    x->p = y;
 
     return 0;
 }
 
-int rb_rot_dir(rb_n **t, rb_n *w)
+int rb_rot_dir(rb_n **t, rb_n *x)
 {
-    rb_n *v = w->l;
-    w->l = v->r;
-    if (v->r)
-        v->r->p = w;
-    v->p = w->p;
-    if (!w->p)
-        *t = v;
-    else if (w == w->p->r)
-        w->p->r = v;
+    rb_n *y = x->l;
+    x->l = y->r;
+    if (y->r)
+        y->r->p = x;
+    y->p = x->p;
+    if (!x->p)
+        *t = y;
+    else if (x == x->p->r)
+        x->p->r = y;
     else
-        w->p->l = v;
-    v->r = w;
-    w->p = v;
+        x->p->l = y;
+    y->r = x;
+    x->p = y;
 
     return 0;
 }
@@ -334,7 +359,10 @@ void rb_pr(rb_n *a)
 {
     if (a)
     {
-        printf("k:%dc:%d\n", a->k, a->c);
+        if(a->c == BLACK)
+            printf("\033[44m\033[37mk:%dc:%d\033[0m\n", a->k, a->c);
+        else
+            printf("\033[41m\033[37mk:%dc:%d\033[0m\n", a->k, a->c);
         rb_pr(a->l);
         rb_pr(a->r);
     }
diff --git a/src/red_black.h b/src/red_black.h
index f874138..404346b 100644
--- a/src/red_black.h
+++ b/src/red_black.h
@@ -123,13 +123,13 @@ int rb_troca_cor(rb_n *a);
 /**
  * rotaciona subarvore a esquerda apartir do noh @param a
  */
-int rb_rot_esq(rb_n **t, rb_n *w);
+int rb_rot_esq(rb_n **t, rb_n *x);
 
 /**
  * rotaciona subarvore a direita apartir do noh
  * @param a noh 
  */
-int rb_rot_dir(rb_n **t, rb_n *w);
+int rb_rot_dir(rb_n **t, rb_n *x);
 
 /**
  * imprime elemento como definido pelo o codigo cliente da biblioteca

commit 672008b3e8ddc58842129fdc4572efadd7358295
Author: Joilnen <joilnen@gmail.com>
Date:   Mon Dec 20 11:39:40 2021 -0300

    consertando rotacoes

diff --git a/src/main.c b/src/main.c
index 808a8aa..4edea18 100644
--- a/src/main.c
+++ b/src/main.c
@@ -61,9 +61,7 @@ int main()
 
     rb_n *novo_noh = (rb_n *) malloc (sizeof(rb_n));
     novo_noh->k = 9;
-    novo_noh->c = RED;
     novo_noh->d = &mt1;
-    novo_noh->l = novo_noh->r = novo_noh->p = NULL;
 
     rb_insert(conjunto_a, novo_noh);
 
@@ -76,9 +74,7 @@ int main()
 
     novo_noh = (rb_n *) malloc (sizeof(rb_n));
     novo_noh->k = 11;
-    novo_noh->c = RED;
     novo_noh->d = &mt2;
-    novo_noh->l = novo_noh->r = novo_noh->p = NULL;
     rb_insert(conjunto_a, novo_noh);
 
     meu_tipo mt3;
@@ -90,9 +86,7 @@ int main()
 
     novo_noh = (rb_n *) malloc (sizeof(rb_n));
     novo_noh->k = 8;
-    novo_noh->c = RED;
     novo_noh->d = &mt3;
-    novo_noh->l = novo_noh->r = novo_noh->p = NULL;
     rb_insert(conjunto_a, novo_noh);
 
     meu_tipo mt4;
@@ -104,9 +98,7 @@ int main()
 
     novo_noh = (rb_n *) malloc (sizeof(rb_n));
     novo_noh->k = 6;
-    novo_noh->c = RED;
     novo_noh->d = &mt4;
-    novo_noh->l = novo_noh->r = novo_noh->p = NULL;
     rb_insert(conjunto_a, novo_noh);
 
     meu_tipo mt5;
@@ -118,9 +110,7 @@ int main()
 
     novo_noh = (rb_n *) malloc (sizeof(rb_n));
     novo_noh->k = 5;
-    novo_noh->c = RED;
     novo_noh->d = &mt5;
-    novo_noh->l = novo_noh->r = novo_noh->p = NULL;
     rb_insert(conjunto_a, novo_noh);
 
     rb_pr(conjunto_a);
diff --git a/src/red_black.c b/src/red_black.c
index f3a2e2a..8f155e0 100644
--- a/src/red_black.c
+++ b/src/red_black.c
@@ -113,7 +113,8 @@ int rb_insert(rb_n *t, rb_n *z)
             if (y && y->c == RED)
             {
                 z->p->c = BLACK;
-                y->c = RED;
+                y->c = BLACK;
+                z->p->p->c = RED;
                 z = z->p->p;
             }
             else 
@@ -134,7 +135,8 @@ int rb_insert(rb_n *t, rb_n *z)
             if (y && y->c == RED)
             {
                 z->p->c = BLACK;
-                y->c = RED;
+                y->c = BLACK;
+                z->p->p->c = RED;
                 z = z->p->p;
             }
             else 

commit e201eca5b7f67035f56a61791abcccee40f5c3cc
Author: Joilnen <joilnen@gmail.com>
Date:   Mon Dec 20 15:25:24 2021 -0300

    foi consertado um ponteiro para funcao de insersao pra ser por referencia
    pra possibilitar sua alteracao dentro da funcao e adiconado
    exemplos que forcassem a rotacao da raiz, o corre com 7 nohs
    adicionados

diff --git a/src/main.c b/src/main.c
index 4edea18..8d92b95 100644
--- a/src/main.c
+++ b/src/main.c
@@ -57,61 +57,78 @@ int main()
     strncpy(mt1.nome, "nome para teste", sizeof("nome para teste") + 1);
     mt1.telefone = (char *) malloc(sizeof("999999999") + 1);
     strncpy(mt1.telefone, "999999999", sizeof("999999999") + 1);
-    // rb_ins_elem(conjunto_a, 9, &mt1);
 
     rb_n *novo_noh = (rb_n *) malloc (sizeof(rb_n));
     novo_noh->k = 9;
     novo_noh->d = &mt1;
 
-    rb_insert(conjunto_a, novo_noh);
+    rb_insert(&conjunto_a, novo_noh);
 
     meu_tipo mt2;
     mt2.nome = (char *) malloc(sizeof("nome para teste") + 1);
     strncpy(mt2.nome, "nome para teste", sizeof("nome para teste") + 1);
     mt2.telefone = (char *) malloc(sizeof("999999999") + 1);
     strncpy(mt2.telefone, "999999999", sizeof("999999999") + 1);
-    // rb_ins_elem(conjunto_a, 11, &mt2);
 
     novo_noh = (rb_n *) malloc (sizeof(rb_n));
     novo_noh->k = 11;
     novo_noh->d = &mt2;
-    rb_insert(conjunto_a, novo_noh);
+    rb_insert(&conjunto_a, novo_noh);
 
     meu_tipo mt3;
     mt3.nome = (char *) malloc(sizeof("nome para teste") + 1);
     strncpy(mt3.nome, "nome para teste", sizeof("nome para teste") + 1);
     mt3.telefone = (char *) malloc(sizeof("999999999") + 1);
     strncpy(mt3.telefone, "999999999", sizeof("999999999") + 1);
-    // rb_ins_elem(conjunto_a, 11, &mt2);
 
     novo_noh = (rb_n *) malloc (sizeof(rb_n));
     novo_noh->k = 8;
     novo_noh->d = &mt3;
-    rb_insert(conjunto_a, novo_noh);
+    rb_insert(&conjunto_a, novo_noh);
 
     meu_tipo mt4;
     mt4.nome = (char *) malloc(sizeof("nome para teste") + 1);
     strncpy(mt4.nome, "nome para teste", sizeof("nome para teste") + 1);
     mt4.telefone = (char *) malloc(sizeof("999999999") + 1);
     strncpy(mt4.telefone, "999999999", sizeof("999999999") + 1);
-    // rb_ins_elem(conjunto_a, 11, &mt2);
 
     novo_noh = (rb_n *) malloc (sizeof(rb_n));
     novo_noh->k = 6;
     novo_noh->d = &mt4;
-    rb_insert(conjunto_a, novo_noh);
+    rb_insert(&conjunto_a, novo_noh);
 
     meu_tipo mt5;
     mt5.nome = (char *) malloc(sizeof("nome para teste") + 1);
     strncpy(mt5.nome, "nome para teste", sizeof("nome para teste") + 1);
     mt5.telefone = (char *) malloc(sizeof("999999999") + 1);
     strncpy(mt5.telefone, "999999999", sizeof("999999999") + 1);
-    // rb_ins_elem(conjunto_a, 11, &mt2);
 
     novo_noh = (rb_n *) malloc (sizeof(rb_n));
     novo_noh->k = 5;
     novo_noh->d = &mt5;
-    rb_insert(conjunto_a, novo_noh);
+    rb_insert(&conjunto_a, novo_noh);
+
+    meu_tipo mt6;
+    mt6.nome = (char *) malloc(sizeof("nome para teste") + 1);
+    strncpy(mt6.nome, "nome para teste", sizeof("nome para teste") + 1);
+    mt6.telefone = (char *) malloc(sizeof("999999999") + 1);
+    strncpy(mt6.telefone, "999999999", sizeof("999999999") + 1);
+
+    novo_noh = (rb_n *) malloc (sizeof(rb_n));
+    novo_noh->k = 4;
+    novo_noh->d = &mt6;
+    rb_insert(&conjunto_a, novo_noh);
+
+    meu_tipo mt7;
+    mt7.nome = (char *) malloc(sizeof("nome para teste") + 1);
+    strncpy(mt7.nome, "nome para teste", sizeof("nome para teste") + 1);
+    mt7.telefone = (char *) malloc(sizeof("999999999") + 1);
+    strncpy(mt7.telefone, "999999999", sizeof("999999999") + 1);
+
+    novo_noh = (rb_n *) malloc (sizeof(rb_n));
+    novo_noh->k = 3;
+    novo_noh->d = &mt7;
+    rb_insert(&conjunto_a, novo_noh);
 
     rb_pr(conjunto_a);
     rb_delete(conjunto_a, novo_noh);
diff --git a/src/red_black.c b/src/red_black.c
index 8f155e0..0cdcd3a 100644
--- a/src/red_black.c
+++ b/src/red_black.c
@@ -60,7 +60,7 @@ int rb_ins_elem(rb_n *a, int k, void *e)
 /**
  * inclusao baseado no livro do cormen
  */
-int rb_insert(rb_n *t, rb_n *z)
+int rb_insert(rb_n **t, rb_n *z)
 {
     /**
      * y receberah noh pai imediato do noh adicionado
@@ -68,7 +68,7 @@ int rb_insert(rb_n *t, rb_n *z)
      * no loop while a seguir para chegar ao noh folha
      */
     rb_n *y = NULL;
-    rb_n *x = t;
+    rb_n *x = *t;
 
     /**
      * itera para chegar no noh folha
@@ -122,11 +122,11 @@ int rb_insert(rb_n *t, rb_n *z)
                 if (z == z->p->r)
                 {
                     z = z->p;
-                    rb_rot_esq(&t, z);
+                    rb_rot_esq(t, z);
                 }
                 z->p->c = BLACK;
                 z->p->p->c = RED;
-                rb_rot_dir(&t, z->p->p);
+                rb_rot_dir(t, z->p->p);
             }
         }
         else
@@ -144,15 +144,15 @@ int rb_insert(rb_n *t, rb_n *z)
                 if (z == z->p->l)
                 {
                     z = z->p;
-                    rb_rot_dir(&t, z);
+                    rb_rot_dir(t, z);
                 }
                 z->p->c = BLACK;
                 z->p->p->c = RED;
-                rb_rot_esq(&t, z->p->p);
+                rb_rot_esq(t, z->p->p);
             }
         }
     }
-    t->c = BLACK;
+    (*t)->c = BLACK;
 }
 
 /**
diff --git a/src/red_black.h b/src/red_black.h
index 404346b..efe1615 100644
--- a/src/red_black.h
+++ b/src/red_black.h
@@ -63,7 +63,7 @@ int rb_ins_elem(rb_n *a, int k, void *e);
  * @param a noh raiz da arvore
  * @param b elemento a ser inserido
  */
-int rb_insert(rb_n *t, rb_n *z);
+int rb_insert(rb_n **t, rb_n *z);
 
 /**
  * @param a noh raiz da arvore

commit 0ad91c93a5ba9c26e870931e600ae5be11d76c26
Author: Joilnen <joilnen@gmail.com>
Date:   Mon Dec 20 15:46:33 2021 -0300

    delecao com problema caso em q o noh deleteado eh o raiz, isso quebra

diff --git a/src/main.c b/src/main.c
index 8d92b95..07a1566 100644
--- a/src/main.c
+++ b/src/main.c
@@ -131,7 +131,7 @@ int main()
     rb_insert(&conjunto_a, novo_noh);
 
     rb_pr(conjunto_a);
-    rb_delete(conjunto_a, novo_noh);
+    rb_delete(&conjunto_a, novo_noh);
     printf("\n");
     rb_pr(conjunto_a);
 
diff --git a/src/red_black.c b/src/red_black.c
index 0cdcd3a..01349fe 100644
--- a/src/red_black.c
+++ b/src/red_black.c
@@ -96,7 +96,7 @@ int rb_insert(rb_n **t, rb_n *z)
      * com o valor da chave, noh recebe RED como padrao
      */
     if (!y)
-        t = z;
+        *t = z;
     else if (z->k < y->k)
         y->l = z;
     else
@@ -158,10 +158,10 @@ int rb_insert(rb_n **t, rb_n *z)
 /**
  * funcao que faz trocas auxiliares na delecao
  */
-static int rb_transplant(rb_n *t, rb_n *u, rb_n *v)
+static int rb_transplant(rb_n **t, rb_n *u, rb_n *v)
 {
     if (!u->p)
-        t = v;
+        *t = v;
     else if (u == u->p->l)
         u->p->l = v;
     else
@@ -178,7 +178,7 @@ static rb_n *tree_minimum(rb_n *x)
     return a;
 }
 
-int rb_delete(rb_n *t, rb_n *z)
+int rb_delete(rb_n **t, rb_n *z)
 {
     rb_n *x;
     rb_n *y = z;
@@ -215,7 +215,7 @@ int rb_delete(rb_n *t, rb_n *z)
     if (yoc == BLACK)
     {
         rb_n *w;
-        while (x != t && x->c == BLACK)
+        while (x != *t && x->c == BLACK)
         {
             if (x == x->p->l)
             {
@@ -224,7 +224,7 @@ int rb_delete(rb_n *t, rb_n *z)
                 {
                     w->c = BLACK;
                     x->p->c = RED;
-                    rb_rot_esq(&t, x->p);
+                    rb_rot_esq(t, x->p);
                     w = x->p->r;
                 }
 
@@ -239,15 +239,15 @@ int rb_delete(rb_n *t, rb_n *z)
                     {
                         w->l->c = BLACK;
                         w->c = RED;
-                        rb_rot_dir(&t, w);
+                        rb_rot_dir(t, w);
                         w = x->p->r;
                     }
 
                     w->c = x->p->c;
                     x->p->c = BLACK;
                     w->r->c = BLACK;
-                    rb_rot_esq(&t, x->p);
-                    x = t;
+                    rb_rot_esq(t, x->p);
+                    x = *t;
                 }
             }
             else 
@@ -257,7 +257,7 @@ int rb_delete(rb_n *t, rb_n *z)
                 {
                     w->c = BLACK;
                     x->p->c = RED;
-                    rb_rot_esq(&t, x->p);
+                    rb_rot_esq(t, x->p);
                     w = x->p->l;
                 }
 
@@ -272,15 +272,15 @@ int rb_delete(rb_n *t, rb_n *z)
                     {
                         w->r->c = BLACK;
                         w->c = RED;
-                        rb_rot_dir(&t, w);
+                        rb_rot_dir(t, w);
                         w = x->p->l;
                     }
 
                     w->c = x->p->c;
                     x->p->c = BLACK;
                     w->l->c = BLACK;
-                    rb_rot_esq(&t, x->p);
-                    x = t;
+                    rb_rot_esq(t, x->p);
+                    x = *t;
                 }
             }
         }
diff --git a/src/red_black.h b/src/red_black.h
index efe1615..80f39db 100644
--- a/src/red_black.h
+++ b/src/red_black.h
@@ -69,7 +69,7 @@ int rb_insert(rb_n **t, rb_n *z);
  * @param a noh raiz da arvore
  * @param b elemento a ser deletado
  */
-int rb_delete(rb_n *t, rb_n *z);
+int rb_delete(rb_n **t, rb_n *z);
 
 /**
  * @param a noh raiz da arvore

commit 587184fd58bd2a3919801b5ddfb9d8f6b5f72af0
Author: Joilnen <joilnen@gmail.com>
Date:   Mon Dec 20 18:35:17 2021 -0300

    delete cheio de problemas por enquato soh insersao funciona bem

diff --git a/src/main.c b/src/main.c
index 07a1566..c278464 100644
--- a/src/main.c
+++ b/src/main.c
@@ -131,7 +131,11 @@ int main()
     rb_insert(&conjunto_a, novo_noh);
 
     rb_pr(conjunto_a);
-    rb_delete(&conjunto_a, novo_noh);
+    // rb_delete(&conjunto_a, tt);
+    rb_delete(&conjunto_a, rb_search(conjunto_a, 3));
+    printf("\n");
+    rb_pr(conjunto_a);
+    rb_delete(&conjunto_a, rb_search(conjunto_a, 11));
     printf("\n");
     rb_pr(conjunto_a);
 
diff --git a/src/red_black.c b/src/red_black.c
index 01349fe..9a1395a 100644
--- a/src/red_black.c
+++ b/src/red_black.c
@@ -371,3 +371,21 @@ void rb_pr(rb_n *a)
 }
 
 
+rb_n *rb_search(rb_n *t, int k)
+{
+    rb_n *y = NULL;
+    rb_n *x = t;
+
+    while (x)
+    {
+        y = x;
+        if (k < x->k)
+            x = x->l;
+        else if (k > x->k)
+            x = x->r;
+        else
+            return x;
+    }
+
+    return  NULL;
+}
diff --git a/src/red_black.h b/src/red_black.h
index 80f39db..2f93388 100644
--- a/src/red_black.h
+++ b/src/red_black.h
@@ -60,12 +60,21 @@ unsigned int rb_nelem(rb_n *a);
 int rb_ins_elem(rb_n *a, int k, void *e);
 
 /**
+ * tc
  * @param a noh raiz da arvore
  * @param b elemento a ser inserido
  */
 int rb_insert(rb_n **t, rb_n *z);
 
 /**
+ * tch
+ * @param a noh raiz da arvore
+ * @param b elemento a ser inserido
+ */
+rb_n *rb_search(rb_n *t, int k);
+
+/**
+ * tc
  * @param a noh raiz da arvore
  * @param b elemento a ser deletado
  */

commit 9d8058765125f656a322aa28591432e204025a57
Author: Joilnen <joilnen@gmail.com>
Date:   Mon Dec 20 21:03:54 2021 -0300

    consertado o delete era chegar validade de um ponteiro

diff --git a/src/main.c b/src/main.c
index c278464..17a7261 100644
--- a/src/main.c
+++ b/src/main.c
@@ -138,6 +138,12 @@ int main()
     rb_delete(&conjunto_a, rb_search(conjunto_a, 11));
     printf("\n");
     rb_pr(conjunto_a);
+    rb_delete(&conjunto_a, rb_search(conjunto_a, 4));
+    printf("\n");
+    rb_pr(conjunto_a);
+    rb_delete(&conjunto_a, rb_search(conjunto_a, 8));
+    printf("\n");
+    rb_pr(conjunto_a);
 
     /**
      * testando apenas rb no momento
diff --git a/src/red_black.c b/src/red_black.c
index 9a1395a..62f968b 100644
--- a/src/red_black.c
+++ b/src/red_black.c
@@ -215,7 +215,7 @@ int rb_delete(rb_n **t, rb_n *z)
     if (yoc == BLACK)
     {
         rb_n *w;
-        while (x != *t && x->c == BLACK)
+        while (x && x != *t && x->c == BLACK)
         {
             if (x == x->p->l)
             {

commit 79ff5bb796251b0ee9ce70d5cf0e55cbb23b7d04
Author: Joilnen <joilnen@gmail.com>
Date:   Mon Dec 20 21:12:56 2021 -0300

    checagem se passa NULL como noh para ser deletado, tava quebrando

diff --git a/src/main.c b/src/main.c
index 17a7261..7217926 100644
--- a/src/main.c
+++ b/src/main.c
@@ -144,7 +144,7 @@ int main()
     rb_delete(&conjunto_a, rb_search(conjunto_a, 8));
     printf("\n");
     rb_pr(conjunto_a);
-
+    rb_delete(&conjunto_a, NULL);
     /**
      * testando apenas rb no momento
     conjord *conj_a = conjord_cria();
diff --git a/src/red_black.c b/src/red_black.c
index 62f968b..e8325b2 100644
--- a/src/red_black.c
+++ b/src/red_black.c
@@ -182,7 +182,11 @@ int rb_delete(rb_n **t, rb_n *z)
 {
     rb_n *x;
     rb_n *y = z;
-    unsigned char yoc = y->c;
+    unsigned char yoc;
+
+    if (!z)
+        return -1;
+    yoc = y->c;
 
     if (!z->l)
     {

commit a2dedb7770c26d9d9ad06336a7ae9f03ac169af3
Author: Joilnen <joilnen@gmail.com>
Date:   Mon Dec 20 21:44:44 2021 -0300

    consertando mais um ponteiro invalido dentro do delete

diff --git a/src/main.c b/src/main.c
index 7217926..876383a 100644
--- a/src/main.c
+++ b/src/main.c
@@ -144,7 +144,16 @@ int main()
     rb_delete(&conjunto_a, rb_search(conjunto_a, 8));
     printf("\n");
     rb_pr(conjunto_a);
-    rb_delete(&conjunto_a, NULL);
+    rb_delete(&conjunto_a, rb_search(conjunto_a, 9));
+    printf("\n");
+    rb_pr(conjunto_a);
+    rb_delete(&conjunto_a, rb_search(conjunto_a, 5));
+    printf("\n");
+    rb_pr(conjunto_a);
+    rb_delete(&conjunto_a, rb_search(conjunto_a, 6));
+    printf("\n nada");
+    rb_pr(conjunto_a);
+    printf("\n");
     /**
      * testando apenas rb no momento
     conjord *conj_a = conjord_cria();
diff --git a/src/red_black.c b/src/red_black.c
index e8325b2..f32dbe7 100644
--- a/src/red_black.c
+++ b/src/red_black.c
@@ -204,7 +204,7 @@ int rb_delete(rb_n **t, rb_n *z)
         yoc = y->c;
         x = y->r;
         if (y->p == z)
-            x->p = y;
+            if(x) x->p = y;
         else
         {
             rb_transplant(t, y, y->r);

commit 80b0701d8f57960614ebb8df46ac71282e93669c
Author: Joilnen <joilnen@gmail.com>
Date:   Mon Dec 20 21:50:58 2021 -0300

    aparentemente o delete da arvore vermelha e preta esta deletando todos
    os casos inclusive todos os nohs sem crashs

diff --git a/src/main.c b/src/main.c
index 876383a..efbadf8 100644
--- a/src/main.c
+++ b/src/main.c
@@ -131,7 +131,6 @@ int main()
     rb_insert(&conjunto_a, novo_noh);
 
     rb_pr(conjunto_a);
-    // rb_delete(&conjunto_a, tt);
     rb_delete(&conjunto_a, rb_search(conjunto_a, 3));
     printf("\n");
     rb_pr(conjunto_a);
@@ -161,34 +160,6 @@ int main()
     */
 }
 
-int imprime_arvore(rb_n *a, short h)
-{
-    rb_n *it = a;
-    int count = h;
-    if(it) 
-    {
-        for(; count; --count) printf(" ");
-        printf("%d%d", it->k, it->c);
-        if(it->l)
-        {
-            for(count = h - 2; h; --h) printf(" ");
-            printf("%d%d", it->l->k, it->l->c);
-
-        }
-        if(it->r)
-        {
-            for(count = h + 2; h; --h) printf(" ");
-            printf("%d%d", it->r->k, it->r->c);
-
-        }
-        printf("\n");
-        imprime_arvore(it->r->r, h - 1);
-        imprime_arvore(it->r->l, h - 1);
-        imprime_arvore(it->l->r, h - 1);
-        imprime_arvore(it->l->l, h - 1);
-    }
-}
-
 /**
  * definicao da funcao de impressao estipulado pelo cliente, aqui apenas um
  * exemplo

commit f9036f3c01bfdab050acf00fb6944b4d23917b6f
Author: Joilnen <joilnen@gmail.com>
Date:   Tue Dec 21 15:00:32 2021 -0300

    troquei minimum por sucessor aparentemente nao faz diferenca
    se a pesquisa for sempre feita pela a raiz

diff --git a/src/red_black.c b/src/red_black.c
index f32dbe7..508282e 100644
--- a/src/red_black.c
+++ b/src/red_black.c
@@ -178,6 +178,20 @@ static rb_n *tree_minimum(rb_n *x)
     return a;
 }
 
+static rb_n* sucessor(rb_n *x)
+{
+    rb_n *y = NULL;
+    if (x->r)
+      return tree_minimum(x->r);
+    y = x->p;
+    while (y && x == y->r)
+    {
+      x = y;
+      y = y->p;
+    }
+    return y;
+}
+
 int rb_delete(rb_n **t, rb_n *z)
 {
     rb_n *x;
@@ -200,7 +214,8 @@ int rb_delete(rb_n **t, rb_n *z)
     }
     else
     {
-        y = tree_minimum(z->r);
+        // y = tree_minimum(z->r);
+        y = sucessor(z);
         yoc = y->c;
         x = y->r;
         if (y->p == z)
@@ -216,6 +231,7 @@ int rb_delete(rb_n **t, rb_n *z)
         y->l->p = y;
         y->c = z->c;
     }
+
     if (yoc == BLACK)
     {
         rb_n *w;

commit 4d24ed67efd370457da02dd43d353d6e8959f8d8
Author: Joilnen <joilnen@gmail.com>
Date:   Tue Dec 21 19:02:03 2021 -0300

    consertando a indentcao da funcao sucessor

diff --git a/src/red_black.c b/src/red_black.c
index 508282e..b2e3e26 100644
--- a/src/red_black.c
+++ b/src/red_black.c
@@ -182,12 +182,12 @@ static rb_n* sucessor(rb_n *x)
 {
     rb_n *y = NULL;
     if (x->r)
-      return tree_minimum(x->r);
+        return tree_minimum(x->r);
     y = x->p;
     while (y && x == y->r)
     {
-      x = y;
-      y = y->p;
+        x = y;
+        y = y->p;
     }
     return y;
 }

commit a21a35ac39cfed6c3d1b65e7ff57c7f421e9c095
Author: Joilnen <joilnen@gmail.com>
Date:   Tue Dec 21 19:35:49 2021 -0300

    melhorando comentario

diff --git a/src/red_black.c b/src/red_black.c
index b2e3e26..3a41fbf 100644
--- a/src/red_black.c
+++ b/src/red_black.c
@@ -157,6 +157,8 @@ int rb_insert(rb_n **t, rb_n *z)
 
 /**
  * funcao que faz trocas auxiliares na delecao
+ * @param u noh que eh trocado por outro em seu lugar
+ * @param v noh que eh colocado no lugar do noh anterior
  */
 static int rb_transplant(rb_n **t, rb_n *u, rb_n *v)
 {

commit a195b68a2e66f953315fa07042b09e1396294ed6
Author: Joilnen <joilnen@gmail.com>
Date:   Wed Dec 22 07:00:24 2021 -0300

    atualizando interfaces

diff --git a/src/conjunto_ordenado.c b/src/conjunto_ordenado.c
index 8e3abe4..81d2e70 100644
--- a/src/conjunto_ordenado.c
+++ b/src/conjunto_ordenado.c
@@ -18,3 +18,5 @@ int conjord_esvazia(conjord *a)
 {
 
 }
+
+

commit c891837cbe985fdb319ed2dcbbf203c05c4d9557
Author: Joilnen <joilnen@gmail.com>
Date:   Wed Dec 22 12:41:31 2021 -0300

    escrevendo TAD conjunto ordenado conjord

diff --git a/src/conjunto_ordenado.c b/src/conjunto_ordenado.c
index 81d2e70..14f03ab 100644
--- a/src/conjunto_ordenado.c
+++ b/src/conjunto_ordenado.c
@@ -1,5 +1,8 @@
 #include "conjunto_ordenado.h"
 
+/**
+ * cria conjunto ordenado e retorna o ponteiro para ele
+ */
 conjord *conjord_cria()
 {
     conjord *c = (conjord *) malloc (sizeof(conjord));
@@ -9,7 +12,19 @@ conjord *conjord_cria()
     return c;
 }
 
-int conjord_eh_vazio(conjord *a)
+/**
+ * imprime elementos do conjunto subitem 1 do item 2
+ * "imprimir os elementos de um conjunto, em ordem crescente das chaves"
+ */
+void conjord_imprime()
+{
+
+}
+
+/**
+ * testa se o conjunto estah vazio
+ */
+int conjord_eh_vazio(const conjord *a)
 {
     return !a->raiz;
 }
diff --git a/src/conjunto_ordenado.h b/src/conjunto_ordenado.h
index d8ac556..aa94a83 100644
--- a/src/conjunto_ordenado.h
+++ b/src/conjunto_ordenado.h
@@ -7,27 +7,91 @@
  * estrutura da TAD explicitamente
  * esta estrutura oculta o uso da red black
  * suas funcoes e funcionamento interno do cliente
+ * expondo apenas funcoes e operacoes com semantica
+ * relativa ao uso do cliente aqui nesta avaliacao
+ * conjunto ordenado as operacpes e funcoes
+ * exigidas no documento da avaliacao para este TAD
  */
 typedef struct conjord {
     rb_n *raiz;
     int cardinalidade;
 } conjord;
 
+/**
+ * cria conjunto ordenado e retorna o ponteiro para ele
+ */
 conjord *conjord_cria();
+
+/**
+ * imprime elementos do conjunto subitem 1 do item 2
+ * "imprimir os elementos de um conjunto, em ordem crescente das chaves"
+ */
 void conjord_imprime();
+
+/**
+ * retorna a cardinalidade do conjunto
+ */
 unsigned int conjord_cardinalidade();
-int conjord_eh_vazio();
+
+/**
+ * testa se o conjunto estah vazio
+ */
+int conjord_eh_vazio(const conjord *a);
+
+/**
+ * torna o conjunto vazio
+ */
 int conjord_esvazia();
+
+/**
+ * destroi e desaloca uma instancia de conjunto ordenado
+ */
 void conjord_destroi(conjord **a);
 
+/**
+ * insere elemento no conjunto ordenado
+ */
 void conjord_insere_elemento(conjord *a, int chave, void *elemento);
+
+/**
+ * exclui elemento do conjunto ordenado através da chave
+ * é o idenficador de acordo com especificacao
+ */
 void conjord_exclui_elemento(conjord *a, int chave);
+
+/**
+ * testa se existe elemento com a chave epecificado 
+ * no conjunto ordenado
+ */
 int conjord_existe_elemento(conjord *a, int chave);
 
+/**
+ * insersecciona dois conjuntos formando um terceiro
+ * como resultado desta operacao retornando seu ponteiro
+ * a seguir
+ */
 conjord *conjord_interseciona(conjord *a, conjord *b);
+
+/**
+ * une dois conjuntos formando um terceiro
+ * como resultado desta operacao retornando seu ponteiro
+ * a seguir
+ */
 conjord *conjord_une(conjord *a, conjord *b);
+
+/**
+ * subtrai dois conjuntos formando um terceiro
+ * como resultado desta operacao retornando seu ponteiro
+ * a seguir
+ */
 conjord *conjord_subtrai(conjord *a, conjord *b);
 
+/**
+ * item 3 da especificao
+ * "Imprime a arvore rubro negra
+ * nesta operacao, cada noh da arvore serah
+ * representado pela sua chave de identificacao seguida da sua cor"
+ */
 void conjord_imprime_rb();
 
 #endif
diff --git a/src/red_black.c b/src/red_black.c
index 3a41fbf..77e9e98 100644
--- a/src/red_black.c
+++ b/src/red_black.c
@@ -180,20 +180,27 @@ static rb_n *tree_minimum(rb_n *x)
     return a;
 }
 
+/**
+ * sucessor baseado nas notas e no livro do cormen, reescrito
+ * e consegui diminuir em duas linhas do algoritmo original
+ */
 static rb_n* sucessor(rb_n *x)
 {
     rb_n *y = NULL;
     if (x->r)
         return tree_minimum(x->r);
-    y = x->p;
-    while (y && x == y->r)
-    {
+    while ((y = x->p) && x == y->r)
         x = y;
-        y = y->p;
-    }
     return y;
 }
 
+/**
+ * deleta noh da arvore red black
+ * @param t ponteiro duplo para raiz, assim pq ele pode ser alterado dentro da funcao
+ * e manter a alteracao depois do retorno da fucao
+ * @param z ponteiro para o noh a ser deletado, para deletar por chave o TAD deve
+ * passar a saida da funcao pesquisar, num arranjo funcional na chamada
+ */
 int rb_delete(rb_n **t, rb_n *z)
 {
     rb_n *x;
@@ -411,3 +418,5 @@ rb_n *rb_search(rb_n *t, int k)
 
     return  NULL;
 }
+
+

commit ff3a1dc2514de4e3a236485fbe6260f61266e1f0
Author: Joilnen <joilnen@gmail.com>
Date:   Wed Dec 22 14:05:06 2021 -0300

    testando impressao da arvore

diff --git a/src/conjunto_ordenado.c b/src/conjunto_ordenado.c
index 14f03ab..e79ff10 100644
--- a/src/conjunto_ordenado.c
+++ b/src/conjunto_ordenado.c
@@ -1,3 +1,4 @@
+#include <stdio.h>
 #include "conjunto_ordenado.h"
 
 /**
@@ -34,4 +35,33 @@ int conjord_esvazia(conjord *a)
 
 }
 
+/**
+ * imprime arvore
+ */
+#define  COUNT  10
+void conjord_imprime_rb(rb_n *t, int s)  {  
+    // Base case  
+    if (!t)
+        return;  
+  
+    // Increase distance between levels  
+    s += COUNT;  
+  
+    // Process l child  
+    conjord_imprime_rb(t->l, s);  
+
+    // Print current node after space  
+    // count  
+    printf("\n");
+    for (int i = COUNT; i < s; i++)  
+        printf(" ");  
+    if(t->c == BLACK)
+        printf("\033[44m\033[37mk:%dc:%d\033[0m\n", t->k, t->c);
+    else
+        printf("\033[41m\033[37mk:%dc:%d\033[0m\n", t->k, t->c);
+  
+    // Process right child first  
+    conjord_imprime_rb(t->r, s);  
+}  
+
 
diff --git a/src/conjunto_ordenado.h b/src/conjunto_ordenado.h
index aa94a83..5061946 100644
--- a/src/conjunto_ordenado.h
+++ b/src/conjunto_ordenado.h
@@ -92,7 +92,7 @@ conjord *conjord_subtrai(conjord *a, conjord *b);
  * nesta operacao, cada noh da arvore serah
  * representado pela sua chave de identificacao seguida da sua cor"
  */
-void conjord_imprime_rb();
+void conjord_imprime_rb(rb_n *t, int s);
 
 #endif
 
diff --git a/src/main.c b/src/main.c
index efbadf8..1daea2a 100644
--- a/src/main.c
+++ b/src/main.c
@@ -52,6 +52,11 @@ int main()
      */
     rb_n *conjunto_a = rb_cr(10, &mt0);
 
+    rb_pr(conjunto_a);
+    printf("= arvore ===================\n");
+    conjord_imprime_rb(conjunto_a, 1);
+    printf("= ==========================\n");
+
     meu_tipo mt1;
     mt1.nome = (char *) malloc(sizeof("nome para teste") + 1);
     strncpy(mt1.nome, "nome para teste", sizeof("nome para teste") + 1);
@@ -64,6 +69,11 @@ int main()
 
     rb_insert(&conjunto_a, novo_noh);
 
+    rb_pr(conjunto_a);
+    printf("= arvore ===================\n");
+    conjord_imprime_rb(conjunto_a, 1);
+    printf("= ==========================\n");
+
     meu_tipo mt2;
     mt2.nome = (char *) malloc(sizeof("nome para teste") + 1);
     strncpy(mt2.nome, "nome para teste", sizeof("nome para teste") + 1);
@@ -75,6 +85,11 @@ int main()
     novo_noh->d = &mt2;
     rb_insert(&conjunto_a, novo_noh);
 
+    rb_pr(conjunto_a);
+    printf("= arvore ===================\n");
+    conjord_imprime_rb(conjunto_a, 1);
+    printf("= ==========================\n");
+
     meu_tipo mt3;
     mt3.nome = (char *) malloc(sizeof("nome para teste") + 1);
     strncpy(mt3.nome, "nome para teste", sizeof("nome para teste") + 1);
@@ -86,6 +101,11 @@ int main()
     novo_noh->d = &mt3;
     rb_insert(&conjunto_a, novo_noh);
 
+    rb_pr(conjunto_a);
+    printf("= arvore ===================\n");
+    conjord_imprime_rb(conjunto_a, 1);
+    printf("= ==========================\n");
+
     meu_tipo mt4;
     mt4.nome = (char *) malloc(sizeof("nome para teste") + 1);
     strncpy(mt4.nome, "nome para teste", sizeof("nome para teste") + 1);
@@ -97,6 +117,11 @@ int main()
     novo_noh->d = &mt4;
     rb_insert(&conjunto_a, novo_noh);
 
+    rb_pr(conjunto_a);
+    printf("= arvore ===================\n");
+    conjord_imprime_rb(conjunto_a, 1);
+    printf("= ==========================\n");
+
     meu_tipo mt5;
     mt5.nome = (char *) malloc(sizeof("nome para teste") + 1);
     strncpy(mt5.nome, "nome para teste", sizeof("nome para teste") + 1);
@@ -119,6 +144,11 @@ int main()
     novo_noh->d = &mt6;
     rb_insert(&conjunto_a, novo_noh);
 
+    rb_pr(conjunto_a);
+    printf("= arvore ===================\n");
+    conjord_imprime_rb(conjunto_a, 1);
+    printf("= ==========================\n");
+
     meu_tipo mt7;
     mt7.nome = (char *) malloc(sizeof("nome para teste") + 1);
     strncpy(mt7.nome, "nome para teste", sizeof("nome para teste") + 1);
@@ -130,6 +160,10 @@ int main()
     novo_noh->d = &mt7;
     rb_insert(&conjunto_a, novo_noh);
 
+    printf("= arvore ===================\n");
+    conjord_imprime_rb(conjunto_a, 1);
+    printf("= ==========================\n");
+
     rb_pr(conjunto_a);
     rb_delete(&conjunto_a, rb_search(conjunto_a, 3));
     printf("\n");
@@ -138,6 +172,9 @@ int main()
     printf("\n");
     rb_pr(conjunto_a);
     rb_delete(&conjunto_a, rb_search(conjunto_a, 4));
+    printf("= arvore ===================\n");
+    conjord_imprime_rb(conjunto_a, 1);
+    printf("= ==========================\n");
     printf("\n");
     rb_pr(conjunto_a);
     rb_delete(&conjunto_a, rb_search(conjunto_a, 8));
@@ -145,12 +182,21 @@ int main()
     rb_pr(conjunto_a);
     rb_delete(&conjunto_a, rb_search(conjunto_a, 9));
     printf("\n");
+    printf("= arvore ===================\n");
+    conjord_imprime_rb(conjunto_a, 1);
+    printf("= ==========================\n");
     rb_pr(conjunto_a);
     rb_delete(&conjunto_a, rb_search(conjunto_a, 5));
     printf("\n");
     rb_pr(conjunto_a);
+    printf("= arvore ===================\n");
+    conjord_imprime_rb(conjunto_a, 1);
+    printf("= ==========================\n");
     rb_delete(&conjunto_a, rb_search(conjunto_a, 6));
-    printf("\n nada");
+    printf("\n nada\n");
+    printf("= arvore ===================\n");
+    conjord_imprime_rb(conjunto_a, 1);
+    printf("= ==========================\n");
     rb_pr(conjunto_a);
     printf("\n");
     /**

commit 5ec58093d577a71de87d125f0c9485c35b4665af
Author: Joilnen <joilnen@gmail.com>
Date:   Wed Dec 22 14:41:05 2021 -0300

    pequena demonstracao da rb

diff --git a/src/main.c b/src/main.c
index 1daea2a..b5968aa 100644
--- a/src/main.c
+++ b/src/main.c
@@ -56,6 +56,8 @@ int main()
     printf("= arvore ===================\n");
     conjord_imprime_rb(conjunto_a, 1);
     printf("= ==========================\n");
+    printf("* tecle enter *");
+    getc(stdin);
 
     meu_tipo mt1;
     mt1.nome = (char *) malloc(sizeof("nome para teste") + 1);
@@ -73,6 +75,8 @@ int main()
     printf("= arvore ===================\n");
     conjord_imprime_rb(conjunto_a, 1);
     printf("= ==========================\n");
+    printf("* tecle enter *");
+    getc(stdin);
 
     meu_tipo mt2;
     mt2.nome = (char *) malloc(sizeof("nome para teste") + 1);
@@ -89,6 +93,8 @@ int main()
     printf("= arvore ===================\n");
     conjord_imprime_rb(conjunto_a, 1);
     printf("= ==========================\n");
+    printf("* tecle enter *");
+    getc(stdin);
 
     meu_tipo mt3;
     mt3.nome = (char *) malloc(sizeof("nome para teste") + 1);
@@ -105,6 +111,8 @@ int main()
     printf("= arvore ===================\n");
     conjord_imprime_rb(conjunto_a, 1);
     printf("= ==========================\n");
+    printf("* tecle enter *");
+    getc(stdin);
 
     meu_tipo mt4;
     mt4.nome = (char *) malloc(sizeof("nome para teste") + 1);
@@ -121,6 +129,8 @@ int main()
     printf("= arvore ===================\n");
     conjord_imprime_rb(conjunto_a, 1);
     printf("= ==========================\n");
+    printf("* tecle enter *");
+    getc(stdin);
 
     meu_tipo mt5;
     mt5.nome = (char *) malloc(sizeof("nome para teste") + 1);
@@ -148,6 +158,8 @@ int main()
     printf("= arvore ===================\n");
     conjord_imprime_rb(conjunto_a, 1);
     printf("= ==========================\n");
+    printf("* tecle enter *");
+    getc(stdin);
 
     meu_tipo mt7;
     mt7.nome = (char *) malloc(sizeof("nome para teste") + 1);
@@ -163,6 +175,8 @@ int main()
     printf("= arvore ===================\n");
     conjord_imprime_rb(conjunto_a, 1);
     printf("= ==========================\n");
+    printf("* tecle enter *");
+    getc(stdin);
 
     rb_pr(conjunto_a);
     rb_delete(&conjunto_a, rb_search(conjunto_a, 3));
@@ -176,6 +190,8 @@ int main()
     conjord_imprime_rb(conjunto_a, 1);
     printf("= ==========================\n");
     printf("\n");
+    printf("* tecle enter *");
+    getc(stdin);
     rb_pr(conjunto_a);
     rb_delete(&conjunto_a, rb_search(conjunto_a, 8));
     printf("\n");
@@ -185,6 +201,8 @@ int main()
     printf("= arvore ===================\n");
     conjord_imprime_rb(conjunto_a, 1);
     printf("= ==========================\n");
+    printf("* tecle enter *");
+    getc(stdin);
     rb_pr(conjunto_a);
     rb_delete(&conjunto_a, rb_search(conjunto_a, 5));
     printf("\n");
@@ -192,6 +210,8 @@ int main()
     printf("= arvore ===================\n");
     conjord_imprime_rb(conjunto_a, 1);
     printf("= ==========================\n");
+    printf("* tecle enter *");
+    getc(stdin);
     rb_delete(&conjunto_a, rb_search(conjunto_a, 6));
     printf("\n nada\n");
     printf("= arvore ===================\n");

commit 5cd18bc478e1492c25c4468738aead5b40add977
Author: Joilnen <joilnen@gmail.com>
Date:   Wed Dec 22 17:37:42 2021 -0300

    demonstracao da arvore rb

diff --git a/src/main.c b/src/main.c
index b5968aa..2da400d 100644
--- a/src/main.c
+++ b/src/main.c
@@ -56,7 +56,7 @@ int main()
     printf("= arvore ===================\n");
     conjord_imprime_rb(conjunto_a, 1);
     printf("= ==========================\n");
-    printf("* tecle enter *");
+    printf("* tecle enter *\n");
     getc(stdin);
 
     meu_tipo mt1;
@@ -75,7 +75,7 @@ int main()
     printf("= arvore ===================\n");
     conjord_imprime_rb(conjunto_a, 1);
     printf("= ==========================\n");
-    printf("* tecle enter *");
+    printf("* tecle enter *\n");
     getc(stdin);
 
     meu_tipo mt2;
@@ -93,7 +93,7 @@ int main()
     printf("= arvore ===================\n");
     conjord_imprime_rb(conjunto_a, 1);
     printf("= ==========================\n");
-    printf("* tecle enter *");
+    printf("* tecle enter *\n");
     getc(stdin);
 
     meu_tipo mt3;
@@ -111,7 +111,7 @@ int main()
     printf("= arvore ===================\n");
     conjord_imprime_rb(conjunto_a, 1);
     printf("= ==========================\n");
-    printf("* tecle enter *");
+    printf("* tecle enter *\n");
     getc(stdin);
 
     meu_tipo mt4;
@@ -129,7 +129,7 @@ int main()
     printf("= arvore ===================\n");
     conjord_imprime_rb(conjunto_a, 1);
     printf("= ==========================\n");
-    printf("* tecle enter *");
+    printf("* tecle enter *\n");
     getc(stdin);
 
     meu_tipo mt5;
@@ -158,7 +158,7 @@ int main()
     printf("= arvore ===================\n");
     conjord_imprime_rb(conjunto_a, 1);
     printf("= ==========================\n");
-    printf("* tecle enter *");
+    printf("* tecle enter *\n");
     getc(stdin);
 
     meu_tipo mt7;
@@ -175,7 +175,7 @@ int main()
     printf("= arvore ===================\n");
     conjord_imprime_rb(conjunto_a, 1);
     printf("= ==========================\n");
-    printf("* tecle enter *");
+    printf("* tecle enter *\n");
     getc(stdin);
 
     rb_pr(conjunto_a);
@@ -189,8 +189,7 @@ int main()
     printf("= arvore ===================\n");
     conjord_imprime_rb(conjunto_a, 1);
     printf("= ==========================\n");
-    printf("\n");
-    printf("* tecle enter *");
+    printf("* tecle enter *\n");
     getc(stdin);
     rb_pr(conjunto_a);
     rb_delete(&conjunto_a, rb_search(conjunto_a, 8));
@@ -201,7 +200,7 @@ int main()
     printf("= arvore ===================\n");
     conjord_imprime_rb(conjunto_a, 1);
     printf("= ==========================\n");
-    printf("* tecle enter *");
+    printf("* tecle enter *\n");
     getc(stdin);
     rb_pr(conjunto_a);
     rb_delete(&conjunto_a, rb_search(conjunto_a, 5));
@@ -210,7 +209,7 @@ int main()
     printf("= arvore ===================\n");
     conjord_imprime_rb(conjunto_a, 1);
     printf("= ==========================\n");
-    printf("* tecle enter *");
+    printf("* tecle enter *\n");
     getc(stdin);
     rb_delete(&conjunto_a, rb_search(conjunto_a, 6));
     printf("\n nada\n");

commit 98d87c66232c4fe8c1f700d6cffe3b3ea766b4d5
Author: Joilnen <joilnen@gmail.com>
Date:   Wed Dec 22 17:41:22 2021 -0300

    ajustando demonstracao de arvore rb

diff --git a/src/conjunto_ordenado.c b/src/conjunto_ordenado.c
index e79ff10..fbf8c1f 100644
--- a/src/conjunto_ordenado.c
+++ b/src/conjunto_ordenado.c
@@ -48,7 +48,7 @@ void conjord_imprime_rb(rb_n *t, int s)  {
     s += COUNT;  
   
     // Process l child  
-    conjord_imprime_rb(t->l, s);  
+    conjord_imprime_rb(t->r, s);  
 
     // Print current node after space  
     // count  
@@ -61,7 +61,7 @@ void conjord_imprime_rb(rb_n *t, int s)  {
         printf("\033[41m\033[37mk:%dc:%d\033[0m\n", t->k, t->c);
   
     // Process right child first  
-    conjord_imprime_rb(t->r, s);  
+    conjord_imprime_rb(t->l, s);  
 }  
 
 

commit 87f35c13d0197242d6b5e7fa87785cdcd8f9e81a
Author: Joilnen <joilnen@gmail.com>
Date:   Wed Dec 22 19:44:38 2021 -0300

    demonstracao da insercao e delecao na arvore rb no main.c

diff --git a/src/main.c b/src/main.c
index 2da400d..df889e7 100644
--- a/src/main.c
+++ b/src/main.c
@@ -9,6 +9,12 @@
 #include <stdio.h>
 #include <string.h>
 
+void pula_tela()
+{
+    int i;
+    for (i = 0; i < 21; i++)
+        printf("\n");
+}
 /**
  * funcao  de impressao do dipo especifico criado pelo o usuario da biblioteca
  * @noh rb
@@ -52,7 +58,9 @@ int main()
      */
     rb_n *conjunto_a = rb_cr(10, &mt0);
 
+    pula_tela();
     rb_pr(conjunto_a);
+    printf("\n");
     printf("= arvore ===================\n");
     conjord_imprime_rb(conjunto_a, 1);
     printf("= ==========================\n");
@@ -71,7 +79,9 @@ int main()
 
     rb_insert(&conjunto_a, novo_noh);
 
+    pula_tela();
     rb_pr(conjunto_a);
+    printf("\n");
     printf("= arvore ===================\n");
     conjord_imprime_rb(conjunto_a, 1);
     printf("= ==========================\n");
@@ -89,7 +99,9 @@ int main()
     novo_noh->d = &mt2;
     rb_insert(&conjunto_a, novo_noh);
 
+    pula_tela();
     rb_pr(conjunto_a);
+    printf("\n");
     printf("= arvore ===================\n");
     conjord_imprime_rb(conjunto_a, 1);
     printf("= ==========================\n");
@@ -107,7 +119,9 @@ int main()
     novo_noh->d = &mt3;
     rb_insert(&conjunto_a, novo_noh);
 
+    pula_tela();
     rb_pr(conjunto_a);
+    printf("\n");
     printf("= arvore ===================\n");
     conjord_imprime_rb(conjunto_a, 1);
     printf("= ==========================\n");
@@ -125,7 +139,9 @@ int main()
     novo_noh->d = &mt4;
     rb_insert(&conjunto_a, novo_noh);
 
+    pula_tela();
     rb_pr(conjunto_a);
+    printf("\n");
     printf("= arvore ===================\n");
     conjord_imprime_rb(conjunto_a, 1);
     printf("= ==========================\n");
@@ -143,6 +159,14 @@ int main()
     novo_noh->d = &mt5;
     rb_insert(&conjunto_a, novo_noh);
 
+    pula_tela();
+    rb_pr(conjunto_a);
+    printf("\n");
+    printf("= arvore ===================\n");
+    conjord_imprime_rb(conjunto_a, 1);
+    printf("= ==========================\n");
+    printf("* tecle enter *\n");
+
     meu_tipo mt6;
     mt6.nome = (char *) malloc(sizeof("nome para teste") + 1);
     strncpy(mt6.nome, "nome para teste", sizeof("nome para teste") + 1);
@@ -154,7 +178,9 @@ int main()
     novo_noh->d = &mt6;
     rb_insert(&conjunto_a, novo_noh);
 
+    pula_tela();
     rb_pr(conjunto_a);
+    printf("\n");
     printf("= arvore ===================\n");
     conjord_imprime_rb(conjunto_a, 1);
     printf("= ==========================\n");
@@ -172,30 +198,61 @@ int main()
     novo_noh->d = &mt7;
     rb_insert(&conjunto_a, novo_noh);
 
+    pula_tela();
+    rb_pr(conjunto_a);
+    printf("\n");
     printf("= arvore ===================\n");
     conjord_imprime_rb(conjunto_a, 1);
     printf("= ==========================\n");
     printf("* tecle enter *\n");
     getc(stdin);
 
-    rb_pr(conjunto_a);
     rb_delete(&conjunto_a, rb_search(conjunto_a, 3));
     printf("\n");
+    pula_tela();
     rb_pr(conjunto_a);
+    printf("\n");
+    printf("= arvore ===================\n");
+    conjord_imprime_rb(conjunto_a, 1);
+    printf("= ==========================\n");
+    printf("* tecle enter *\n");
+    getc(stdin);
+
     rb_delete(&conjunto_a, rb_search(conjunto_a, 11));
     printf("\n");
+    pula_tela();
     rb_pr(conjunto_a);
+    printf("= arvore ===================\n");
+    conjord_imprime_rb(conjunto_a, 1);
+    printf("= ==========================\n");
+    printf("* tecle enter *\n");
+    getc(stdin);
+
     rb_delete(&conjunto_a, rb_search(conjunto_a, 4));
+    printf("\n");
+    pula_tela();
+    rb_pr(conjunto_a);
+    printf("\n");
     printf("= arvore ===================\n");
     conjord_imprime_rb(conjunto_a, 1);
     printf("= ==========================\n");
     printf("* tecle enter *\n");
     getc(stdin);
+
+    pula_tela();
     rb_pr(conjunto_a);
-    rb_delete(&conjunto_a, rb_search(conjunto_a, 8));
     printf("\n");
+    rb_delete(&conjunto_a, rb_search(conjunto_a, 8));
     rb_pr(conjunto_a);
+    printf("= arvore ===================\n");
+    conjord_imprime_rb(conjunto_a, 1);
+    printf("= ==========================\n");
+    printf("* tecle enter *\n");
+    getc(stdin);
+
     rb_delete(&conjunto_a, rb_search(conjunto_a, 9));
+    pula_tela();
+    rb_pr(conjunto_a);
     printf("\n");
     printf("= arvore ===================\n");
     conjord_imprime_rb(conjunto_a, 1);
@@ -203,15 +260,20 @@ int main()
     printf("* tecle enter *\n");
     getc(stdin);
     rb_pr(conjunto_a);
+    printf("\n");
     rb_delete(&conjunto_a, rb_search(conjunto_a, 5));
     printf("\n");
+
+    pula_tela();
     rb_pr(conjunto_a);
+    printf("\n");
     printf("= arvore ===================\n");
     conjord_imprime_rb(conjunto_a, 1);
     printf("= ==========================\n");
     printf("* tecle enter *\n");
     getc(stdin);
     rb_delete(&conjunto_a, rb_search(conjunto_a, 6));
+    pula_tela();
     printf("\n nada\n");
     printf("= arvore ===================\n");
     conjord_imprime_rb(conjunto_a, 1);
diff --git a/src/red_black.c b/src/red_black.c
index 77e9e98..4223138 100644
--- a/src/red_black.c
+++ b/src/red_black.c
@@ -391,9 +391,9 @@ void rb_pr(rb_n *a)
     if (a)
     {
         if(a->c == BLACK)
-            printf("\033[44m\033[37mk:%dc:%d\033[0m\n", a->k, a->c);
+            printf("\033[44m\033[37mk:%dc:%d\033[0m ", a->k, a->c);
         else
-            printf("\033[41m\033[37mk:%dc:%d\033[0m\n", a->k, a->c);
+            printf("\033[41m\033[37mk:%dc:%d\033[0m ", a->k, a->c);
         rb_pr(a->l);
         rb_pr(a->r);
     }

commit 7ed984a1847f5984682c35be109ee002f6d6bd75
Author: Joilnen <joilnen@gmail.com>
Date:   Thu Dec 23 09:15:10 2021 -0300

    melhorando a documentacao relatorio principal

diff --git a/doc/tex/figs/ADT.jpg b/doc/tex/figs/ADT.jpg
new file mode 100644
index 0000000..8752fad
Binary files /dev/null and b/doc/tex/figs/ADT.jpg differ
diff --git a/doc/tex/fig/golpatterns.png b/doc/tex/figs/golpatterns.png
similarity index 100%
rename from doc/tex/fig/golpatterns.png
rename to doc/tex/figs/golpatterns.png
diff --git a/doc/tex/fig/lista.png b/doc/tex/figs/lista.png
similarity index 100%
rename from doc/tex/fig/lista.png
rename to doc/tex/figs/lista.png
diff --git a/doc/tex/fig/ontologia.pdf b/doc/tex/figs/ontologia.pdf
similarity index 100%
rename from doc/tex/fig/ontologia.pdf
rename to doc/tex/figs/ontologia.pdf
diff --git a/doc/tex/fig/ontologia1.eps b/doc/tex/figs/ontologia1.eps
similarity index 100%
rename from doc/tex/fig/ontologia1.eps
rename to doc/tex/figs/ontologia1.eps
diff --git a/doc/tex/fig/t.jpg b/doc/tex/figs/t.jpg
similarity index 100%
rename from doc/tex/fig/t.jpg
rename to doc/tex/figs/t.jpg
diff --git a/doc/tex/packages.tex b/doc/tex/packages.tex
index 1351cce..5e4756a 100644
--- a/doc/tex/packages.tex
+++ b/doc/tex/packages.tex
@@ -79,7 +79,7 @@
     title=Listing \thetcbcounter: #2, #1}
 
 % Automata packages
-\usepackage{tikz, graphics}
+\usepackage{tikz, graphicx}
 
 \usepackage{pgfplots}
 \pgfplotsset{compat=1.16}
diff --git a/doc/tex/relatorio.pdf b/doc/tex/relatorio.pdf
index aec8bba..ef705d1 100644
Binary files a/doc/tex/relatorio.pdf and b/doc/tex/relatorio.pdf differ
diff --git a/doc/tex/relatorio.tex b/doc/tex/relatorio.tex
index 829d600..9c07db1 100644
--- a/doc/tex/relatorio.tex
+++ b/doc/tex/relatorio.tex
@@ -84,12 +84,22 @@ da atividade conjunto ordenado \\
 \indent \textbf{Palavras-chave: } fontes, C, Red Black, Conjunto\\
 \small
 \section {Introdução}
-Esta biblioteca é composta por dois arquivos, conjunto\_ordenado.c e seu cabeçalho,
-conjunto\_ordenado.h, sendo necessário apenas para seu uso a inclusão via, \\
-\enf{\#include "conjunto\_ordenado.h"} e compilação conjunta com conjunto\_ordenado.c
+\noindent Esta biblioteca é composta por quatro arquivos, \\
+\enf{conjunto\_ordenado.h}\\
+\enf{conjunto\_ordenado.c} \\
+\enf{red\_black.h} \\
+\enf{red\_black.c}\\
+sendo necessário apenas para seu uso a inclusão via, \\
+\enf{\#include "conjunto\_ordenado.h"} onde se encontra declarado, sendo definido em \\
+\enf{"conjunto\_ordenado.c"}, o TAD \footnote{Tipo Abstrato de Dados} 
+\enf{conjord} que oculta do código cliente e manipula internamente a estrutura de dados
+red black \enf{"struct rb\_n *"} aqui neste trabalho, declarada em \enf{red\_black.h} e definida em 
+\enf{red\_black.c} 
 
 Além da convencional inclusão e compilação, o usuário da biblioteca, pessoa
-que escreve o programa cliente, aqui neste trabalho exemplificado pelo o arquivo \enf{main.c}
+que escreve o programa cliente, aqui neste trabalho exemplificado pelo os arquivos \\
+\enf{main.c} \\
+\enf{test\_tree.c} \\
 deverá escolher definir seu tipo dado, através de uma struct ou utilizar um tipo de dado nativo da 
 linguagem.
 \renewcommand{\lstlistingname}{Fonte}
@@ -192,10 +202,18 @@ void (*imprime_elemento)(rb_n *);
 int seta_imprime_elemento(void (*i)(rb_n *n));
 \end{lstlisting}
 
-% \section{Referências Bibliográficas}
+\begin{figure}
+    \begin{center}
+    \includegraphics [scale = .4] {figs/ADT}
+        \caption{Diagrama TAD}
+    \end{center}
+\end{figure}
+
+\section{Referências Bibliográficas}
 \nocite{*}
 \bibliography{mybib.bib}{}
 \bibliographystyle{plain}
+\href{https://www.geeksforgeeks.org/abstract-data-types/} {Diagrama TAD - \color{blue} https://www.geeksforgeeks.org/abstract-data-types/}
 
 \end {document}
 
diff --git a/src/main.c b/src/main.c
index df889e7..bb9a986 100644
--- a/src/main.c
+++ b/src/main.c
@@ -9,12 +9,20 @@
 #include <stdio.h>
 #include <string.h>
 
-void pula_tela()
-{
-    int i;
-    for (i = 0; i < 21; i++)
-        printf("\n");
+/**
+ * foi utlizado macro em vez de funca
+ * pra evitar o footprint da chanada
+ * pois essa funcao limpa a tela entao 
+ * varias a vezes eh preferivel q seja inline
+ * mas como n tem funcao inline usei a macro
+ */
+#define pula_tela() \
+{ \
+    int i; \
+    for (i = 0; i < 21; i++) \
+        printf("\n"); \
 }
+
 /**
  * funcao  de impressao do dipo especifico criado pelo o usuario da biblioteca
  * @noh rb
@@ -219,9 +227,9 @@ int main()
     getc(stdin);
 
     rb_delete(&conjunto_a, rb_search(conjunto_a, 11));
-    printf("\n");
     pula_tela();
     rb_pr(conjunto_a);
+    printf("\n");
     printf("= arvore ===================\n");
     conjord_imprime_rb(conjunto_a, 1);
     printf("= ==========================\n");
@@ -229,7 +237,6 @@ int main()
     getc(stdin);
 
     rb_delete(&conjunto_a, rb_search(conjunto_a, 4));
-    printf("\n");
     pula_tela();
     rb_pr(conjunto_a);
     printf("\n");
@@ -239,11 +246,10 @@ int main()
     printf("* tecle enter *\n");
     getc(stdin);
 
+    rb_delete(&conjunto_a, rb_search(conjunto_a, 8));
     pula_tela();
     rb_pr(conjunto_a);
     printf("\n");
-    rb_delete(&conjunto_a, rb_search(conjunto_a, 8));
-    rb_pr(conjunto_a);
     printf("= arvore ===================\n");
     conjord_imprime_rb(conjunto_a, 1);
     printf("= ==========================\n");

commit f479dcc6b016d0977efcc69d87a3fb76b4b15306
Author: Joilnen <joilnen@gmail.com>
Date:   Thu Dec 23 11:22:57 2021 -0300

    lidando com a limpeza de tela

diff --git a/src/conjunto_ordenado.c b/src/conjunto_ordenado.c
index fbf8c1f..006050e 100644
--- a/src/conjunto_ordenado.c
+++ b/src/conjunto_ordenado.c
@@ -4,10 +4,11 @@
 /**
  * cria conjunto ordenado e retorna o ponteiro para ele
  */
-conjord *conjord_cria()
+conjord *conjord_cria(char *nome)
 {
     conjord *c = (conjord *) malloc (sizeof(conjord));
     c->raiz = NULL;
+    c->nome = nome;
     c->cardinalidade = 0;
 
     return c;
diff --git a/src/conjunto_ordenado.h b/src/conjunto_ordenado.h
index 5061946..2b291a6 100644
--- a/src/conjunto_ordenado.h
+++ b/src/conjunto_ordenado.h
@@ -14,13 +14,14 @@
  */
 typedef struct conjord {
     rb_n *raiz;
+    char *nome;
     int cardinalidade;
 } conjord;
 
 /**
  * cria conjunto ordenado e retorna o ponteiro para ele
  */
-conjord *conjord_cria();
+conjord *conjord_cria(char *nome);
 
 /**
  * imprime elementos do conjunto subitem 1 do item 2
diff --git a/src/main.c b/src/main.c
index bb9a986..6a2f197 100644
--- a/src/main.c
+++ b/src/main.c
@@ -10,19 +10,17 @@
 #include <string.h>
 
 /**
- * foi utlizado macro em vez de funca
- * pra evitar o footprint da chanada
- * pois essa funcao limpa a tela entao 
+ * foi utlizado macro em vez de funcao
+ * pra evitar o footprint da chamada
+ * pois essa funcao limpa a tela entao chmada
  * varias a vezes eh preferivel q seja inline
  * mas como n tem funcao inline usei a macro
+ * foi primeiro implementado com um loop
+ * mas pensando melhor dessa forma mais rapido
  */
+static  char aux_pula_tela[22];
 #define pula_tela() \
-{ \
-    int i; \
-    for (i = 0; i < 21; i++) \
-        printf("\n"); \
-}
-
+    printf("%s", aux_pula_tela);
 /**
  * funcao  de impressao do dipo especifico criado pelo o usuario da biblioteca
  * @noh rb
@@ -34,6 +32,8 @@ void imprime_meu_tipo(rb_n *);
  */
 int main()
 {
+    /** seta scroll da tela */
+    memset(aux_pula_tela, '\n', 21);
     /**
      * definicao de um tipo exemplo pelo o usuario
      */

commit 61e26de8f07d32e6b0fd6f50e21fd984ea598e08
Author: Joilnen <joilnen@gmail.com>
Date:   Thu Dec 23 18:43:08 2021 -0300

    adicionado parametro pra suportar terminais sem cor

diff --git a/src/conjunto_ordenado.c b/src/conjunto_ordenado.c
index 006050e..93520af 100644
--- a/src/conjunto_ordenado.c
+++ b/src/conjunto_ordenado.c
@@ -38,31 +38,41 @@ int conjord_esvazia(conjord *a)
 
 /**
  * imprime arvore
+ * @param t noh raiz
+ * @param s espaco entre os nohs na impressao
+ * @param e tipo do terminal
  */
-#define  COUNT  10
-void conjord_imprime_rb(rb_n *t, int s)  {  
-    // Base case  
+void conjord_imprime_rb(rb_n *t, int s, int e)  {  
+    const int dist =  8;
     if (!t)
         return;  
   
-    // Increase distance between levels  
-    s += COUNT;  
+    s += dist;  
   
-    // Process l child  
-    conjord_imprime_rb(t->r, s);  
+    conjord_imprime_rb(t->r, s, e);  
 
-    // Print current node after space  
-    // count  
-    printf("\n");
-    for (int i = COUNT; i < s; i++)  
-        printf(" ");  
+    // for (int i = dist; i < s; i++)  
+    //     printf(" ");  
+    // printf("%*s", s, "");
+    printf("%*c", s - dist, ' ');
     if(t->c == BLACK)
-        printf("\033[44m\033[37mk:%dc:%d\033[0m\n", t->k, t->c);
+    {
+        if(e == TCOLOR)
+            printf("\033[44m\033[37mk:%dc:%d\033[0m\n", t->k, t->c);
+        else
+            printf("k:%dc:%d\n", t->k, t->c);
+
+    }
     else
-        printf("\033[41m\033[37mk:%dc:%d\033[0m\n", t->k, t->c);
+    {
+        if(e == TCOLOR)
+            printf("\033[41m\033[37mk:%dc:%d\033[0m\n", t->k, t->c);
+        else
+            printf("k:%dc:%d\n", t->k, t->c);
+    }
   
     // Process right child first  
-    conjord_imprime_rb(t->l, s);  
+    conjord_imprime_rb(t->l, s, e);  
 }  
 
 
diff --git a/src/conjunto_ordenado.h b/src/conjunto_ordenado.h
index 2b291a6..872dd50 100644
--- a/src/conjunto_ordenado.h
+++ b/src/conjunto_ordenado.h
@@ -93,7 +93,7 @@ conjord *conjord_subtrai(conjord *a, conjord *b);
  * nesta operacao, cada noh da arvore serah
  * representado pela sua chave de identificacao seguida da sua cor"
  */
-void conjord_imprime_rb(rb_n *t, int s);
+void conjord_imprime_rb(rb_n *t, int s, int e);
 
 #endif
 
diff --git a/src/main.c b/src/main.c
index 6a2f197..89ce9d7 100644
--- a/src/main.c
+++ b/src/main.c
@@ -12,20 +12,21 @@
 /**
  * foi utlizado macro em vez de funcao
  * pra evitar o footprint da chamada
- * pois essa funcao limpa a tela entao chmada
+ * pois essa funcao limpa a tela e eh chamada
  * varias a vezes eh preferivel q seja inline
  * mas como n tem funcao inline usei a macro
  * foi primeiro implementado com um loop
  * mas pensando melhor dessa forma mais rapido
  */
-static  char aux_pula_tela[22];
+#define TELA_PADRAO_FULL 45
+static  char aux_pula_tela[TELA_PADRAO_FULL + 1];
 #define pula_tela() \
     printf("%s", aux_pula_tela);
 /**
  * funcao  de impressao do dipo especifico criado pelo o usuario da biblioteca
  * @noh rb
  */
-void imprime_meu_tipo(rb_n *);
+void imprime_meu_tipo(void *);
 
 /**
  * funcao main de teste separada do codigo da biblioteca como especificado
@@ -33,7 +34,8 @@ void imprime_meu_tipo(rb_n *);
 int main()
 {
     /** seta scroll da tela */
-    memset(aux_pula_tela, '\n', 21);
+    memset(aux_pula_tela, '\n', TELA_PADRAO_FULL);
+
     /**
      * definicao de um tipo exemplo pelo o usuario
      */
@@ -67,10 +69,10 @@ int main()
     rb_n *conjunto_a = rb_cr(10, &mt0);
 
     pula_tela();
-    rb_pr(conjunto_a);
+    rb_pr(conjunto_a, TCOLOR);
     printf("\n");
     printf("= arvore ===================\n");
-    conjord_imprime_rb(conjunto_a, 1);
+    conjord_imprime_rb(conjunto_a, 1, TCOLOR);
     printf("= ==========================\n");
     printf("* tecle enter *\n");
     getc(stdin);
@@ -88,10 +90,10 @@ int main()
     rb_insert(&conjunto_a, novo_noh);
 
     pula_tela();
-    rb_pr(conjunto_a);
+    rb_pr(conjunto_a, TCOLOR);
     printf("\n");
     printf("= arvore ===================\n");
-    conjord_imprime_rb(conjunto_a, 1);
+    conjord_imprime_rb(conjunto_a, 1, TCOLOR);
     printf("= ==========================\n");
     printf("* tecle enter *\n");
     getc(stdin);
@@ -108,10 +110,10 @@ int main()
     rb_insert(&conjunto_a, novo_noh);
 
     pula_tela();
-    rb_pr(conjunto_a);
+    rb_pr(conjunto_a, TCOLOR);
     printf("\n");
     printf("= arvore ===================\n");
-    conjord_imprime_rb(conjunto_a, 1);
+    conjord_imprime_rb(conjunto_a, 1, TCOLOR);
     printf("= ==========================\n");
     printf("* tecle enter *\n");
     getc(stdin);
@@ -128,10 +130,10 @@ int main()
     rb_insert(&conjunto_a, novo_noh);
 
     pula_tela();
-    rb_pr(conjunto_a);
+    rb_pr(conjunto_a, TCOLOR);
     printf("\n");
     printf("= arvore ===================\n");
-    conjord_imprime_rb(conjunto_a, 1);
+    conjord_imprime_rb(conjunto_a, 1, TCOLOR);
     printf("= ==========================\n");
     printf("* tecle enter *\n");
     getc(stdin);
@@ -148,10 +150,10 @@ int main()
     rb_insert(&conjunto_a, novo_noh);
 
     pula_tela();
-    rb_pr(conjunto_a);
+    rb_pr(conjunto_a, TCOLOR);
     printf("\n");
     printf("= arvore ===================\n");
-    conjord_imprime_rb(conjunto_a, 1);
+    conjord_imprime_rb(conjunto_a, 1, TCOLOR);
     printf("= ==========================\n");
     printf("* tecle enter *\n");
     getc(stdin);
@@ -168,10 +170,10 @@ int main()
     rb_insert(&conjunto_a, novo_noh);
 
     pula_tela();
-    rb_pr(conjunto_a);
+    rb_pr(conjunto_a, TCOLOR);
     printf("\n");
     printf("= arvore ===================\n");
-    conjord_imprime_rb(conjunto_a, 1);
+    conjord_imprime_rb(conjunto_a, 1, TCOLOR);
     printf("= ==========================\n");
     printf("* tecle enter *\n");
 
@@ -187,10 +189,10 @@ int main()
     rb_insert(&conjunto_a, novo_noh);
 
     pula_tela();
-    rb_pr(conjunto_a);
+    rb_pr(conjunto_a, TCOLOR);
     printf("\n");
     printf("= arvore ===================\n");
-    conjord_imprime_rb(conjunto_a, 1);
+    conjord_imprime_rb(conjunto_a, 1, TCOLOR);
     printf("= ==========================\n");
     printf("* tecle enter *\n");
     getc(stdin);
@@ -207,10 +209,10 @@ int main()
     rb_insert(&conjunto_a, novo_noh);
 
     pula_tela();
-    rb_pr(conjunto_a);
+    rb_pr(conjunto_a, TCOLOR);
     printf("\n");
     printf("= arvore ===================\n");
-    conjord_imprime_rb(conjunto_a, 1);
+    conjord_imprime_rb(conjunto_a, 1, TCOLOR);
     printf("= ==========================\n");
     printf("* tecle enter *\n");
     getc(stdin);
@@ -218,63 +220,63 @@ int main()
     rb_delete(&conjunto_a, rb_search(conjunto_a, 3));
     printf("\n");
     pula_tela();
-    rb_pr(conjunto_a);
+    rb_pr(conjunto_a, TCOLOR);
     printf("\n");
     printf("= arvore ===================\n");
-    conjord_imprime_rb(conjunto_a, 1);
+    conjord_imprime_rb(conjunto_a, 1, TCOLOR);
     printf("= ==========================\n");
     printf("* tecle enter *\n");
     getc(stdin);
 
     rb_delete(&conjunto_a, rb_search(conjunto_a, 11));
     pula_tela();
-    rb_pr(conjunto_a);
+    rb_pr(conjunto_a, TCOLOR);
     printf("\n");
     printf("= arvore ===================\n");
-    conjord_imprime_rb(conjunto_a, 1);
+    conjord_imprime_rb(conjunto_a, 1, TCOLOR);
     printf("= ==========================\n");
     printf("* tecle enter *\n");
     getc(stdin);
 
     rb_delete(&conjunto_a, rb_search(conjunto_a, 4));
     pula_tela();
-    rb_pr(conjunto_a);
+    rb_pr(conjunto_a, TCOLOR);
     printf("\n");
     printf("= arvore ===================\n");
-    conjord_imprime_rb(conjunto_a, 1);
+    conjord_imprime_rb(conjunto_a, 1, TCOLOR);
     printf("= ==========================\n");
     printf("* tecle enter *\n");
     getc(stdin);
 
     rb_delete(&conjunto_a, rb_search(conjunto_a, 8));
     pula_tela();
-    rb_pr(conjunto_a);
+    rb_pr(conjunto_a, TCOLOR);
     printf("\n");
     printf("= arvore ===================\n");
-    conjord_imprime_rb(conjunto_a, 1);
+    conjord_imprime_rb(conjunto_a, 1, TCOLOR);
     printf("= ==========================\n");
     printf("* tecle enter *\n");
     getc(stdin);
 
     rb_delete(&conjunto_a, rb_search(conjunto_a, 9));
     pula_tela();
-    rb_pr(conjunto_a);
+    rb_pr(conjunto_a, TCOLOR);
     printf("\n");
     printf("= arvore ===================\n");
-    conjord_imprime_rb(conjunto_a, 1);
+    conjord_imprime_rb(conjunto_a, 1, TCOLOR);
     printf("= ==========================\n");
     printf("* tecle enter *\n");
     getc(stdin);
-    rb_pr(conjunto_a);
+    rb_pr(conjunto_a, TCOLOR);
     printf("\n");
     rb_delete(&conjunto_a, rb_search(conjunto_a, 5));
     printf("\n");
 
     pula_tela();
-    rb_pr(conjunto_a);
+    rb_pr(conjunto_a, TCOLOR);
     printf("\n");
     printf("= arvore ===================\n");
-    conjord_imprime_rb(conjunto_a, 1);
+    conjord_imprime_rb(conjunto_a, 1, TCOLOR);
     printf("= ==========================\n");
     printf("* tecle enter *\n");
     getc(stdin);
@@ -282,9 +284,9 @@ int main()
     pula_tela();
     printf("\n nada\n");
     printf("= arvore ===================\n");
-    conjord_imprime_rb(conjunto_a, 1);
+    conjord_imprime_rb(conjunto_a, 1, TCOLOR);
     printf("= ==========================\n");
-    rb_pr(conjunto_a);
+    rb_pr(conjunto_a, TCOLOR);
     printf("\n");
     /**
      * testando apenas rb no momento
@@ -297,7 +299,7 @@ int main()
  * definicao da funcao de impressao estipulado pelo cliente, aqui apenas um
  * exemplo
  */
-void imprime_meu_tipo(rb_n *n)
+void imprime_meu_tipo(void *n)
 {
 
 }
diff --git a/src/red_black.c b/src/red_black.c
index 4223138..4e7dbbb 100644
--- a/src/red_black.c
+++ b/src/red_black.c
@@ -7,7 +7,7 @@
 #include "red_black.h"
 #include <stdio.h>
 
-void (*rb_impr_elem)(rb_n *);
+void (*rb_impr_elem)(void *);
 
 rb_n* rb_cr(int key, void *dado)
 {
@@ -381,21 +381,31 @@ int rb_rot_dir(rb_n **t, rb_n *x)
     return 0;
 }
 
-int rb_seta_impr_elem(void (*i)(rb_n *n))
+int rb_seta_impr_elem(void (*i)(void *n))
 {
     rb_impr_elem = i;
 }
 
-void rb_pr(rb_n *a)
+void rb_pr(rb_n *a, int t)
 {
     if (a)
     {
-        if(a->c == BLACK)
-            printf("\033[44m\033[37mk:%dc:%d\033[0m ", a->k, a->c);
+        if (a->c == BLACK)
+        {
+            if(t == TCOLOR)
+                printf("\033[44m\033[37mk:%dc:%d\033[0m ", a->k, a->c);
+            else
+                printf("k:%dc:%d ", a->k, a->c);
+        }
         else
-            printf("\033[41m\033[37mk:%dc:%d\033[0m ", a->k, a->c);
-        rb_pr(a->l);
-        rb_pr(a->r);
+        {
+            if(t == TCOLOR)
+                printf("\033[41m\033[37mk:%dc:%d\033[0m ", a->k, a->c);
+            else
+                printf("k:%dc:%d ", a->k, a->c);
+        }
+        rb_pr(a->l, t);
+        rb_pr(a->r, t);
     }
 }
 
diff --git a/src/red_black.h b/src/red_black.h
index 2f93388..e1dc33d 100644
--- a/src/red_black.h
+++ b/src/red_black.h
@@ -8,10 +8,18 @@
 
 /**
  * definicao  do que eh considerado RED e BLACK
- * neste codigo para maior clareza
- */
+ * neste codigo para maior clareza, resolvi usar 
+ * enum no lugar de defines por ser mais seguro
 #define BLACK 0
 #define RED 1
+ */
+enum {BLACK = 0, RED};
+
+/**
+ * tipo de terminal se suporta formatacao e cor
+ * ou se eh monocromatico simples
+ */
+enum {TMONO, TCOLOR};
 
 /*
  * rubro negra
@@ -143,16 +151,18 @@ int rb_rot_dir(rb_n **t, rb_n *x);
 /**
  * imprime elemento como definido pelo o codigo cliente da biblioteca
  */
-extern void (*rb_impr_elem)(rb_n *);
+extern void (*rb_impr_elem)(void *);
 
 /**
  * seta a rotina de impressao do dado criado pelo cliente
  */
-int rb_seta_impr_elem(void (*i)(rb_n *n));
+int rb_seta_impr_elem(void (*i)(void *n));
 
 /**
- * imprime arvore @param a
+ * imprime arvore 
+ * @param a raiz
+ * @param t tipo de terminal
  */
-void rb_pr(rb_n *a);
+void rb_pr(rb_n *a, int t);
 
 #endif

commit 80948706d3ba9f67ac4b72ece8c7037b768ece50
Author: Joilnen <joilnen@gmail.com>
Date:   Thu Dec 23 21:11:25 2021 -0300

    pequenos ajustes

diff --git a/src/conjunto_ordenado.c b/src/conjunto_ordenado.c
index 93520af..921b7cd 100644
--- a/src/conjunto_ordenado.c
+++ b/src/conjunto_ordenado.c
@@ -68,10 +68,9 @@ void conjord_imprime_rb(rb_n *t, int s, int e)  {
         if(e == TCOLOR)
             printf("\033[41m\033[37mk:%dc:%d\033[0m\n", t->k, t->c);
         else
-            printf("k:%dc:%d\n", t->k, t->c);
+            printf("\033[47m\033[30mk:%dc:%d\033[0m\n", t->k, t->c);
     }
-  
-    // Process right child first  
+
     conjord_imprime_rb(t->l, s, e);  
 }  
 
diff --git a/src/red_black.c b/src/red_black.c
index 4e7dbbb..af583fe 100644
--- a/src/red_black.c
+++ b/src/red_black.c
@@ -402,7 +402,7 @@ void rb_pr(rb_n *a, int t)
             if(t == TCOLOR)
                 printf("\033[41m\033[37mk:%dc:%d\033[0m ", a->k, a->c);
             else
-                printf("k:%dc:%d ", a->k, a->c);
+                printf("\033[47m\033[30mk:%dc:%d\033[0m ", a->k, a->c);
         }
         rb_pr(a->l, t);
         rb_pr(a->r, t);

commit 8596eda2ccebd41d8d1a7e10e202e4f181be050e
Author: Joilnen <joilnen@gmail.com>
Date:   Fri Dec 24 05:35:16 2021 -0300

    formatacao

diff --git a/src/red_black.c b/src/red_black.c
index 4e7dbbb..2eeb88a 100644
--- a/src/red_black.c
+++ b/src/red_black.c
@@ -7,8 +7,19 @@
 #include "red_black.h"
 #include <stdio.h>
 
+/**
+ * ponteiro para funcao de impressao do tipo
+ * dado especificado pelo codigo cliente
+ * @param void * ponteiro dado especificado pelo
+ * o codigo cliente
+ */
 void (*rb_impr_elem)(void *);
 
+/**
+ * criacao do noh raiz
+ * @param k chave escolhida
+ * @param dado especificado pelo o codigo cliente
+ */
 rb_n* rb_cr(int key, void *dado)
 {
     rb_n *a = (rb_n *) malloc(sizeof(rb_n));
@@ -21,10 +32,16 @@ rb_n* rb_cr(int key, void *dado)
     return a;
 }
 
+/**
+ * @param a noh raiz
+ * @param k chave escolhida
+ * @param e dado especificado pelo o codigo cliente
+ */
 int rb_ins_elem(rb_n *a, int k, void *e)
 {
     rb_n *it = a;
     printf("k %d it->k %d\n", k, it->k);
+
     while (it)
     {
         rb_n *tmp = it;
@@ -172,6 +189,11 @@ static int rb_transplant(rb_n **t, rb_n *u, rb_n *v)
         v->p = u->p;
 }
 
+/**
+ * @param x noh raiz
+ * retorma o noh mais a esquerda na arvore 
+ * ou subarvore
+ */
 static rb_n *tree_minimum(rb_n *x)
 {
     rb_n *a = x;
@@ -203,7 +225,7 @@ static rb_n* sucessor(rb_n *x)
  */
 int rb_delete(rb_n **t, rb_n *z)
 {
-    rb_n *x;
+    rb_n *x = NULL;
     rb_n *y = z;
     unsigned char yoc;
 

commit fdc3d51313d507c1dd96c2c7c2f45c76dc4d6b69
Author: Joilnen <joilnen@gmail.com>
Date:   Fri Dec 24 06:43:59 2021 -0300

    adicionado escape code pra limpar a tela em vez da solucao
    ingenua anterior

diff --git a/src/conjunto_ordenado.h b/src/conjunto_ordenado.h
index 872dd50..6eabc30 100644
--- a/src/conjunto_ordenado.h
+++ b/src/conjunto_ordenado.h
@@ -95,6 +95,17 @@ conjord *conjord_subtrai(conjord *a, conjord *b);
  */
 void conjord_imprime_rb(rb_n *t, int s, int e);
 
+/**
+ * foi utlizado macro em vez de funcao
+ * pra evitar o footprint da chamada
+ * pois essa funcao limpa a tela e eh chamada
+ * varias a vezes eh preferivel q seja inline
+ * mas como n tem funcao inline usei a macro
+ * foi primeiro implementado com um loop
+ * mas pensando melhor dessa forma mais rapido
+ */
+#define LTELA printf("\033c");
+
 #endif
 
 
diff --git a/src/main.c b/src/main.c
index 89ce9d7..5643809 100644
--- a/src/main.c
+++ b/src/main.c
@@ -9,19 +9,6 @@
 #include <stdio.h>
 #include <string.h>
 
-/**
- * foi utlizado macro em vez de funcao
- * pra evitar o footprint da chamada
- * pois essa funcao limpa a tela e eh chamada
- * varias a vezes eh preferivel q seja inline
- * mas como n tem funcao inline usei a macro
- * foi primeiro implementado com um loop
- * mas pensando melhor dessa forma mais rapido
- */
-#define TELA_PADRAO_FULL 45
-static  char aux_pula_tela[TELA_PADRAO_FULL + 1];
-#define pula_tela() \
-    printf("%s", aux_pula_tela);
 /**
  * funcao  de impressao do dipo especifico criado pelo o usuario da biblioteca
  * @noh rb
@@ -33,9 +20,6 @@ void imprime_meu_tipo(void *);
  */
 int main()
 {
-    /** seta scroll da tela */
-    memset(aux_pula_tela, '\n', TELA_PADRAO_FULL);
-
     /**
      * definicao de um tipo exemplo pelo o usuario
      */
@@ -44,7 +28,6 @@ int main()
         char *telefone;
     } meu_tipo;
 
-
     /**
      * criacao do dado para o tipo do usuario
      */
@@ -68,7 +51,7 @@ int main()
      */
     rb_n *conjunto_a = rb_cr(10, &mt0);
 
-    pula_tela();
+    LTELA;
     rb_pr(conjunto_a, TCOLOR);
     printf("\n");
     printf("= arvore ===================\n");
@@ -89,7 +72,7 @@ int main()
 
     rb_insert(&conjunto_a, novo_noh);
 
-    pula_tela();
+    LTELA;
     rb_pr(conjunto_a, TCOLOR);
     printf("\n");
     printf("= arvore ===================\n");
@@ -109,7 +92,7 @@ int main()
     novo_noh->d = &mt2;
     rb_insert(&conjunto_a, novo_noh);
 
-    pula_tela();
+    LTELA;
     rb_pr(conjunto_a, TCOLOR);
     printf("\n");
     printf("= arvore ===================\n");
@@ -129,7 +112,7 @@ int main()
     novo_noh->d = &mt3;
     rb_insert(&conjunto_a, novo_noh);
 
-    pula_tela();
+    LTELA;
     rb_pr(conjunto_a, TCOLOR);
     printf("\n");
     printf("= arvore ===================\n");
@@ -149,7 +132,7 @@ int main()
     novo_noh->d = &mt4;
     rb_insert(&conjunto_a, novo_noh);
 
-    pula_tela();
+    LTELA;
     rb_pr(conjunto_a, TCOLOR);
     printf("\n");
     printf("= arvore ===================\n");
@@ -169,7 +152,7 @@ int main()
     novo_noh->d = &mt5;
     rb_insert(&conjunto_a, novo_noh);
 
-    pula_tela();
+    LTELA;
     rb_pr(conjunto_a, TCOLOR);
     printf("\n");
     printf("= arvore ===================\n");
@@ -188,7 +171,7 @@ int main()
     novo_noh->d = &mt6;
     rb_insert(&conjunto_a, novo_noh);
 
-    pula_tela();
+    LTELA;
     rb_pr(conjunto_a, TCOLOR);
     printf("\n");
     printf("= arvore ===================\n");
@@ -208,7 +191,7 @@ int main()
     novo_noh->d = &mt7;
     rb_insert(&conjunto_a, novo_noh);
 
-    pula_tela();
+    LTELA;
     rb_pr(conjunto_a, TCOLOR);
     printf("\n");
     printf("= arvore ===================\n");
@@ -219,7 +202,7 @@ int main()
 
     rb_delete(&conjunto_a, rb_search(conjunto_a, 3));
     printf("\n");
-    pula_tela();
+    LTELA;
     rb_pr(conjunto_a, TCOLOR);
     printf("\n");
     printf("= arvore ===================\n");
@@ -229,7 +212,7 @@ int main()
     getc(stdin);
 
     rb_delete(&conjunto_a, rb_search(conjunto_a, 11));
-    pula_tela();
+    LTELA;
     rb_pr(conjunto_a, TCOLOR);
     printf("\n");
     printf("= arvore ===================\n");
@@ -239,7 +222,7 @@ int main()
     getc(stdin);
 
     rb_delete(&conjunto_a, rb_search(conjunto_a, 4));
-    pula_tela();
+    LTELA;
     rb_pr(conjunto_a, TCOLOR);
     printf("\n");
     printf("= arvore ===================\n");
@@ -249,7 +232,7 @@ int main()
     getc(stdin);
 
     rb_delete(&conjunto_a, rb_search(conjunto_a, 8));
-    pula_tela();
+    LTELA;
     rb_pr(conjunto_a, TCOLOR);
     printf("\n");
     printf("= arvore ===================\n");
@@ -259,7 +242,7 @@ int main()
     getc(stdin);
 
     rb_delete(&conjunto_a, rb_search(conjunto_a, 9));
-    pula_tela();
+    LTELA;
     rb_pr(conjunto_a, TCOLOR);
     printf("\n");
     printf("= arvore ===================\n");
@@ -272,7 +255,7 @@ int main()
     rb_delete(&conjunto_a, rb_search(conjunto_a, 5));
     printf("\n");
 
-    pula_tela();
+    LTELA;
     rb_pr(conjunto_a, TCOLOR);
     printf("\n");
     printf("= arvore ===================\n");
@@ -281,7 +264,7 @@ int main()
     printf("* tecle enter *\n");
     getc(stdin);
     rb_delete(&conjunto_a, rb_search(conjunto_a, 6));
-    pula_tela();
+    LTELA;
     printf("\n nada\n");
     printf("= arvore ===================\n");
     conjord_imprime_rb(conjunto_a, 1, TCOLOR);
diff --git a/src/test_rb.c b/src/test_rb.c
new file mode 100644
index 0000000..e69de29

commit 12fb73c5f11b9f6992f06cdd7d3e03aa7433a924
Author: Joilnen <joilnen@gmail.com>
Date:   Fri Dec 24 07:42:35 2021 -0300

    brincando com codigos de tela

diff --git a/src/conjunto_ordenado.c b/src/conjunto_ordenado.c
index 921b7cd..29fb9d2 100644
--- a/src/conjunto_ordenado.c
+++ b/src/conjunto_ordenado.c
@@ -68,7 +68,7 @@ void conjord_imprime_rb(rb_n *t, int s, int e)  {
         if(e == TCOLOR)
             printf("\033[41m\033[37mk:%dc:%d\033[0m\n", t->k, t->c);
         else
-            printf("\033[47m\033[30mk:%dc:%d\033[0m\n", t->k, t->c);
+            printf("\033[7mk:%dc:%d\033[0m\n", t->k, t->c);
     }
 
     conjord_imprime_rb(t->l, s, e);  
diff --git a/src/red_black.c b/src/red_black.c
index af583fe..73886e4 100644
--- a/src/red_black.c
+++ b/src/red_black.c
@@ -402,7 +402,7 @@ void rb_pr(rb_n *a, int t)
             if(t == TCOLOR)
                 printf("\033[41m\033[37mk:%dc:%d\033[0m ", a->k, a->c);
             else
-                printf("\033[47m\033[30mk:%dc:%d\033[0m ", a->k, a->c);
+                printf("\033[7mk:%dc:%d\033[0m ", a->k, a->c);
         }
         rb_pr(a->l, t);
         rb_pr(a->r, t);

commit 310eb2fe1595966da5098ba34c3e661709092d00
Merge: 8596eda 12fb73c
Author: Joilnen <joilnen@gmail.com>
Date:   Fri Dec 24 13:44:01 2021 -0300

    Merge branch 'master' of 192.168.43.29:conjunto_ordenado

commit 5056ab458a2344e70f3eff78e007eb7c1b5cfd59
Author: Joilnen <joilnen@gmail.com>
Date:   Fri Dec 24 23:13:14 2021 -0300

    curses codes

diff --git a/src/conjunto_ordenado.c b/src/conjunto_ordenado.c
index 29fb9d2..dc8253d 100644
--- a/src/conjunto_ordenado.c
+++ b/src/conjunto_ordenado.c
@@ -31,6 +31,10 @@ int conjord_eh_vazio(const conjord *a)
     return !a->raiz;
 }
 
+/**
+ * deleta todos os elementos do 
+ * conjunto e zera a cardinalidade
+ */
 int conjord_esvazia(conjord *a)
 {
 
diff --git a/src/conjunto_ordenado.h b/src/conjunto_ordenado.h
index 6eabc30..3123fbb 100644
--- a/src/conjunto_ordenado.h
+++ b/src/conjunto_ordenado.h
@@ -1,6 +1,7 @@
 #ifndef CONJUNTO_ORDENADO_H
 #define CONJUNTO_ORDENADO_H
 
+#include "jcurses.h"
 #include "red_black.h"
 
 /**
@@ -104,7 +105,7 @@ void conjord_imprime_rb(rb_n *t, int s, int e);
  * foi primeiro implementado com um loop
  * mas pensando melhor dessa forma mais rapido
  */
-#define LTELA printf("\033c");
+#define LTELA printf(LIMPA_TELA);
 
 #endif
 
diff --git a/src/jcurses.h b/src/jcurses.h
new file mode 100644
index 0000000..5d082e2
--- /dev/null
+++ b/src/jcurses.h
@@ -0,0 +1,19 @@
+#ifndef JOILNEN_CURSES_H
+#define JOILNEN_CURSES_H
+
+/**
+ * marcros que criei baseado no que pesquisei
+ * sobre formatacao e codifificacao de terminal vt100
+ * que eh a base dos emuladores de terminal do linux
+ * curses eh como chamam o tipo de software q faz isso
+ * curses e ncurses sao exemplos, aqui eh soh uma tentativa
+ * primaria que atende as necessidades apenas dessa avaliacao
+ */
+
+#define LIMPA_TELA "\033c"
+#define S_AZUL "\033[44m\033[37m"
+#define S_VERM "\033[41m\033[37m"
+#define S_INV  "\033[7m"
+#define S_NORM "\033[0m"
+
+#endif
diff --git a/src/main.c b/src/main.c
index 5643809..1ec8a5a 100644
--- a/src/main.c
+++ b/src/main.c
@@ -252,10 +252,10 @@ int main()
     getc(stdin);
     rb_pr(conjunto_a, TCOLOR);
     printf("\n");
-    rb_delete(&conjunto_a, rb_search(conjunto_a, 5));
-    printf("\n");
 
+    rb_delete(&conjunto_a, rb_search(conjunto_a, 5));
     LTELA;
+    printf("\n");
     rb_pr(conjunto_a, TCOLOR);
     printf("\n");
     printf("= arvore ===================\n");
@@ -263,6 +263,7 @@ int main()
     printf("= ==========================\n");
     printf("* tecle enter *\n");
     getc(stdin);
+
     rb_delete(&conjunto_a, rb_search(conjunto_a, 6));
     LTELA;
     printf("\n nada\n");
diff --git a/src/red_black.c b/src/red_black.c
index 342edae..3789e76 100644
--- a/src/red_black.c
+++ b/src/red_black.c
@@ -4,6 +4,7 @@
  * de implementacao das funcoes da redblack 
  * utilizada no conjunto ordenado
  */
+#include "jcurses.h"
 #include "red_black.h"
 #include <stdio.h>
 
@@ -279,17 +280,20 @@ int rb_delete(rb_n **t, rb_n *z)
                     w = x->p->r;
                 }
 
-                if (w->l->c == BLACK && w->r->c == BLACK)
+                if ((w->l->c == BLACK && w->r->c == BLACK) || (w->l == BLACK && w->r == BLACK))
                 {
-                    w->c = RED;
+                    if(!w) w->c = RED;
                     x = x->p;
                 }
                 else
                 {
-                    if (w->r->c == BLACK)
+                    if (w->r == BLACK || w->r->c == BLACK)
                     {
-                        w->l->c = BLACK;
-                        w->c = RED;
+                        if (w)
+                        {
+                            w->l->c = BLACK;
+                            w->c = RED;
+                        }
                         rb_rot_dir(t, w);
                         w = x->p->r;
                     }
@@ -335,8 +339,11 @@ int rb_delete(rb_n **t, rb_n *z)
                 }
             }
         }
+        if(x) x->c = BLACK;
     } /* if (yoc == BLACK) */
 
+
+
     return 0;
 }
 
@@ -415,16 +422,16 @@ void rb_pr(rb_n *a, int t)
         if (a->c == BLACK)
         {
             if(t == TCOLOR)
-                printf("\033[44m\033[37mk:%dc:%d\033[0m ", a->k, a->c);
+                printf("%sk:%dc:%d%s ", S_AZUL, a->k, a->c, S_NORM);
             else
                 printf("k:%dc:%d ", a->k, a->c);
         }
         else
         {
-            if(t == TCOLOR)
-                printf("\033[41m\033[37mk:%dc:%d\033[0m ", a->k, a->c);
+            if (t == TCOLOR)
+                printf("%sk:%dc:%d%s ", S_VERM, a->k, a->c, S_NORM);
             else
-                printf("\033[7mk:%dc:%d\033[0m ", a->k, a->c);
+                printf("%sk:%dc:%d%s ", S_INV, a->k, a->c, S_NORM);
         }
         rb_pr(a->l, t);
         rb_pr(a->r, t);
diff --git a/src/test_rb.c b/src/test_rb.c
index e69de29..5643809 100644
--- a/src/test_rb.c
+++ b/src/test_rb.c
@@ -0,0 +1,290 @@
+/**
+ * aluno: joilnen leite
+ */
+
+/**
+ * inclusao da bilioteca implementada baseada em arvores red black
+ */
+#include "conjunto_ordenado.h"
+#include <stdio.h>
+#include <string.h>
+
+/**
+ * funcao  de impressao do dipo especifico criado pelo o usuario da biblioteca
+ * @noh rb
+ */
+void imprime_meu_tipo(void *);
+
+/**
+ * funcao main de teste separada do codigo da biblioteca como especificado
+ */
+int main()
+{
+    /**
+     * definicao de um tipo exemplo pelo o usuario
+     */
+    typedef struct {
+        char *nome;
+        char *telefone;
+    } meu_tipo;
+
+    /**
+     * criacao do dado para o tipo do usuario
+     */
+    meu_tipo mt0;
+    mt0.nome = (char *) malloc(sizeof("nome para teste") + 1);
+    strncpy(mt0.nome, "nome para teste", sizeof("nome para teste") + 1);
+    mt0.telefone = (char *) malloc(sizeof("999999999") + 1);
+    strncpy(mt0.telefone, "999999999", sizeof("999999999") + 1);
+
+    /**
+     * seta a funcao para impressao utiliza aqui a tecnica de ponteiro para funcao
+     */
+    rb_seta_impr_elem(imprime_meu_tipo);
+
+    /**
+     * cria noh raiz, utiliza a tecnica de macro pois simplifica e deixa
+     * uma interface mais intuitiva ao usuario da biblioteca
+     * @parametro 0 nome variavel do noh raiz
+     * @parametro 1 chave do noh raiz
+     * @parametro 2 dado criado neste noh, pode ser de qqr tipo
+     */
+    rb_n *conjunto_a = rb_cr(10, &mt0);
+
+    LTELA;
+    rb_pr(conjunto_a, TCOLOR);
+    printf("\n");
+    printf("= arvore ===================\n");
+    conjord_imprime_rb(conjunto_a, 1, TCOLOR);
+    printf("= ==========================\n");
+    printf("* tecle enter *\n");
+    getc(stdin);
+
+    meu_tipo mt1;
+    mt1.nome = (char *) malloc(sizeof("nome para teste") + 1);
+    strncpy(mt1.nome, "nome para teste", sizeof("nome para teste") + 1);
+    mt1.telefone = (char *) malloc(sizeof("999999999") + 1);
+    strncpy(mt1.telefone, "999999999", sizeof("999999999") + 1);
+
+    rb_n *novo_noh = (rb_n *) malloc (sizeof(rb_n));
+    novo_noh->k = 9;
+    novo_noh->d = &mt1;
+
+    rb_insert(&conjunto_a, novo_noh);
+
+    LTELA;
+    rb_pr(conjunto_a, TCOLOR);
+    printf("\n");
+    printf("= arvore ===================\n");
+    conjord_imprime_rb(conjunto_a, 1, TCOLOR);
+    printf("= ==========================\n");
+    printf("* tecle enter *\n");
+    getc(stdin);
+
+    meu_tipo mt2;
+    mt2.nome = (char *) malloc(sizeof("nome para teste") + 1);
+    strncpy(mt2.nome, "nome para teste", sizeof("nome para teste") + 1);
+    mt2.telefone = (char *) malloc(sizeof("999999999") + 1);
+    strncpy(mt2.telefone, "999999999", sizeof("999999999") + 1);
+
+    novo_noh = (rb_n *) malloc (sizeof(rb_n));
+    novo_noh->k = 11;
+    novo_noh->d = &mt2;
+    rb_insert(&conjunto_a, novo_noh);
+
+    LTELA;
+    rb_pr(conjunto_a, TCOLOR);
+    printf("\n");
+    printf("= arvore ===================\n");
+    conjord_imprime_rb(conjunto_a, 1, TCOLOR);
+    printf("= ==========================\n");
+    printf("* tecle enter *\n");
+    getc(stdin);
+
+    meu_tipo mt3;
+    mt3.nome = (char *) malloc(sizeof("nome para teste") + 1);
+    strncpy(mt3.nome, "nome para teste", sizeof("nome para teste") + 1);
+    mt3.telefone = (char *) malloc(sizeof("999999999") + 1);
+    strncpy(mt3.telefone, "999999999", sizeof("999999999") + 1);
+
+    novo_noh = (rb_n *) malloc (sizeof(rb_n));
+    novo_noh->k = 8;
+    novo_noh->d = &mt3;
+    rb_insert(&conjunto_a, novo_noh);
+
+    LTELA;
+    rb_pr(conjunto_a, TCOLOR);
+    printf("\n");
+    printf("= arvore ===================\n");
+    conjord_imprime_rb(conjunto_a, 1, TCOLOR);
+    printf("= ==========================\n");
+    printf("* tecle enter *\n");
+    getc(stdin);
+
+    meu_tipo mt4;
+    mt4.nome = (char *) malloc(sizeof("nome para teste") + 1);
+    strncpy(mt4.nome, "nome para teste", sizeof("nome para teste") + 1);
+    mt4.telefone = (char *) malloc(sizeof("999999999") + 1);
+    strncpy(mt4.telefone, "999999999", sizeof("999999999") + 1);
+
+    novo_noh = (rb_n *) malloc (sizeof(rb_n));
+    novo_noh->k = 6;
+    novo_noh->d = &mt4;
+    rb_insert(&conjunto_a, novo_noh);
+
+    LTELA;
+    rb_pr(conjunto_a, TCOLOR);
+    printf("\n");
+    printf("= arvore ===================\n");
+    conjord_imprime_rb(conjunto_a, 1, TCOLOR);
+    printf("= ==========================\n");
+    printf("* tecle enter *\n");
+    getc(stdin);
+
+    meu_tipo mt5;
+    mt5.nome = (char *) malloc(sizeof("nome para teste") + 1);
+    strncpy(mt5.nome, "nome para teste", sizeof("nome para teste") + 1);
+    mt5.telefone = (char *) malloc(sizeof("999999999") + 1);
+    strncpy(mt5.telefone, "999999999", sizeof("999999999") + 1);
+
+    novo_noh = (rb_n *) malloc (sizeof(rb_n));
+    novo_noh->k = 5;
+    novo_noh->d = &mt5;
+    rb_insert(&conjunto_a, novo_noh);
+
+    LTELA;
+    rb_pr(conjunto_a, TCOLOR);
+    printf("\n");
+    printf("= arvore ===================\n");
+    conjord_imprime_rb(conjunto_a, 1, TCOLOR);
+    printf("= ==========================\n");
+    printf("* tecle enter *\n");
+
+    meu_tipo mt6;
+    mt6.nome = (char *) malloc(sizeof("nome para teste") + 1);
+    strncpy(mt6.nome, "nome para teste", sizeof("nome para teste") + 1);
+    mt6.telefone = (char *) malloc(sizeof("999999999") + 1);
+    strncpy(mt6.telefone, "999999999", sizeof("999999999") + 1);
+
+    novo_noh = (rb_n *) malloc (sizeof(rb_n));
+    novo_noh->k = 4;
+    novo_noh->d = &mt6;
+    rb_insert(&conjunto_a, novo_noh);
+
+    LTELA;
+    rb_pr(conjunto_a, TCOLOR);
+    printf("\n");
+    printf("= arvore ===================\n");
+    conjord_imprime_rb(conjunto_a, 1, TCOLOR);
+    printf("= ==========================\n");
+    printf("* tecle enter *\n");
+    getc(stdin);
+
+    meu_tipo mt7;
+    mt7.nome = (char *) malloc(sizeof("nome para teste") + 1);
+    strncpy(mt7.nome, "nome para teste", sizeof("nome para teste") + 1);
+    mt7.telefone = (char *) malloc(sizeof("999999999") + 1);
+    strncpy(mt7.telefone, "999999999", sizeof("999999999") + 1);
+
+    novo_noh = (rb_n *) malloc (sizeof(rb_n));
+    novo_noh->k = 3;
+    novo_noh->d = &mt7;
+    rb_insert(&conjunto_a, novo_noh);
+
+    LTELA;
+    rb_pr(conjunto_a, TCOLOR);
+    printf("\n");
+    printf("= arvore ===================\n");
+    conjord_imprime_rb(conjunto_a, 1, TCOLOR);
+    printf("= ==========================\n");
+    printf("* tecle enter *\n");
+    getc(stdin);
+
+    rb_delete(&conjunto_a, rb_search(conjunto_a, 3));
+    printf("\n");
+    LTELA;
+    rb_pr(conjunto_a, TCOLOR);
+    printf("\n");
+    printf("= arvore ===================\n");
+    conjord_imprime_rb(conjunto_a, 1, TCOLOR);
+    printf("= ==========================\n");
+    printf("* tecle enter *\n");
+    getc(stdin);
+
+    rb_delete(&conjunto_a, rb_search(conjunto_a, 11));
+    LTELA;
+    rb_pr(conjunto_a, TCOLOR);
+    printf("\n");
+    printf("= arvore ===================\n");
+    conjord_imprime_rb(conjunto_a, 1, TCOLOR);
+    printf("= ==========================\n");
+    printf("* tecle enter *\n");
+    getc(stdin);
+
+    rb_delete(&conjunto_a, rb_search(conjunto_a, 4));
+    LTELA;
+    rb_pr(conjunto_a, TCOLOR);
+    printf("\n");
+    printf("= arvore ===================\n");
+    conjord_imprime_rb(conjunto_a, 1, TCOLOR);
+    printf("= ==========================\n");
+    printf("* tecle enter *\n");
+    getc(stdin);
+
+    rb_delete(&conjunto_a, rb_search(conjunto_a, 8));
+    LTELA;
+    rb_pr(conjunto_a, TCOLOR);
+    printf("\n");
+    printf("= arvore ===================\n");
+    conjord_imprime_rb(conjunto_a, 1, TCOLOR);
+    printf("= ==========================\n");
+    printf("* tecle enter *\n");
+    getc(stdin);
+
+    rb_delete(&conjunto_a, rb_search(conjunto_a, 9));
+    LTELA;
+    rb_pr(conjunto_a, TCOLOR);
+    printf("\n");
+    printf("= arvore ===================\n");
+    conjord_imprime_rb(conjunto_a, 1, TCOLOR);
+    printf("= ==========================\n");
+    printf("* tecle enter *\n");
+    getc(stdin);
+    rb_pr(conjunto_a, TCOLOR);
+    printf("\n");
+    rb_delete(&conjunto_a, rb_search(conjunto_a, 5));
+    printf("\n");
+
+    LTELA;
+    rb_pr(conjunto_a, TCOLOR);
+    printf("\n");
+    printf("= arvore ===================\n");
+    conjord_imprime_rb(conjunto_a, 1, TCOLOR);
+    printf("= ==========================\n");
+    printf("* tecle enter *\n");
+    getc(stdin);
+    rb_delete(&conjunto_a, rb_search(conjunto_a, 6));
+    LTELA;
+    printf("\n nada\n");
+    printf("= arvore ===================\n");
+    conjord_imprime_rb(conjunto_a, 1, TCOLOR);
+    printf("= ==========================\n");
+    rb_pr(conjunto_a, TCOLOR);
+    printf("\n");
+    /**
+     * testando apenas rb no momento
+    conjord *conj_a = conjord_cria();
+    printf("eh vazio %d", conjord_eh_vazio(conj_a));
+    */
+}
+
+/**
+ * definicao da funcao de impressao estipulado pelo cliente, aqui apenas um
+ * exemplo
+ */
+void imprime_meu_tipo(void *n)
+{
+
+}
+
+

commit 123cacce2fdd798913da438a59c6ab72fa7c7678
Author: Joilnen <joilnen@gmail.com>
Date:   Sat Dec 25 18:21:49 2021 -0300

    possibilidade de compilar do diretorio base

diff --git a/makefile b/makefile
new file mode 100644
index 0000000..2dbc0d8
--- /dev/null
+++ b/makefile
@@ -0,0 +1,7 @@
+all:
+	@make -C src
+	@mv src/rodeme .
+clean:
+	@make -C src clean
+
+

commit 8de643ddbfdc227b4ba939c13dc4f9f2cf329f96
Author: Joilnen <joilnen@gmail.com>
Date:   Tue Dec 28 18:19:28 2021 -0300

    sentinela

diff --git a/src/red_black.c b/src/red_black.c
index 3789e76..5c6060e 100644
--- a/src/red_black.c
+++ b/src/red_black.c
@@ -228,11 +228,10 @@ int rb_delete(rb_n **t, rb_n *z)
 {
     rb_n *x = NULL;
     rb_n *y = z;
-    unsigned char yoc;
+    unsigned char yoc = z->c;
 
     if (!z)
         return -1;
-    yoc = y->c;
 
     if (!z->l)
     {
@@ -280,7 +279,7 @@ int rb_delete(rb_n **t, rb_n *z)
                     w = x->p->r;
                 }
 
-                if ((w->l->c == BLACK && w->r->c == BLACK) || (w->l == BLACK && w->r == BLACK))
+                if (w->l->c == BLACK && w->r->c == BLACK) 
                 {
                     if(!w) w->c = RED;
                     x = x->p;
@@ -342,7 +341,132 @@ int rb_delete(rb_n **t, rb_n *z)
         if(x) x->c = BLACK;
     } /* if (yoc == BLACK) */
 
+    return 0;
+}
+
+/**
+ * deleta noh da arvore red black
+ * @param t ponteiro duplo para raiz, assim pq ele pode ser alterado dentro da funcao
+ * e manter a alteracao depois do retorno da fucao
+ * @param z ponteiro para o noh a ser deletado, para deletar por chave o TAD deve
+ * passar a saida da funcao pesquisar, num arranjo funcional na chamada
+ */
+int rb_delete_sentinela(rb_n **t, rb_n *z)
+{
+    rb_n *x = NULL;
+    rb_n *y = z;
+    unsigned char yoc = z->c;
+
+    if (!z)
+        return -1;
+
+    if (!z->l)
+    {
+        x = z->r;
+        rb_transplant(t, z, z->r);
+    }
+    else if (!z->r)
+    {
+        x = z->l;
+        rb_transplant(t, z, z->l);
+    }
+    else
+    {
+        // y = tree_minimum(z->r);
+        y = sucessor(z);
+        yoc = y->c;
+        x = y->r;
+        if (y->p == z)
+            if(x) x->p = y;
+        else
+        {
+            rb_transplant(t, y, y->r);
+            y->r = z->r;
+            y->r->p = y;
+        }
+        rb_transplant(t, z, y);
+        y->l = z->l;
+        y->l->p = y;
+        y->c = z->c;
+    }
+
+    if (yoc == BLACK)
+    {
+        rb_n *w;
+        while (x && x != *t && x->c == BLACK)
+        {
+            if (x == x->p->l)
+            {
+                w = x->p->r;
+                if (w->c == RED)
+                {
+                    w->c = BLACK;
+                    x->p->c = RED;
+                    rb_rot_esq(t, x->p);
+                    w = x->p->r;
+                }
+
+                if (w->l->c == BLACK && w->r->c == BLACK) 
+                {
+                    if(!w) w->c = RED;
+                    x = x->p;
+                }
+                else
+                {
+                    if (w->r == BLACK || w->r->c == BLACK)
+                    {
+                        if (w)
+                        {
+                            w->l->c = BLACK;
+                            w->c = RED;
+                        }
+                        rb_rot_dir(t, w);
+                        w = x->p->r;
+                    }
 
+                    w->c = x->p->c;
+                    x->p->c = BLACK;
+                    w->r->c = BLACK;
+                    rb_rot_esq(t, x->p);
+                    x = *t;
+                }
+            }
+            else 
+            {
+                w = x->p->l;
+                if (w->c == RED)
+                {
+                    w->c = BLACK;
+                    x->p->c = RED;
+                    rb_rot_esq(t, x->p);
+                    w = x->p->l;
+                }
+
+                if (w->r->c == BLACK && w->l->c == BLACK)
+                {
+                    w->c = RED;
+                    x = x->p;
+                }
+                else
+                {
+                    if (w->l->c == BLACK)
+                    {
+                        w->r->c = BLACK;
+                        w->c = RED;
+                        rb_rot_dir(t, w);
+                        w = x->p->l;
+                    }
+
+                    w->c = x->p->c;
+                    x->p->c = BLACK;
+                    w->l->c = BLACK;
+                    rb_rot_esq(t, x->p);
+                    x = *t;
+                }
+            }
+        }
+        if(x) x->c = BLACK;
+    } /* if (yoc == BLACK) */
 
     return 0;
 }
@@ -458,4 +582,38 @@ rb_n *rb_search(rb_n *t, int k)
     return  NULL;
 }
 
+void rb_converte_null_sentinela(rb_n *t, rb_n *sentinela)
+{
+    if(t)
+    {
+
+        if(!t->p)
+        {
+            t->p = sentinela;
+            t->sentinela = 1;
+        }
+        rb_converte_null_sentinela(t->l, sentinela);
+        rb_converte_null_sentinela(t->r, sentinela);
+    }
+
+    t = sentinela;
+}
 
+void rb_converte_sentinela_null(rb_n *t)
+{
+    rb_n *tmp;
+    if(t)
+    {
+
+        if(t->p->sentinela)
+        {
+            tmp = t->p;
+            t->p = NULL;
+        }
+        rb_converte_sentinela_null(t->l);
+        rb_converte_sentinela_null(t->r);
+    }
+
+    t = NULL;
+    free(tmp);
+}
diff --git a/src/red_black.h b/src/red_black.h
index e1dc33d..a42e6ae 100644
--- a/src/red_black.h
+++ b/src/red_black.h
@@ -13,13 +13,13 @@
 #define BLACK 0
 #define RED 1
  */
-enum {BLACK = 0, RED};
+typedef enum cor_noh {BLACK = 0, RED} cor_noh;
 
 /**
  * tipo de terminal se suporta formatacao e cor
  * ou se eh monocromatico simples
  */
-enum {TMONO, TCOLOR};
+typedef enum tipo_screen {TMONO, TCOLOR} tipo_screen;
 
 /*
  * rubro negra
@@ -46,6 +46,7 @@ typedef struct rb_n {
     unsigned char c:1;
     void *d;
     unsigned int np;
+    unsigned char sentinela:1;
     struct rb_n *l, *r, *p;
 } rb_n;
 
@@ -88,6 +89,13 @@ rb_n *rb_search(rb_n *t, int k);
  */
 int rb_delete(rb_n **t, rb_n *z);
 
+/**
+ * tc
+ * @param a noh raiz da arvore
+ * @param b elemento a ser deletado
+ */
+int rb_delete_sentinela(rb_n **t, rb_n *z);
+
 /**
  * @param a noh raiz da arvore
  * @param k chave do elemento a ser excluido
@@ -165,4 +173,8 @@ int rb_seta_impr_elem(void (*i)(void *n));
  */
 void rb_pr(rb_n *a, int t);
 
+void rb_convert_null_sentinela(rb_n *t, rb_n *sentinela);
+
+void rb_converte_sentinela_null(rb_n *t);
+
 #endif

commit 68d97c470fd681c78bc6ae068187825218bd6d0d
Author: Joilnen <joilnen@gmail.com>
Date:   Wed Dec 29 09:30:29 2021 -0300

    tentando adaptar sem sentinela mas vou fazer um fork, isso aqui parece
    q soh vai com sentinela mesmo

diff --git a/src/red_black.c b/src/red_black.c
index 5c6060e..d53fc09 100644
--- a/src/red_black.c
+++ b/src/red_black.c
@@ -217,6 +217,19 @@ static rb_n* sucessor(rb_n *x)
     return y;
 }
 
+static int checa_tmp_node(rb_n *n)
+{
+    return !!(n->l || n->r || n->p);
+}
+
+static void store_tmp_node(rb_n *n, rb_n *a, lr i)
+{
+    n->l = a->l;
+    n->r = a->r;
+    n->p = a->p;
+    n->dclr = i;
+}
+
 /**
  * deleta noh da arvore red black
  * @param t ponteiro duplo para raiz, assim pq ele pode ser alterado dentro da funcao
@@ -226,9 +239,13 @@ static rb_n* sucessor(rb_n *x)
  */
 int rb_delete(rb_n **t, rb_n *z)
 {
-    rb_n *x = NULL;
+    rb_n *x = NULL, tmp;
     rb_n *y = z;
     unsigned char yoc = z->c;
+    tmp.l = tmp.r = tmp.p = NULL;
+    tmp.c = 0;
+
+    printf("TMP ST %d\n", checa_tmp_node(&tmp));
 
     if (!z)
         return -1;
@@ -237,11 +254,15 @@ int rb_delete(rb_n **t, rb_n *z)
     {
         x = z->r;
         rb_transplant(t, z, z->r);
+        if(!x)
+            store_tmp_node(&tmp, z, RIGHT);
     }
     else if (!z->r)
     {
         x = z->l;
         rb_transplant(t, z, z->l);
+        if(!x)
+            store_tmp_node(&tmp, z, LEFT);
     }
     else
     {
@@ -582,7 +603,7 @@ rb_n *rb_search(rb_n *t, int k)
     return  NULL;
 }
 
-void rb_converte_null_sentinela(rb_n *t, rb_n *sentinela)
+static void rb_converte_null_sentinela(rb_n *t, rb_n *sentinela)
 {
     if(t)
     {
@@ -599,12 +620,11 @@ void rb_converte_null_sentinela(rb_n *t, rb_n *sentinela)
     t = sentinela;
 }
 
-void rb_converte_sentinela_null(rb_n *t)
+static void rb_converte_sentinela_null(rb_n *t)
 {
     rb_n *tmp;
     if(t)
     {
-
         if(t->p->sentinela)
         {
             tmp = t->p;
diff --git a/src/red_black.h b/src/red_black.h
index a42e6ae..20694f2 100644
--- a/src/red_black.h
+++ b/src/red_black.h
@@ -47,6 +47,7 @@ typedef struct rb_n {
     void *d;
     unsigned int np;
     unsigned char sentinela:1;
+    unsigned char dclr:1;
     struct rb_n *l, *r, *p;
 } rb_n;
 
@@ -173,8 +174,6 @@ int rb_seta_impr_elem(void (*i)(void *n));
  */
 void rb_pr(rb_n *a, int t);
 
-void rb_convert_null_sentinela(rb_n *t, rb_n *sentinela);
-
-void rb_converte_sentinela_null(rb_n *t);
+typedef enum lr {LEFT, RIGHT} lr;
 
 #endif

commit 64a8e76f859d276f8c23350c60b1b4b16bfbb027
Author: Joilnen <joilnen@gmail.com>
Date:   Wed Dec 29 14:05:30 2021 -0300

    alterando o noh rb_n para ser tb sentinela

diff --git a/src/red_black.c b/src/red_black.c
index d53fc09..62cfbb6 100644
--- a/src/red_black.c
+++ b/src/red_black.c
@@ -227,7 +227,6 @@ static void store_tmp_node(rb_n *n, rb_n *a, lr i)
     n->l = a->l;
     n->r = a->r;
     n->p = a->p;
-    n->dclr = i;
 }
 
 /**
@@ -603,37 +602,4 @@ rb_n *rb_search(rb_n *t, int k)
     return  NULL;
 }
 
-static void rb_converte_null_sentinela(rb_n *t, rb_n *sentinela)
-{
-    if(t)
-    {
-
-        if(!t->p)
-        {
-            t->p = sentinela;
-            t->sentinela = 1;
-        }
-        rb_converte_null_sentinela(t->l, sentinela);
-        rb_converte_null_sentinela(t->r, sentinela);
-    }
-
-    t = sentinela;
-}
 
-static void rb_converte_sentinela_null(rb_n *t)
-{
-    rb_n *tmp;
-    if(t)
-    {
-        if(t->p->sentinela)
-        {
-            tmp = t->p;
-            t->p = NULL;
-        }
-        rb_converte_sentinela_null(t->l);
-        rb_converte_sentinela_null(t->r);
-    }
-
-    t = NULL;
-    free(tmp);
-}
diff --git a/src/red_black.h b/src/red_black.h
index 20694f2..fc748d7 100644
--- a/src/red_black.h
+++ b/src/red_black.h
@@ -46,8 +46,7 @@ typedef struct rb_n {
     unsigned char c:1;
     void *d;
     unsigned int np;
-    unsigned char sentinela:1;
-    unsigned char dclr:1;
+    unsigned char s:1;
     struct rb_n *l, *r, *p;
 } rb_n;
 

commit 84ead572bcbbf623785881f78432bcb1af757579
Author: Joilnen <joilnen@gmail.com>
Date:   Wed Dec 29 15:15:13 2021 -0300

    insercao parcialmente funcionando, problema na rotacao

diff --git a/src/conjunto_ordenado.c b/src/conjunto_ordenado.c
index dc8253d..fca731f 100644
--- a/src/conjunto_ordenado.c
+++ b/src/conjunto_ordenado.c
@@ -48,7 +48,7 @@ int conjord_esvazia(conjord *a)
  */
 void conjord_imprime_rb(rb_n *t, int s, int e)  {  
     const int dist =  8;
-    if (!t)
+    if (t == &rb_s)
         return;  
   
     s += dist;  
diff --git a/src/red_black.c b/src/red_black.c
index 62cfbb6..6b49d3a 100644
--- a/src/red_black.c
+++ b/src/red_black.c
@@ -8,6 +8,8 @@
 #include "red_black.h"
 #include <stdio.h>
 
+rb_n rb_s;
+
 /**
  * ponteiro para funcao de impressao do tipo
  * dado especificado pelo codigo cliente
@@ -28,7 +30,7 @@ rb_n* rb_cr(int key, void *dado)
     /** raiz sempre colorida com preto */
     a->c = BLACK;
     a->d = dado;
-    a->p = a->l = a->r = NULL;
+    a->p = a->l = a->r = &rb_s;
 
     return a;
 }
@@ -92,7 +94,7 @@ int rb_insert(rb_n **t, rb_n *z)
      * itera para chegar no noh folha
      * da posicao a ser inserido o novo noh
      */
-    while (x)
+    while (x != &rb_s)
     {
         y = x;
         if (z->k < x->k)
@@ -113,17 +115,17 @@ int rb_insert(rb_n **t, rb_n *z)
      * caso n adiciona na esquera ou diretia de acordo
      * com o valor da chave, noh recebe RED como padrao
      */
-    if (!y)
+    if (y == &rb_s)
         *t = z;
     else if (z->k < y->k)
         y->l = z;
     else
         y->r = z;
-    z->l = z->r = NULL;
+    z->l = z->r = &rb_s;
     z->c = RED;
 
     /** ajuste */
-    while (z && z->p && z->p->c == RED)
+    while (z->p->c == RED)
     {
         if (z->p == z->p->p->l)
         {
@@ -561,7 +563,7 @@ int rb_seta_impr_elem(void (*i)(void *n))
 
 void rb_pr(rb_n *a, int t)
 {
-    if (a)
+    if (a != &rb_s)
     {
         if (a->c == BLACK)
         {
diff --git a/src/red_black.h b/src/red_black.h
index fc748d7..bb03965 100644
--- a/src/red_black.h
+++ b/src/red_black.h
@@ -46,10 +46,11 @@ typedef struct rb_n {
     unsigned char c:1;
     void *d;
     unsigned int np;
-    unsigned char s:1;
     struct rb_n *l, *r, *p;
 } rb_n;
 
+extern rb_n rb_s;
+
 /**
  * cria o primeiro noh, a raiz da arvore rb,
  */

commit b3d1cc6a37af68e53b11dcf10edf90174b381dde
Author: Joilnen <joilnen@gmail.com>
Date:   Wed Dec 29 15:25:28 2021 -0300

    insersao parece estar funcionando perfeitamente nos primeiros testes

diff --git a/src/red_black.c b/src/red_black.c
index 6b49d3a..0b68eed 100644
--- a/src/red_black.c
+++ b/src/red_black.c
@@ -130,7 +130,7 @@ int rb_insert(rb_n **t, rb_n *z)
         if (z->p == z->p->p->l)
         {
             y = z->p->p->r;
-            if (y && y->c == RED)
+            if (y->c == RED)
             {
                 z->p->c = BLACK;
                 y->c = BLACK;
@@ -152,7 +152,7 @@ int rb_insert(rb_n **t, rb_n *z)
         else
         {
             y = z->p->p->l;
-            if (y && y->c == RED)
+            if (y->c == RED)
             {
                 z->p->c = BLACK;
                 y->c = BLACK;
@@ -522,10 +522,10 @@ int rb_rot_esq(rb_n **t, rb_n *x)
 {
     rb_n *y = x->r;
     x->r = y->l;
-    if (y->l)
+    if (y->l != &rb_s)
         y->l->p = x;
     y->p = x->p;
-    if (!x->p)
+    if (x->p == &rb_s)
         *t = y;
     else if (x == x->p->l)
         x->p->l = y;
@@ -541,10 +541,10 @@ int rb_rot_dir(rb_n **t, rb_n *x)
 {
     rb_n *y = x->l;
     x->l = y->r;
-    if (y->r)
+    if (y->r != &rb_s)
         y->r->p = x;
     y->p = x->p;
-    if (!x->p)
+    if (x->p == &rb_s)
         *t = y;
     else if (x == x->p->r)
         x->p->r = y;

commit 9ea8ca45abd9ae5d9368a30fac3bf96450f4a25a
Author: Joilnen <joilnen@gmail.com>
Date:   Wed Dec 29 15:34:51 2021 -0300

    delecao funcionando parcialmente, estamos quase lah

diff --git a/src/red_black.c b/src/red_black.c
index 0b68eed..941b75b 100644
--- a/src/red_black.c
+++ b/src/red_black.c
@@ -212,7 +212,7 @@ static rb_n *tree_minimum(rb_n *x)
 static rb_n* sucessor(rb_n *x)
 {
     rb_n *y = NULL;
-    if (x->r)
+    if (x->r != &rb_s)
         return tree_minimum(x->r);
     while ((y = x->p) && x == y->r)
         x = y;
@@ -240,30 +240,22 @@ static void store_tmp_node(rb_n *n, rb_n *a, lr i)
  */
 int rb_delete(rb_n **t, rb_n *z)
 {
-    rb_n *x = NULL, tmp;
+    rb_n *x = NULL;
     rb_n *y = z;
     unsigned char yoc = z->c;
-    tmp.l = tmp.r = tmp.p = NULL;
-    tmp.c = 0;
-
-    printf("TMP ST %d\n", checa_tmp_node(&tmp));
 
     if (!z)
         return -1;
 
-    if (!z->l)
+    if (z->l == &rb_s)
     {
         x = z->r;
         rb_transplant(t, z, z->r);
-        if(!x)
-            store_tmp_node(&tmp, z, RIGHT);
     }
-    else if (!z->r)
+    else if (z->r == &rb_s)
     {
         x = z->l;
         rb_transplant(t, z, z->l);
-        if(!x)
-            store_tmp_node(&tmp, z, LEFT);
     }
     else
     {
@@ -288,7 +280,7 @@ int rb_delete(rb_n **t, rb_n *z)
     if (yoc == BLACK)
     {
         rb_n *w;
-        while (x && x != *t && x->c == BLACK)
+        while (x != *t && x->c == BLACK)
         {
             if (x == x->p->l)
             {

commit 8aaabc8098fde34f4f475865244abf2efb496d41
Author: Joilnen <joilnen@gmail.com>
Date:   Wed Dec 29 15:58:16 2021 -0300

    delecao balanceada soh q ainda dando crash pelo o caminho

diff --git a/src/red_black.c b/src/red_black.c
index 941b75b..0811b52 100644
--- a/src/red_black.c
+++ b/src/red_black.c
@@ -31,6 +31,7 @@ rb_n* rb_cr(int key, void *dado)
     a->c = BLACK;
     a->d = dado;
     a->p = a->l = a->r = &rb_s;
+    rb_s.c = BLACK;
 
     return a;
 }
@@ -182,7 +183,7 @@ int rb_insert(rb_n **t, rb_n *z)
  */
 static int rb_transplant(rb_n **t, rb_n *u, rb_n *v)
 {
-    if (!u->p)
+    if (u->p == &rb_s)
         *t = v;
     else if (u == u->p->l)
         u->p->l = v;
@@ -295,18 +296,15 @@ int rb_delete(rb_n **t, rb_n *z)
 
                 if (w->l->c == BLACK && w->r->c == BLACK) 
                 {
-                    if(!w) w->c = RED;
+                    w->c = RED;
                     x = x->p;
                 }
                 else
                 {
-                    if (w->r == BLACK || w->r->c == BLACK)
+                    if (w->r->c == BLACK)
                     {
-                        if (w)
-                        {
-                            w->l->c = BLACK;
-                            w->c = RED;
-                        }
+                        w->l->c = BLACK;
+                        w->c = RED;
                         rb_rot_dir(t, w);
                         w = x->p->r;
                     }
@@ -352,7 +350,7 @@ int rb_delete(rb_n **t, rb_n *z)
                 }
             }
         }
-        if(x) x->c = BLACK;
+        x->c = BLACK;
     } /* if (yoc == BLACK) */
 
     return 0;

commit ff44c15422a577e6b3258939e150e312af618cef
Author: Joilnen <joilnen@gmail.com>
Date:   Wed Dec 29 17:37:59 2021 -0300

    ainda crash na delecao da raiz o resto parece ok

diff --git a/src/red_black.c b/src/red_black.c
index 0811b52..3759161 100644
--- a/src/red_black.c
+++ b/src/red_black.c
@@ -88,7 +88,7 @@ int rb_insert(rb_n **t, rb_n *z)
      * x eh um ponteiro temporario para iteracao feita 
      * no loop while a seguir para chegar ao noh folha
      */
-    rb_n *y = NULL;
+    rb_n *y = &rb_s;
     rb_n *x = *t;
 
     /**
@@ -241,13 +241,10 @@ static void store_tmp_node(rb_n *n, rb_n *a, lr i)
  */
 int rb_delete(rb_n **t, rb_n *z)
 {
-    rb_n *x = NULL;
+    rb_n *x = &rb_s;
     rb_n *y = z;
     unsigned char yoc = z->c;
 
-    if (!z)
-        return -1;
-
     if (z->l == &rb_s)
     {
         x = z->r;
@@ -265,7 +262,7 @@ int rb_delete(rb_n **t, rb_n *z)
         yoc = y->c;
         x = y->r;
         if (y->p == z)
-            if(x) x->p = y;
+            x->p = y;
         else
         {
             rb_transplant(t, y, y->r);
@@ -327,7 +324,7 @@ int rb_delete(rb_n **t, rb_n *z)
                     w = x->p->l;
                 }
 
-                if (w->r->c == BLACK && w->l->c == BLACK)
+                if (w->l->c == BLACK && w->r->c == BLACK)
                 {
                     w->c = RED;
                     x = x->p;
@@ -580,7 +577,7 @@ rb_n *rb_search(rb_n *t, int k)
     rb_n *y = NULL;
     rb_n *x = t;
 
-    while (x)
+    while (x != &rb_s)
     {
         y = x;
         if (k < x->k)

commit 452006fcf48e44136678029d86c4a1cad5944a26
Author: Joilnen <joilnen@gmail.com>
Date:   Wed Dec 29 18:49:22 2021 -0300

    ainda brigando com a delecao da raiz

diff --git a/src/red_black.c b/src/red_black.c
index 3759161..a93e3d1 100644
--- a/src/red_black.c
+++ b/src/red_black.c
@@ -201,7 +201,7 @@ static int rb_transplant(rb_n **t, rb_n *u, rb_n *v)
 static rb_n *tree_minimum(rb_n *x)
 {
     rb_n *a = x;
-    while (a->l)
+    while (a->l != &rb_s)
         a = a->l;
     return a;
 }

commit b0a40b4714920a831b9362d79e5017ae2b10d06d
Author: Joilnen <joilnen@gmail.com>
Date:   Wed Dec 29 23:44:40 2021 -0300

    delecao quase lah

diff --git a/src/red_black.c b/src/red_black.c
index a93e3d1..d9f7152 100644
--- a/src/red_black.c
+++ b/src/red_black.c
@@ -277,7 +277,7 @@ int rb_delete(rb_n **t, rb_n *z)
 
     if (yoc == BLACK)
     {
-        rb_n *w;
+        rb_n *w = &rb_s;
         while (x != *t && x->c == BLACK)
         {
             if (x == x->p->l)
@@ -320,7 +320,7 @@ int rb_delete(rb_n **t, rb_n *z)
                 {
                     w->c = BLACK;
                     x->p->c = RED;
-                    rb_rot_esq(t, x->p);
+                    rb_rot_dir(t, x->p);
                     w = x->p->l;
                 }
 
@@ -335,14 +335,14 @@ int rb_delete(rb_n **t, rb_n *z)
                     {
                         w->r->c = BLACK;
                         w->c = RED;
-                        rb_rot_dir(t, w);
+                        rb_rot_esq(t, w);
                         w = x->p->l;
                     }
 
                     w->c = x->p->c;
                     x->p->c = BLACK;
                     w->l->c = BLACK;
-                    rb_rot_esq(t, x->p);
+                    rb_rot_dir(t, x->p);
                     x = *t;
                 }
             }

commit 32b6a153983658cc85d3c17622e41c4526cd2441
Author: Joilnen <joilnen@gmail.com>
Date:   Wed Dec 29 23:51:33 2021 -0300

    red black funcionando insersao e delecao

diff --git a/src/main.c b/src/main.c
index 1ec8a5a..dac212b 100644
--- a/src/main.c
+++ b/src/main.c
@@ -264,6 +264,17 @@ int main()
     printf("* tecle enter *\n");
     getc(stdin);
 
+    rb_delete(&conjunto_a, rb_search(conjunto_a, 10));
+    LTELA;
+    printf("\n");
+    rb_pr(conjunto_a, TCOLOR);
+    printf("\n");
+    printf("= arvore ===================\n");
+    conjord_imprime_rb(conjunto_a, 1, TCOLOR);
+    printf("= ==========================\n");
+    printf("* tecle enter *\n");
+    getc(stdin);
+
     rb_delete(&conjunto_a, rb_search(conjunto_a, 6));
     LTELA;
     printf("\n nada\n");

commit 1c3c7ea4e1cbf507294591afe704724095bb010f
Author: Joilnen <joilnen@gmail.com>
Date:   Wed Dec 29 23:58:12 2021 -0300

    apenas formatacao

diff --git a/src/main.c b/src/main.c
index dac212b..5d9c197 100644
--- a/src/main.c
+++ b/src/main.c
@@ -255,7 +255,6 @@ int main()
 
     rb_delete(&conjunto_a, rb_search(conjunto_a, 5));
     LTELA;
-    printf("\n");
     rb_pr(conjunto_a, TCOLOR);
     printf("\n");
     printf("= arvore ===================\n");
@@ -266,7 +265,6 @@ int main()
 
     rb_delete(&conjunto_a, rb_search(conjunto_a, 10));
     LTELA;
-    printf("\n");
     rb_pr(conjunto_a, TCOLOR);
     printf("\n");
     printf("= arvore ===================\n");
@@ -277,7 +275,7 @@ int main()
 
     rb_delete(&conjunto_a, rb_search(conjunto_a, 6));
     LTELA;
-    printf("\n nada\n");
+    printf("nada\n");
     printf("= arvore ===================\n");
     conjord_imprime_rb(conjunto_a, 1, TCOLOR);
     printf("= ==========================\n");

commit c7934628e33c6d959bcb20c78dbc3705ce2be729
Author: Joilnen <joilnen@gmail.com>
Date:   Thu Dec 30 00:30:14 2021 -0300

    limpando o codigo

diff --git a/src/red_black.c b/src/red_black.c
index d9f7152..aba04c7 100644
--- a/src/red_black.c
+++ b/src/red_black.c
@@ -8,6 +8,10 @@
 #include "red_black.h"
 #include <stdio.h>
 
+/**
+ * definicao do noh sentinela
+ * @param rb_s red black noh setinela
+ */
 rb_n rb_s;
 
 /**
@@ -220,18 +224,6 @@ static rb_n* sucessor(rb_n *x)
     return y;
 }
 
-static int checa_tmp_node(rb_n *n)
-{
-    return !!(n->l || n->r || n->p);
-}
-
-static void store_tmp_node(rb_n *n, rb_n *a, lr i)
-{
-    n->l = a->l;
-    n->r = a->r;
-    n->p = a->p;
-}
-
 /**
  * deleta noh da arvore red black
  * @param t ponteiro duplo para raiz, assim pq ele pode ser alterado dentro da funcao
@@ -353,133 +345,6 @@ int rb_delete(rb_n **t, rb_n *z)
     return 0;
 }
 
-/**
- * deleta noh da arvore red black
- * @param t ponteiro duplo para raiz, assim pq ele pode ser alterado dentro da funcao
- * e manter a alteracao depois do retorno da fucao
- * @param z ponteiro para o noh a ser deletado, para deletar por chave o TAD deve
- * passar a saida da funcao pesquisar, num arranjo funcional na chamada
- */
-int rb_delete_sentinela(rb_n **t, rb_n *z)
-{
-    rb_n *x = NULL;
-    rb_n *y = z;
-    unsigned char yoc = z->c;
-
-    if (!z)
-        return -1;
-
-    if (!z->l)
-    {
-        x = z->r;
-        rb_transplant(t, z, z->r);
-    }
-    else if (!z->r)
-    {
-        x = z->l;
-        rb_transplant(t, z, z->l);
-    }
-    else
-    {
-        // y = tree_minimum(z->r);
-        y = sucessor(z);
-        yoc = y->c;
-        x = y->r;
-        if (y->p == z)
-            if(x) x->p = y;
-        else
-        {
-            rb_transplant(t, y, y->r);
-            y->r = z->r;
-            y->r->p = y;
-        }
-        rb_transplant(t, z, y);
-        y->l = z->l;
-        y->l->p = y;
-        y->c = z->c;
-    }
-
-    if (yoc == BLACK)
-    {
-        rb_n *w;
-        while (x && x != *t && x->c == BLACK)
-        {
-            if (x == x->p->l)
-            {
-                w = x->p->r;
-                if (w->c == RED)
-                {
-                    w->c = BLACK;
-                    x->p->c = RED;
-                    rb_rot_esq(t, x->p);
-                    w = x->p->r;
-                }
-
-                if (w->l->c == BLACK && w->r->c == BLACK) 
-                {
-                    if(!w) w->c = RED;
-                    x = x->p;
-                }
-                else
-                {
-                    if (w->r == BLACK || w->r->c == BLACK)
-                    {
-                        if (w)
-                        {
-                            w->l->c = BLACK;
-                            w->c = RED;
-                        }
-                        rb_rot_dir(t, w);
-                        w = x->p->r;
-                    }
-
-                    w->c = x->p->c;
-                    x->p->c = BLACK;
-                    w->r->c = BLACK;
-                    rb_rot_esq(t, x->p);
-                    x = *t;
-                }
-            }
-            else 
-            {
-                w = x->p->l;
-                if (w->c == RED)
-                {
-                    w->c = BLACK;
-                    x->p->c = RED;
-                    rb_rot_esq(t, x->p);
-                    w = x->p->l;
-                }
-
-                if (w->r->c == BLACK && w->l->c == BLACK)
-                {
-                    w->c = RED;
-                    x = x->p;
-                }
-                else
-                {
-                    if (w->l->c == BLACK)
-                    {
-                        w->r->c = BLACK;
-                        w->c = RED;
-                        rb_rot_dir(t, w);
-                        w = x->p->l;
-                    }
-
-                    w->c = x->p->c;
-                    x->p->c = BLACK;
-                    w->l->c = BLACK;
-                    rb_rot_esq(t, x->p);
-                    x = *t;
-                }
-            }
-        }
-        if(x) x->c = BLACK;
-    } /* if (yoc == BLACK) */
-
-    return 0;
-}
-
 int rb_exclui_elem(rb_n *a, int k)
 {
     return 0;
diff --git a/src/red_black.h b/src/red_black.h
index bb03965..111fd31 100644
--- a/src/red_black.h
+++ b/src/red_black.h
@@ -49,6 +49,9 @@ typedef struct rb_n {
     struct rb_n *l, *r, *p;
 } rb_n;
 
+/**
+ * noh sentinela
+ */
 extern rb_n rb_s;
 
 /**
@@ -90,13 +93,6 @@ rb_n *rb_search(rb_n *t, int k);
  */
 int rb_delete(rb_n **t, rb_n *z);
 
-/**
- * tc
- * @param a noh raiz da arvore
- * @param b elemento a ser deletado
- */
-int rb_delete_sentinela(rb_n **t, rb_n *z);
-
 /**
  * @param a noh raiz da arvore
  * @param k chave do elemento a ser excluido
@@ -174,6 +170,4 @@ int rb_seta_impr_elem(void (*i)(void *n));
  */
 void rb_pr(rb_n *a, int t);
 
-typedef enum lr {LEFT, RIGHT} lr;
-
 #endif

commit 398f6159236bfc1afdce05486676f845aec2cd0b
Author: Joilnen <joilnen@gmail.com>
Date:   Thu Dec 30 10:02:06 2021 -0300

    alterando o codigo de limpar a tela para funcionar em terminais vt100 com
    o minimo de recursos

diff --git a/src/jcurses.h b/src/jcurses.h
index 5d082e2..3a8e187 100644
--- a/src/jcurses.h
+++ b/src/jcurses.h
@@ -10,7 +10,7 @@
  * primaria que atende as necessidades apenas dessa avaliacao
  */
 
-#define LIMPA_TELA "\033c"
+#define LIMPA_TELA "\033[H\033[J"
 #define S_AZUL "\033[44m\033[37m"
 #define S_VERM "\033[41m\033[37m"
 #define S_INV  "\033[7m"

commit eaf427d19d12261327af53fcd63a5b77cfcf0825
Author: Joilnen <joilnen@gmail.com>
Date:   Thu Dec 30 10:30:07 2021 -0300

    movendo o codigo de teste para um arquivo e funcao separados do main

diff --git a/src/main.c b/src/main.c
index 5d9c197..bbf1231 100644
--- a/src/main.c
+++ b/src/main.c
@@ -1,300 +1,12 @@
 /**
  * aluno: joilnen leite
  */
+#include "testa_rb.h"
 
-/**
- * inclusao da bilioteca implementada baseada em arvores red black
- */
-#include "conjunto_ordenado.h"
-#include <stdio.h>
-#include <string.h>
-
-/**
- * funcao  de impressao do dipo especifico criado pelo o usuario da biblioteca
- * @noh rb
- */
-void imprime_meu_tipo(void *);
-
-/**
- * funcao main de teste separada do codigo da biblioteca como especificado
- */
 int main()
 {
-    /**
-     * definicao de um tipo exemplo pelo o usuario
-     */
-    typedef struct {
-        char *nome;
-        char *telefone;
-    } meu_tipo;
-
-    /**
-     * criacao do dado para o tipo do usuario
-     */
-    meu_tipo mt0;
-    mt0.nome = (char *) malloc(sizeof("nome para teste") + 1);
-    strncpy(mt0.nome, "nome para teste", sizeof("nome para teste") + 1);
-    mt0.telefone = (char *) malloc(sizeof("999999999") + 1);
-    strncpy(mt0.telefone, "999999999", sizeof("999999999") + 1);
-
-    /**
-     * seta a funcao para impressao utiliza aqui a tecnica de ponteiro para funcao
-     */
-    rb_seta_impr_elem(imprime_meu_tipo);
-
-    /**
-     * cria noh raiz, utiliza a tecnica de macro pois simplifica e deixa
-     * uma interface mais intuitiva ao usuario da biblioteca
-     * @parametro 0 nome variavel do noh raiz
-     * @parametro 1 chave do noh raiz
-     * @parametro 2 dado criado neste noh, pode ser de qqr tipo
-     */
-    rb_n *conjunto_a = rb_cr(10, &mt0);
-
-    LTELA;
-    rb_pr(conjunto_a, TCOLOR);
-    printf("\n");
-    printf("= arvore ===================\n");
-    conjord_imprime_rb(conjunto_a, 1, TCOLOR);
-    printf("= ==========================\n");
-    printf("* tecle enter *\n");
-    getc(stdin);
-
-    meu_tipo mt1;
-    mt1.nome = (char *) malloc(sizeof("nome para teste") + 1);
-    strncpy(mt1.nome, "nome para teste", sizeof("nome para teste") + 1);
-    mt1.telefone = (char *) malloc(sizeof("999999999") + 1);
-    strncpy(mt1.telefone, "999999999", sizeof("999999999") + 1);
-
-    rb_n *novo_noh = (rb_n *) malloc (sizeof(rb_n));
-    novo_noh->k = 9;
-    novo_noh->d = &mt1;
-
-    rb_insert(&conjunto_a, novo_noh);
-
-    LTELA;
-    rb_pr(conjunto_a, TCOLOR);
-    printf("\n");
-    printf("= arvore ===================\n");
-    conjord_imprime_rb(conjunto_a, 1, TCOLOR);
-    printf("= ==========================\n");
-    printf("* tecle enter *\n");
-    getc(stdin);
-
-    meu_tipo mt2;
-    mt2.nome = (char *) malloc(sizeof("nome para teste") + 1);
-    strncpy(mt2.nome, "nome para teste", sizeof("nome para teste") + 1);
-    mt2.telefone = (char *) malloc(sizeof("999999999") + 1);
-    strncpy(mt2.telefone, "999999999", sizeof("999999999") + 1);
-
-    novo_noh = (rb_n *) malloc (sizeof(rb_n));
-    novo_noh->k = 11;
-    novo_noh->d = &mt2;
-    rb_insert(&conjunto_a, novo_noh);
-
-    LTELA;
-    rb_pr(conjunto_a, TCOLOR);
-    printf("\n");
-    printf("= arvore ===================\n");
-    conjord_imprime_rb(conjunto_a, 1, TCOLOR);
-    printf("= ==========================\n");
-    printf("* tecle enter *\n");
-    getc(stdin);
-
-    meu_tipo mt3;
-    mt3.nome = (char *) malloc(sizeof("nome para teste") + 1);
-    strncpy(mt3.nome, "nome para teste", sizeof("nome para teste") + 1);
-    mt3.telefone = (char *) malloc(sizeof("999999999") + 1);
-    strncpy(mt3.telefone, "999999999", sizeof("999999999") + 1);
-
-    novo_noh = (rb_n *) malloc (sizeof(rb_n));
-    novo_noh->k = 8;
-    novo_noh->d = &mt3;
-    rb_insert(&conjunto_a, novo_noh);
-
-    LTELA;
-    rb_pr(conjunto_a, TCOLOR);
-    printf("\n");
-    printf("= arvore ===================\n");
-    conjord_imprime_rb(conjunto_a, 1, TCOLOR);
-    printf("= ==========================\n");
-    printf("* tecle enter *\n");
-    getc(stdin);
-
-    meu_tipo mt4;
-    mt4.nome = (char *) malloc(sizeof("nome para teste") + 1);
-    strncpy(mt4.nome, "nome para teste", sizeof("nome para teste") + 1);
-    mt4.telefone = (char *) malloc(sizeof("999999999") + 1);
-    strncpy(mt4.telefone, "999999999", sizeof("999999999") + 1);
-
-    novo_noh = (rb_n *) malloc (sizeof(rb_n));
-    novo_noh->k = 6;
-    novo_noh->d = &mt4;
-    rb_insert(&conjunto_a, novo_noh);
+    testa_arvore_rb();
 
-    LTELA;
-    rb_pr(conjunto_a, TCOLOR);
-    printf("\n");
-    printf("= arvore ===================\n");
-    conjord_imprime_rb(conjunto_a, 1, TCOLOR);
-    printf("= ==========================\n");
-    printf("* tecle enter *\n");
-    getc(stdin);
-
-    meu_tipo mt5;
-    mt5.nome = (char *) malloc(sizeof("nome para teste") + 1);
-    strncpy(mt5.nome, "nome para teste", sizeof("nome para teste") + 1);
-    mt5.telefone = (char *) malloc(sizeof("999999999") + 1);
-    strncpy(mt5.telefone, "999999999", sizeof("999999999") + 1);
-
-    novo_noh = (rb_n *) malloc (sizeof(rb_n));
-    novo_noh->k = 5;
-    novo_noh->d = &mt5;
-    rb_insert(&conjunto_a, novo_noh);
-
-    LTELA;
-    rb_pr(conjunto_a, TCOLOR);
-    printf("\n");
-    printf("= arvore ===================\n");
-    conjord_imprime_rb(conjunto_a, 1, TCOLOR);
-    printf("= ==========================\n");
-    printf("* tecle enter *\n");
-
-    meu_tipo mt6;
-    mt6.nome = (char *) malloc(sizeof("nome para teste") + 1);
-    strncpy(mt6.nome, "nome para teste", sizeof("nome para teste") + 1);
-    mt6.telefone = (char *) malloc(sizeof("999999999") + 1);
-    strncpy(mt6.telefone, "999999999", sizeof("999999999") + 1);
-
-    novo_noh = (rb_n *) malloc (sizeof(rb_n));
-    novo_noh->k = 4;
-    novo_noh->d = &mt6;
-    rb_insert(&conjunto_a, novo_noh);
-
-    LTELA;
-    rb_pr(conjunto_a, TCOLOR);
-    printf("\n");
-    printf("= arvore ===================\n");
-    conjord_imprime_rb(conjunto_a, 1, TCOLOR);
-    printf("= ==========================\n");
-    printf("* tecle enter *\n");
-    getc(stdin);
-
-    meu_tipo mt7;
-    mt7.nome = (char *) malloc(sizeof("nome para teste") + 1);
-    strncpy(mt7.nome, "nome para teste", sizeof("nome para teste") + 1);
-    mt7.telefone = (char *) malloc(sizeof("999999999") + 1);
-    strncpy(mt7.telefone, "999999999", sizeof("999999999") + 1);
-
-    novo_noh = (rb_n *) malloc (sizeof(rb_n));
-    novo_noh->k = 3;
-    novo_noh->d = &mt7;
-    rb_insert(&conjunto_a, novo_noh);
-
-    LTELA;
-    rb_pr(conjunto_a, TCOLOR);
-    printf("\n");
-    printf("= arvore ===================\n");
-    conjord_imprime_rb(conjunto_a, 1, TCOLOR);
-    printf("= ==========================\n");
-    printf("* tecle enter *\n");
-    getc(stdin);
-
-    rb_delete(&conjunto_a, rb_search(conjunto_a, 3));
-    printf("\n");
-    LTELA;
-    rb_pr(conjunto_a, TCOLOR);
-    printf("\n");
-    printf("= arvore ===================\n");
-    conjord_imprime_rb(conjunto_a, 1, TCOLOR);
-    printf("= ==========================\n");
-    printf("* tecle enter *\n");
-    getc(stdin);
-
-    rb_delete(&conjunto_a, rb_search(conjunto_a, 11));
-    LTELA;
-    rb_pr(conjunto_a, TCOLOR);
-    printf("\n");
-    printf("= arvore ===================\n");
-    conjord_imprime_rb(conjunto_a, 1, TCOLOR);
-    printf("= ==========================\n");
-    printf("* tecle enter *\n");
-    getc(stdin);
-
-    rb_delete(&conjunto_a, rb_search(conjunto_a, 4));
-    LTELA;
-    rb_pr(conjunto_a, TCOLOR);
-    printf("\n");
-    printf("= arvore ===================\n");
-    conjord_imprime_rb(conjunto_a, 1, TCOLOR);
-    printf("= ==========================\n");
-    printf("* tecle enter *\n");
-    getc(stdin);
-
-    rb_delete(&conjunto_a, rb_search(conjunto_a, 8));
-    LTELA;
-    rb_pr(conjunto_a, TCOLOR);
-    printf("\n");
-    printf("= arvore ===================\n");
-    conjord_imprime_rb(conjunto_a, 1, TCOLOR);
-    printf("= ==========================\n");
-    printf("* tecle enter *\n");
-    getc(stdin);
-
-    rb_delete(&conjunto_a, rb_search(conjunto_a, 9));
-    LTELA;
-    rb_pr(conjunto_a, TCOLOR);
-    printf("\n");
-    printf("= arvore ===================\n");
-    conjord_imprime_rb(conjunto_a, 1, TCOLOR);
-    printf("= ==========================\n");
-    printf("* tecle enter *\n");
-    getc(stdin);
-    rb_pr(conjunto_a, TCOLOR);
-    printf("\n");
-
-    rb_delete(&conjunto_a, rb_search(conjunto_a, 5));
-    LTELA;
-    rb_pr(conjunto_a, TCOLOR);
-    printf("\n");
-    printf("= arvore ===================\n");
-    conjord_imprime_rb(conjunto_a, 1, TCOLOR);
-    printf("= ==========================\n");
-    printf("* tecle enter *\n");
-    getc(stdin);
-
-    rb_delete(&conjunto_a, rb_search(conjunto_a, 10));
-    LTELA;
-    rb_pr(conjunto_a, TCOLOR);
-    printf("\n");
-    printf("= arvore ===================\n");
-    conjord_imprime_rb(conjunto_a, 1, TCOLOR);
-    printf("= ==========================\n");
-    printf("* tecle enter *\n");
-    getc(stdin);
-
-    rb_delete(&conjunto_a, rb_search(conjunto_a, 6));
-    LTELA;
-    printf("nada\n");
-    printf("= arvore ===================\n");
-    conjord_imprime_rb(conjunto_a, 1, TCOLOR);
-    printf("= ==========================\n");
-    rb_pr(conjunto_a, TCOLOR);
-    printf("\n");
-    /**
-     * testando apenas rb no momento
-    conjord *conj_a = conjord_cria();
-    printf("eh vazio %d", conjord_eh_vazio(conj_a));
-    */
-}
-
-/**
- * definicao da funcao de impressao estipulado pelo cliente, aqui apenas um
- * exemplo
- */
-void imprime_meu_tipo(void *n)
-{
+    return 0;
 
 }
-
-
diff --git a/src/makefile b/src/makefile
index d201161..944ed46 100644
--- a/src/makefile
+++ b/src/makefile
@@ -3,8 +3,8 @@
 #
 
 C=gcc
-S=main.c conjunto_ordenado.c red_black.c
-O=main.o conjunto_ordenado.o red_black.o
+S=main.c conjunto_ordenado.c red_black.c testa_rb.c
+O=main.o conjunto_ordenado.o red_black.o testa_rb.o
 E=rodeme
 D=-g
 
diff --git a/src/test_rb.c b/src/testa_rb.c
similarity index 96%
rename from src/test_rb.c
rename to src/testa_rb.c
index 5643809..1a7a74e 100644
--- a/src/test_rb.c
+++ b/src/testa_rb.c
@@ -18,7 +18,7 @@ void imprime_meu_tipo(void *);
 /**
  * funcao main de teste separada do codigo da biblioteca como especificado
  */
-int main()
+int testa_arvore_rb()
 {
     /**
      * definicao de um tipo exemplo pelo o usuario
@@ -252,9 +252,18 @@ int main()
     getc(stdin);
     rb_pr(conjunto_a, TCOLOR);
     printf("\n");
+
     rb_delete(&conjunto_a, rb_search(conjunto_a, 5));
+    LTELA;
+    rb_pr(conjunto_a, TCOLOR);
     printf("\n");
+    printf("= arvore ===================\n");
+    conjord_imprime_rb(conjunto_a, 1, TCOLOR);
+    printf("= ==========================\n");
+    printf("* tecle enter *\n");
+    getc(stdin);
 
+    rb_delete(&conjunto_a, rb_search(conjunto_a, 10));
     LTELA;
     rb_pr(conjunto_a, TCOLOR);
     printf("\n");
@@ -263,9 +272,10 @@ int main()
     printf("= ==========================\n");
     printf("* tecle enter *\n");
     getc(stdin);
+
     rb_delete(&conjunto_a, rb_search(conjunto_a, 6));
     LTELA;
-    printf("\n nada\n");
+    printf("nada\n");
     printf("= arvore ===================\n");
     conjord_imprime_rb(conjunto_a, 1, TCOLOR);
     printf("= ==========================\n");
diff --git a/src/testa_rb.h b/src/testa_rb.h
new file mode 100644
index 0000000..30e4996
--- /dev/null
+++ b/src/testa_rb.h
@@ -0,0 +1,16 @@
+#ifndef TESTA_ARVORE_RB_
+#define TESTA_ARVORE_RB_
+
+/**
+ * aluno: joilnen leite
+ */
+
+/**
+ * declaracao da funcao de teste da 
+ * arvore vermelha e preta
+ */
+void testa_arvore_rb();
+
+#endif
+
+

commit 8aa14fa10cf9a1d58625af816d910fcce337f228
Author: Joilnen <joilnen@gmail.com>
Date:   Thu Dec 30 10:50:34 2021 -0300

    funcao insere noh retorna erro se ja existe chave igual, foi apagado
    codigo de uma funcao insere antiga que funcionava mas sem sentinela
    q eh como estamos usando agora

diff --git a/src/red_black.c b/src/red_black.c
index aba04c7..54afdad 100644
--- a/src/red_black.c
+++ b/src/red_black.c
@@ -40,48 +40,6 @@ rb_n* rb_cr(int key, void *dado)
     return a;
 }
 
-/**
- * @param a noh raiz
- * @param k chave escolhida
- * @param e dado especificado pelo o codigo cliente
- */
-int rb_ins_elem(rb_n *a, int k, void *e)
-{
-    rb_n *it = a;
-    printf("k %d it->k %d\n", k, it->k);
-
-    while (it)
-    {
-        rb_n *tmp = it;
-        int rl = 0;
-        if (k < it->k)
-            it = it->l, rl = !!0;
-        else if (k > it->k)
-            it = it->r, rl = !0;
-        else return -1;
-
-        printf("rl %d\n", rl);
-
-        if (!it)
-        {
-            it = (rb_n *) malloc(sizeof(rb_n));
-            it->d = e;
-            it->k = k;
-            /** cor vermelha por default na insercao */
-            it->c = 1;
-            it->l = it->r = NULL;
-
-            if (rl & 0)
-                tmp->l = it;
-            else 
-                tmp->r = it;
-            return 0;
-        }
-    }
-
-    return -1;
-}
-
 /**
  * inclusao baseado no livro do cormen
  */
@@ -104,8 +62,10 @@ int rb_insert(rb_n **t, rb_n *z)
         y = x;
         if (z->k < x->k)
             x = x->l;
-        else
+        else if (z->k > x->k)
             x = x->r;
+        else
+            return -1;
     }
 
     /**
@@ -178,6 +138,8 @@ int rb_insert(rb_n **t, rb_n *z)
         }
     }
     (*t)->c = BLACK;
+
+    return 0;
 }
 
 /**
diff --git a/src/red_black.h b/src/red_black.h
index 111fd31..6b6c1ce 100644
--- a/src/red_black.h
+++ b/src/red_black.h
@@ -65,13 +65,6 @@ rb_n* rb_cr(int key, void *dado);
  */
 unsigned int rb_nelem(rb_n *a);
 
-/**
- * @param a noh raiz da arvore
- * @param k chave do elemento a ser inserido
- * @param e tipo generico de dado a ser guardado neste noh
- */
-int rb_ins_elem(rb_n *a, int k, void *e);
-
 /**
  * tc
  * @param a noh raiz da arvore
diff --git a/src/testa_rb.c b/src/testa_rb.c
index 1a7a74e..09dbc3e 100644
--- a/src/testa_rb.c
+++ b/src/testa_rb.c
@@ -60,13 +60,27 @@ int testa_arvore_rb()
     printf("* tecle enter *\n");
     getc(stdin);
 
+    meu_tipo mt8;
+    mt8.nome = (char *) malloc(sizeof("nome para teste") + 1);
+    strncpy(mt8.nome, "nome para teste", sizeof("nome para teste") + 1);
+    mt8.telefone = (char *) malloc(sizeof("999999999") + 1);
+    strncpy(mt8.telefone, "999999999", sizeof("999999999") + 1);
+
+    rb_n *novo_noh = (rb_n *) malloc (sizeof(rb_n));
+    novo_noh->k = 9;
+    novo_noh->d = &mt8;
+
+    rb_insert(&conjunto_a, novo_noh);
+
+
+
     meu_tipo mt1;
     mt1.nome = (char *) malloc(sizeof("nome para teste") + 1);
     strncpy(mt1.nome, "nome para teste", sizeof("nome para teste") + 1);
     mt1.telefone = (char *) malloc(sizeof("999999999") + 1);
     strncpy(mt1.telefone, "999999999", sizeof("999999999") + 1);
 
-    rb_n *novo_noh = (rb_n *) malloc (sizeof(rb_n));
+    novo_noh = (rb_n *) malloc (sizeof(rb_n));
     novo_noh->k = 9;
     novo_noh->d = &mt1;
 

commit 94a049df392c385e8e97dc8530f8a66268f16609
Author: Joilnen <joilnen@gmail.com>
Date:   Thu Dec 30 13:02:44 2021 -0300

    reestruturando main e funcoes auxiliares para chamar testes sobre o TAD

diff --git a/src/conjunto_ordenado.h b/src/conjunto_ordenado.h
index 3123fbb..9ea7863 100644
--- a/src/conjunto_ordenado.h
+++ b/src/conjunto_ordenado.h
@@ -10,7 +10,7 @@
  * suas funcoes e funcionamento interno do cliente
  * expondo apenas funcoes e operacoes com semantica
  * relativa ao uso do cliente aqui nesta avaliacao
- * conjunto ordenado as operacpes e funcoes
+ * conjunto ordenado as operacoes e funcoes
  * exigidas no documento da avaliacao para este TAD
  */
 typedef struct conjord {
diff --git a/src/main.c b/src/main.c
index bbf1231..70e64d5 100644
--- a/src/main.c
+++ b/src/main.c
@@ -1,12 +1,77 @@
 /**
  * aluno: joilnen leite
  */
+#include <stdio.h>
+#include "testa_item_1.h"
+#include "testa_item_2.h"
+#include "testa_item_3.h"
 #include "testa_rb.h"
+#include "jcurses.h"
+
+/**
+ * estas funcoes mostram testes referentes
+ * aos itens da avaliacao
+ */
+static void tela_item_1();
+static void tela_item_2();
+static void tela_item_3();
+static void tela_testa_rb();
 
 int main()
 {
-    testa_arvore_rb();
+    char op, nitems = 4;
+
+    /**
+     * aqui poderia ser escrito 
+     * "case 0:
+     *      tela_item_1();
+     *      getc(stdin);
+     *      testa_item_1();
+     *      break;
+     * "
+     * em um unico swtich mas assim ficou mais legivel 
+     * e limpo
+     */
+    for (op = 0; op < nitems; ++op)
+    {
+        switch (op)
+        {
+            case 0: tela_item_1(); break;
+            case 1: tela_item_2(); break;
+            case 2: tela_item_3(); break;
+            case 3: tela_testa_rb();
+        }
+        getc(stdin);
+        switch (op)
+        {
+            case 0: testa_item_1(); break;
+            case 1: testa_item_1(); break;
+            case 2: testa_item_1(); break;
+            case 3: testa_arvore_rb();
+        }
+    }
 
     return 0;
+}
 
+void tela_item_1()
+{
+    printf("Testa item 1\n");
+}
+
+void tela_item_2()
+{
+    printf("Testa item 2\n");
 }
+
+void tela_item_3()
+{
+    printf("Testa item 3\n");
+}
+
+void tela_testa_rb()
+{
+    printf("Testa rb\n");
+}
+
+
diff --git a/src/makefile b/src/makefile
index 944ed46..94af2b5 100644
--- a/src/makefile
+++ b/src/makefile
@@ -3,8 +3,10 @@
 #
 
 C=gcc
-S=main.c conjunto_ordenado.c red_black.c testa_rb.c
-O=main.o conjunto_ordenado.o red_black.o testa_rb.o
+S=main.c conjunto_ordenado.c red_black.c testa_rb.c \
+  testa_item_1.c testa_item_2.c testa_item_3.c
+O=main.o conjunto_ordenado.o red_black.o testa_rb.o \
+  testa_item_1.o testa_item_2.o testa_item_3.o
 E=rodeme
 D=-g
 
@@ -15,3 +17,4 @@ all: $(O)
 clean:
 	rm -f *.o $(E)
 
+
diff --git a/src/red_black.c b/src/red_black.c
index 54afdad..96a1c53 100644
--- a/src/red_black.c
+++ b/src/red_black.c
@@ -2,7 +2,7 @@
  * aluno: joilnen leite
  * arquivo separado do main, como especificado 
  * de implementacao das funcoes da redblack 
- * utilizada no conjunto ordenado
+ * utilizada como base no TAD conjunto ordenado
  */
 #include "jcurses.h"
 #include "red_black.h"
diff --git a/src/testa_item_1.c b/src/testa_item_1.c
new file mode 100644
index 0000000..5fab149
--- /dev/null
+++ b/src/testa_item_1.c
@@ -0,0 +1,8 @@
+#include "testa_item_1.h"
+
+void testa_item_1()
+{
+
+}
+
+
diff --git a/src/testa_item_1.h b/src/testa_item_1.h
new file mode 100644
index 0000000..38d9cb8
--- /dev/null
+++ b/src/testa_item_1.h
@@ -0,0 +1,7 @@
+#ifndef TESTA_ITEM_1_H_
+#define TESTA_ITEM_1_H_
+
+void testa_item_1();
+
+#endif
+
diff --git a/src/testa_item_2.c b/src/testa_item_2.c
new file mode 100644
index 0000000..56c9478
--- /dev/null
+++ b/src/testa_item_2.c
@@ -0,0 +1,7 @@
+#include "testa_item_2.h"
+
+void testa_item_2()
+{
+
+}
+
diff --git a/src/testa_item_2.h b/src/testa_item_2.h
new file mode 100644
index 0000000..8f0417b
--- /dev/null
+++ b/src/testa_item_2.h
@@ -0,0 +1,7 @@
+#ifndef TESTA_ITEM_2_H_
+#define TESTA_ITEM_2_H_
+
+void testa_item_2();
+
+#endif
+
diff --git a/src/testa_item_3.c b/src/testa_item_3.c
new file mode 100644
index 0000000..c68e970
--- /dev/null
+++ b/src/testa_item_3.c
@@ -0,0 +1,7 @@
+#include "testa_item_3.h"
+
+void testa_item_3()
+{
+
+}
+
diff --git a/src/testa_item_3.h b/src/testa_item_3.h
new file mode 100644
index 0000000..db34708
--- /dev/null
+++ b/src/testa_item_3.h
@@ -0,0 +1,7 @@
+#ifndef TESTA_ITEM_3_H_
+#define TESTA_ITEM_3_H_
+
+void testa_item_3();
+
+#endif
+

commit e3e7e67ff083119e7ba2aa7840cd92f5e2e3508e
Author: Joilnen <joilnen@gmail.com>
Date:   Thu Dec 30 13:38:39 2021 -0300

    organizando codigo de testes

diff --git a/src/main.c b/src/main.c
index 70e64d5..87e586b 100644
--- a/src/main.c
+++ b/src/main.c
@@ -2,25 +2,27 @@
  * aluno: joilnen leite
  */
 #include <stdio.h>
-#include "testa_item_1.h"
-#include "testa_item_2.h"
-#include "testa_item_3.h"
-#include "testa_rb.h"
-#include "jcurses.h"
+#include "testa.h"
 
 /**
  * estas funcoes mostram testes referentes
  * aos itens da avaliacao
+ * sao pares com testa_item*
  */
-static void tela_item_1();
-static void tela_item_2();
-static void tela_item_3();
-static void tela_testa_rb();
+static void tela_item_1(const char *m);
+static void tela_item_2(const char *m);
+static void tela_item_3(const char *m);
+static void tela_testa_rb(const char *m);
 
 int main()
 {
     char op, nitems = 4;
 
+    /**
+     * mensagem de controle
+     */
+    const char mc[] = "* tecle enter *";
+
     /**
      * aqui poderia ser escrito 
      * "case 0:
@@ -36,42 +38,46 @@ int main()
     {
         switch (op)
         {
-            case 0: tela_item_1(); break;
-            case 1: tela_item_2(); break;
-            case 2: tela_item_3(); break;
-            case 3: tela_testa_rb();
+            case 0: tela_item_1(mc); break;
+            case 1: tela_item_2(mc); break;
+            case 2: tela_item_3(mc); break;
+            case 3: tela_testa_rb(mc);
         }
         getc(stdin);
         switch (op)
         {
-            case 0: testa_item_1(); break;
-            case 1: testa_item_1(); break;
-            case 2: testa_item_1(); break;
-            case 3: testa_arvore_rb();
+            case 0: testa_item_1(mc); break;
+            case 1: testa_item_1(mc); break;
+            case 2: testa_item_1(mc); break;
+            case 3: testa_arvore_rb(mc);
         }
     }
 
     return 0;
 }
 
-void tela_item_1()
+void tela_item_1(const char *m)
 {
-    printf("Testa item 1\n");
+    printf("Sera efetuado testes do item 1\n");
+    printf("%s\n", m);
 }
 
-void tela_item_2()
+void tela_item_2(const char *m)
 {
     printf("Testa item 2\n");
+    printf("%s\n", m);
 }
 
-void tela_item_3()
+void tela_item_3(const char *m)
 {
     printf("Testa item 3\n");
+    printf("%s\n", m);
 }
 
-void tela_testa_rb()
+void tela_testa_rb(const char *m)
 {
     printf("Testa rb\n");
+    printf("%s\n", m);
 }
 
 
diff --git a/src/testa.h b/src/testa.h
new file mode 100644
index 0000000..494ed68
--- /dev/null
+++ b/src/testa.h
@@ -0,0 +1,11 @@
+#ifndef TESTA_H_
+#define TESTA_H_
+
+#include "jcurses.h"
+#include "testa_item_1.h"
+#include "testa_item_2.h"
+#include "testa_item_3.h"
+#include "testa_rb.h"
+
+#endif
+
diff --git a/src/testa_item_1.c b/src/testa_item_1.c
index 5fab149..87127d4 100644
--- a/src/testa_item_1.c
+++ b/src/testa_item_1.c
@@ -1,6 +1,6 @@
 #include "testa_item_1.h"
 
-void testa_item_1()
+void testa_item_1(const char *m)
 {
 
 }
diff --git a/src/testa_item_1.h b/src/testa_item_1.h
index 38d9cb8..095609e 100644
--- a/src/testa_item_1.h
+++ b/src/testa_item_1.h
@@ -1,7 +1,7 @@
 #ifndef TESTA_ITEM_1_H_
 #define TESTA_ITEM_1_H_
 
-void testa_item_1();
+void testa_item_1(const char *m);
 
 #endif
 
diff --git a/src/testa_item_2.c b/src/testa_item_2.c
index 56c9478..9ba76fc 100644
--- a/src/testa_item_2.c
+++ b/src/testa_item_2.c
@@ -1,6 +1,6 @@
 #include "testa_item_2.h"
 
-void testa_item_2()
+void testa_item_2(const char *m)
 {
 
 }
diff --git a/src/testa_item_2.h b/src/testa_item_2.h
index 8f0417b..e674e4c 100644
--- a/src/testa_item_2.h
+++ b/src/testa_item_2.h
@@ -1,7 +1,7 @@
 #ifndef TESTA_ITEM_2_H_
 #define TESTA_ITEM_2_H_
 
-void testa_item_2();
+void testa_item_2(const char *m);
 
 #endif
 
diff --git a/src/testa_item_3.c b/src/testa_item_3.c
index c68e970..032dbbf 100644
--- a/src/testa_item_3.c
+++ b/src/testa_item_3.c
@@ -1,6 +1,6 @@
 #include "testa_item_3.h"
 
-void testa_item_3()
+void testa_item_3(const char *m)
 {
 
 }
diff --git a/src/testa_item_3.h b/src/testa_item_3.h
index db34708..e1a9564 100644
--- a/src/testa_item_3.h
+++ b/src/testa_item_3.h
@@ -1,7 +1,7 @@
 #ifndef TESTA_ITEM_3_H_
 #define TESTA_ITEM_3_H_
 
-void testa_item_3();
+void testa_item_3(const char *m);
 
 #endif
 
diff --git a/src/testa_rb.c b/src/testa_rb.c
index 09dbc3e..60f20cf 100644
--- a/src/testa_rb.c
+++ b/src/testa_rb.c
@@ -18,7 +18,7 @@ void imprime_meu_tipo(void *);
 /**
  * funcao main de teste separada do codigo da biblioteca como especificado
  */
-int testa_arvore_rb()
+int testa_arvore_rb(const char *m)
 {
     /**
      * definicao de um tipo exemplo pelo o usuario
diff --git a/src/testa_rb.h b/src/testa_rb.h
index 30e4996..3ef3e40 100644
--- a/src/testa_rb.h
+++ b/src/testa_rb.h
@@ -9,7 +9,7 @@
  * declaracao da funcao de teste da 
  * arvore vermelha e preta
  */
-void testa_arvore_rb();
+void testa_arvore_rb(const char *m);
 
 #endif
 

commit 839252593a7200de2e48a7ee4c4031ee8651812a
Author: Joilnen <joilnen@gmail.com>
Date:   Thu Dec 30 16:22:09 2021 -0300

    modularizando melhor os casos de teste

diff --git a/src/main.c b/src/main.c
index 87e586b..b781b2d 100644
--- a/src/main.c
+++ b/src/main.c
@@ -4,16 +4,6 @@
 #include <stdio.h>
 #include "testa.h"
 
-/**
- * estas funcoes mostram testes referentes
- * aos itens da avaliacao
- * sao pares com testa_item*
- */
-static void tela_item_1(const char *m);
-static void tela_item_2(const char *m);
-static void tela_item_3(const char *m);
-static void tela_testa_rb(const char *m);
-
 int main()
 {
     char op, nitems = 4;
@@ -56,28 +46,3 @@ int main()
     return 0;
 }
 
-void tela_item_1(const char *m)
-{
-    printf("Sera efetuado testes do item 1\n");
-    printf("%s\n", m);
-}
-
-void tela_item_2(const char *m)
-{
-    printf("Testa item 2\n");
-    printf("%s\n", m);
-}
-
-void tela_item_3(const char *m)
-{
-    printf("Testa item 3\n");
-    printf("%s\n", m);
-}
-
-void tela_testa_rb(const char *m)
-{
-    printf("Testa rb\n");
-    printf("%s\n", m);
-}
-
-
diff --git a/src/testa_item_1.c b/src/testa_item_1.c
index 87127d4..07bf3b4 100644
--- a/src/testa_item_1.c
+++ b/src/testa_item_1.c
@@ -1,3 +1,4 @@
+#include <stdio.h>
 #include "testa_item_1.h"
 
 void testa_item_1(const char *m)
@@ -5,4 +6,9 @@ void testa_item_1(const char *m)
 
 }
 
+void tela_item_1(const char *m)
+{
+    printf("Sera efetuado testes do item 1\n");
+    printf("%s\n", m);
+}
 
diff --git a/src/testa_item_1.h b/src/testa_item_1.h
index 095609e..d22ff07 100644
--- a/src/testa_item_1.h
+++ b/src/testa_item_1.h
@@ -1,6 +1,7 @@
 #ifndef TESTA_ITEM_1_H_
 #define TESTA_ITEM_1_H_
 
+void tela_item_1(const char *m);
 void testa_item_1(const char *m);
 
 #endif
diff --git a/src/testa_item_2.c b/src/testa_item_2.c
index 9ba76fc..c5db65c 100644
--- a/src/testa_item_2.c
+++ b/src/testa_item_2.c
@@ -1,5 +1,13 @@
+#include <stdio.h>
 #include "testa_item_2.h"
 
+void tela_item_2(const char *m)
+{
+    printf("Testa item 2\n");
+    printf("%s\n", m);
+}
+
+
 void testa_item_2(const char *m)
 {
 
diff --git a/src/testa_item_2.h b/src/testa_item_2.h
index e674e4c..ad0f154 100644
--- a/src/testa_item_2.h
+++ b/src/testa_item_2.h
@@ -1,6 +1,7 @@
 #ifndef TESTA_ITEM_2_H_
 #define TESTA_ITEM_2_H_
 
+void tela_item_2(const char *m);
 void testa_item_2(const char *m);
 
 #endif
diff --git a/src/testa_item_3.c b/src/testa_item_3.c
index 032dbbf..8c87537 100644
--- a/src/testa_item_3.c
+++ b/src/testa_item_3.c
@@ -1,5 +1,13 @@
+#include <stdio.h>
 #include "testa_item_3.h"
 
+void tela_item_3(const char *m)
+{
+    printf("Testa item 3\n");
+    printf("%s\n", m);
+}
+
+
 void testa_item_3(const char *m)
 {
 
diff --git a/src/testa_item_3.h b/src/testa_item_3.h
index e1a9564..3808f42 100644
--- a/src/testa_item_3.h
+++ b/src/testa_item_3.h
@@ -1,6 +1,7 @@
 #ifndef TESTA_ITEM_3_H_
 #define TESTA_ITEM_3_H_
 
+void tela_item_3(const char *m);
 void testa_item_3(const char *m);
 
 #endif
diff --git a/src/testa_rb.c b/src/testa_rb.c
index 60f20cf..c1cd79e 100644
--- a/src/testa_rb.c
+++ b/src/testa_rb.c
@@ -9,6 +9,12 @@
 #include <stdio.h>
 #include <string.h>
 
+void tela_testa_rb(const char *m)
+{
+    printf("Testa rb\n");
+    printf("%s\n", m);
+}
+
 /**
  * funcao  de impressao do dipo especifico criado pelo o usuario da biblioteca
  * @noh rb
diff --git a/src/testa_rb.h b/src/testa_rb.h
index 3ef3e40..d568f6b 100644
--- a/src/testa_rb.h
+++ b/src/testa_rb.h
@@ -9,6 +9,7 @@
  * declaracao da funcao de teste da 
  * arvore vermelha e preta
  */
+void tela_testa_rb(const char *m);
 void testa_arvore_rb(const char *m);
 
 #endif

commit 2ea2d4d7266cdc915a69675e366b757b5afce4fc
Author: Joilnen <joilnen@gmail.com>
Date:   Thu Dec 30 17:39:25 2021 -0300

    melhorando a formatacao das telas de teste

diff --git a/src/main.c b/src/main.c
index b781b2d..0c5ddeb 100644
--- a/src/main.c
+++ b/src/main.c
@@ -11,7 +11,7 @@ int main()
     /**
      * mensagem de controle
      */
-    const char mc[] = "* tecle enter *";
+    const char mc[] = "\033[24;65f* tecle enter * ";
 
     /**
      * aqui poderia ser escrito 
diff --git a/src/testa_item_1.c b/src/testa_item_1.c
index 07bf3b4..54986a7 100644
--- a/src/testa_item_1.c
+++ b/src/testa_item_1.c
@@ -1,4 +1,5 @@
 #include <stdio.h>
+#include "conjunto_ordenado.h"
 #include "testa_item_1.h"
 
 void testa_item_1(const char *m)
@@ -8,7 +9,8 @@ void testa_item_1(const char *m)
 
 void tela_item_1(const char *m)
 {
+    LTELA;
     printf("Sera efetuado testes do item 1\n");
-    printf("%s\n", m);
+    printf("%s", m);
 }
 
diff --git a/src/testa_item_2.c b/src/testa_item_2.c
index c5db65c..1c7407a 100644
--- a/src/testa_item_2.c
+++ b/src/testa_item_2.c
@@ -1,10 +1,12 @@
 #include <stdio.h>
+#include "conjunto_ordenado.h"
 #include "testa_item_2.h"
 
 void tela_item_2(const char *m)
 {
+    LTELA;
     printf("Testa item 2\n");
-    printf("%s\n", m);
+    printf("%s", m);
 }
 
 
diff --git a/src/testa_item_3.c b/src/testa_item_3.c
index 8c87537..7142cb2 100644
--- a/src/testa_item_3.c
+++ b/src/testa_item_3.c
@@ -1,10 +1,12 @@
 #include <stdio.h>
+#include "conjunto_ordenado.h"
 #include "testa_item_3.h"
 
 void tela_item_3(const char *m)
 {
+    LTELA;
     printf("Testa item 3\n");
-    printf("%s\n", m);
+    printf("%s", m);
 }
 
 
diff --git a/src/testa_rb.c b/src/testa_rb.c
index c1cd79e..b5381bf 100644
--- a/src/testa_rb.c
+++ b/src/testa_rb.c
@@ -11,8 +11,10 @@
 
 void tela_testa_rb(const char *m)
 {
+    LTELA;
     printf("Testa rb\n");
-    printf("%s\n", m);
+    printf("\033[24d");
+    printf("%s", m);
 }
 
 /**
@@ -63,7 +65,7 @@ int testa_arvore_rb(const char *m)
     printf("= arvore ===================\n");
     conjord_imprime_rb(conjunto_a, 1, TCOLOR);
     printf("= ==========================\n");
-    printf("* tecle enter *\n");
+    printf("%s", m);
     getc(stdin);
 
     meu_tipo mt8;
@@ -78,8 +80,6 @@ int testa_arvore_rb(const char *m)
 
     rb_insert(&conjunto_a, novo_noh);
 
-
-
     meu_tipo mt1;
     mt1.nome = (char *) malloc(sizeof("nome para teste") + 1);
     strncpy(mt1.nome, "nome para teste", sizeof("nome para teste") + 1);
@@ -98,7 +98,7 @@ int testa_arvore_rb(const char *m)
     printf("= arvore ===================\n");
     conjord_imprime_rb(conjunto_a, 1, TCOLOR);
     printf("= ==========================\n");
-    printf("* tecle enter *\n");
+    printf("%s", m);
     getc(stdin);
 
     meu_tipo mt2;
@@ -118,7 +118,7 @@ int testa_arvore_rb(const char *m)
     printf("= arvore ===================\n");
     conjord_imprime_rb(conjunto_a, 1, TCOLOR);
     printf("= ==========================\n");
-    printf("* tecle enter *\n");
+    printf("%s", m);
     getc(stdin);
 
     meu_tipo mt3;
@@ -138,7 +138,7 @@ int testa_arvore_rb(const char *m)
     printf("= arvore ===================\n");
     conjord_imprime_rb(conjunto_a, 1, TCOLOR);
     printf("= ==========================\n");
-    printf("* tecle enter *\n");
+    printf("%s", m);
     getc(stdin);
 
     meu_tipo mt4;
@@ -158,7 +158,7 @@ int testa_arvore_rb(const char *m)
     printf("= arvore ===================\n");
     conjord_imprime_rb(conjunto_a, 1, TCOLOR);
     printf("= ==========================\n");
-    printf("* tecle enter *\n");
+    printf("%s", m);
     getc(stdin);
 
     meu_tipo mt5;
@@ -178,7 +178,7 @@ int testa_arvore_rb(const char *m)
     printf("= arvore ===================\n");
     conjord_imprime_rb(conjunto_a, 1, TCOLOR);
     printf("= ==========================\n");
-    printf("* tecle enter *\n");
+    printf("%s", m);
 
     meu_tipo mt6;
     mt6.nome = (char *) malloc(sizeof("nome para teste") + 1);
@@ -197,7 +197,7 @@ int testa_arvore_rb(const char *m)
     printf("= arvore ===================\n");
     conjord_imprime_rb(conjunto_a, 1, TCOLOR);
     printf("= ==========================\n");
-    printf("* tecle enter *\n");
+    printf("%s", m);
     getc(stdin);
 
     meu_tipo mt7;
@@ -217,7 +217,7 @@ int testa_arvore_rb(const char *m)
     printf("= arvore ===================\n");
     conjord_imprime_rb(conjunto_a, 1, TCOLOR);
     printf("= ==========================\n");
-    printf("* tecle enter *\n");
+    printf("%s", m);
     getc(stdin);
 
     rb_delete(&conjunto_a, rb_search(conjunto_a, 3));
@@ -228,7 +228,7 @@ int testa_arvore_rb(const char *m)
     printf("= arvore ===================\n");
     conjord_imprime_rb(conjunto_a, 1, TCOLOR);
     printf("= ==========================\n");
-    printf("* tecle enter *\n");
+    printf("%s", m);
     getc(stdin);
 
     rb_delete(&conjunto_a, rb_search(conjunto_a, 11));
@@ -238,7 +238,7 @@ int testa_arvore_rb(const char *m)
     printf("= arvore ===================\n");
     conjord_imprime_rb(conjunto_a, 1, TCOLOR);
     printf("= ==========================\n");
-    printf("* tecle enter *\n");
+    printf("%s", m);
     getc(stdin);
 
     rb_delete(&conjunto_a, rb_search(conjunto_a, 4));
@@ -248,7 +248,7 @@ int testa_arvore_rb(const char *m)
     printf("= arvore ===================\n");
     conjord_imprime_rb(conjunto_a, 1, TCOLOR);
     printf("= ==========================\n");
-    printf("* tecle enter *\n");
+    printf("%s", m);
     getc(stdin);
 
     rb_delete(&conjunto_a, rb_search(conjunto_a, 8));
@@ -258,7 +258,7 @@ int testa_arvore_rb(const char *m)
     printf("= arvore ===================\n");
     conjord_imprime_rb(conjunto_a, 1, TCOLOR);
     printf("= ==========================\n");
-    printf("* tecle enter *\n");
+    printf("%s", m);
     getc(stdin);
 
     rb_delete(&conjunto_a, rb_search(conjunto_a, 9));
@@ -268,7 +268,7 @@ int testa_arvore_rb(const char *m)
     printf("= arvore ===================\n");
     conjord_imprime_rb(conjunto_a, 1, TCOLOR);
     printf("= ==========================\n");
-    printf("* tecle enter *\n");
+    printf("%s", m);
     getc(stdin);
     rb_pr(conjunto_a, TCOLOR);
     printf("\n");
@@ -280,7 +280,7 @@ int testa_arvore_rb(const char *m)
     printf("= arvore ===================\n");
     conjord_imprime_rb(conjunto_a, 1, TCOLOR);
     printf("= ==========================\n");
-    printf("* tecle enter *\n");
+    printf("%s", m);
     getc(stdin);
 
     rb_delete(&conjunto_a, rb_search(conjunto_a, 10));
@@ -290,7 +290,7 @@ int testa_arvore_rb(const char *m)
     printf("= arvore ===================\n");
     conjord_imprime_rb(conjunto_a, 1, TCOLOR);
     printf("= ==========================\n");
-    printf("* tecle enter *\n");
+    printf("%s", m);
     getc(stdin);
 
     rb_delete(&conjunto_a, rb_search(conjunto_a, 6));

commit 0f09061f4fb9e2eca112aec43d79f86115af8d79
Author: Joilnen <joilnen@gmail.com>
Date:   Fri Dec 31 13:11:14 2021 -0300

    criando o TAD "conjord" ele faz a interface e oculta a arvore, o cliente
    n lida com funcoes da arvore ou sua estrutura diretamente nunca

diff --git a/src/conjunto_ordenado.c b/src/conjunto_ordenado.c
index fca731f..5d5f73f 100644
--- a/src/conjunto_ordenado.c
+++ b/src/conjunto_ordenado.c
@@ -1,19 +1,44 @@
 #include <stdio.h>
 #include "conjunto_ordenado.h"
 
+static rb_n **raiz;
+static unsigned int r_counter = 0;
+
 /**
  * cria conjunto ordenado e retorna o ponteiro para ele
  */
 conjord *conjord_cria(char *nome)
 {
     conjord *c = (conjord *) malloc (sizeof(conjord));
-    c->raiz = NULL;
+    c->pr = NULL;
+    c->idx = r_counter;
     c->nome = nome;
     c->cardinalidade = 0;
 
     return c;
 }
 
+/**
+ * insere elemento no conjunto ordenado
+ */
+void conjord_insere_elemento(conjord *a, int chave, void *elemento)
+{
+    if (a->pr)
+    {
+        rb_n *n = (rb_n *) malloc(sizeof(rb_n));
+        n->k = chave;
+        n->d = elemento;
+        if(!rb_insert(&a->pr, n))
+            a->cardinalidade++;
+    }
+    else
+    {
+        raiz = (rb_n **) malloc(sizeof(rb_n));
+        a->pr = raiz[a->idx] = rb_cr(chave, elemento);
+        a->cardinalidade++;
+    }
+}
+
 /**
  * imprime elementos do conjunto subitem 1 do item 2
  * "imprimir os elementos de um conjunto, em ordem crescente das chaves"
@@ -28,7 +53,7 @@ void conjord_imprime()
  */
 int conjord_eh_vazio(const conjord *a)
 {
-    return !a->raiz;
+    return !a->pr;
 }
 
 /**
@@ -40,6 +65,41 @@ int conjord_esvazia(conjord *a)
 
 }
 
+void conjord_imprime_arvore_rb(conjord *c, int s)
+{  
+    const int dist =  8;
+    int e = TIPO_DE_TERMINAL;
+    rb_n *t = c->pr;
+    if (t == &rb_s)
+        return;  
+  
+    s += dist;  
+  
+    conjord_imprime_rb(t->r, s, e);  
+
+    // for (int i = dist; i < s; i++)  
+    //     printf(" ");  
+    // printf("%*s", s, "");
+    printf("%*c", s - dist, ' ');
+    if(t->c == BLACK)
+    {
+        if(e == TCOLOR)
+            printf("\033[44m\033[37mk:%dc:%d\033[0m\n", t->k, t->c);
+        else
+            printf("k:%dc:%d\n", t->k, t->c);
+
+    }
+    else
+    {
+        if(e == TCOLOR)
+            printf("\033[41m\033[37mk:%dc:%d\033[0m\n", t->k, t->c);
+        else
+            printf("\033[7mk:%dc:%d\033[0m\n", t->k, t->c);
+    }
+
+    conjord_imprime_rb(t->l, s, e);  
+}
+
 /**
  * imprime arvore
  * @param t noh raiz
diff --git a/src/conjunto_ordenado.h b/src/conjunto_ordenado.h
index 9ea7863..de0b121 100644
--- a/src/conjunto_ordenado.h
+++ b/src/conjunto_ordenado.h
@@ -14,7 +14,8 @@
  * exigidas no documento da avaliacao para este TAD
  */
 typedef struct conjord {
-    rb_n *raiz;
+    rb_n *pr;
+    unsigned int idx;
     char *nome;
     int cardinalidade;
 } conjord;
@@ -24,6 +25,11 @@ typedef struct conjord {
  */
 conjord *conjord_cria(char *nome);
 
+/**
+ * insere elemento no conjunto ordenado
+ */
+void conjord_insere_elemento(conjord *a, int chave, void *elemento);
+
 /**
  * imprime elementos do conjunto subitem 1 do item 2
  * "imprimir os elementos de um conjunto, em ordem crescente das chaves"
@@ -50,11 +56,6 @@ int conjord_esvazia();
  */
 void conjord_destroi(conjord **a);
 
-/**
- * insere elemento no conjunto ordenado
- */
-void conjord_insere_elemento(conjord *a, int chave, void *elemento);
-
 /**
  * exclui elemento do conjunto ordenado através da chave
  * é o idenficador de acordo com especificacao
@@ -96,6 +97,16 @@ conjord *conjord_subtrai(conjord *a, conjord *b);
  */
 void conjord_imprime_rb(rb_n *t, int s, int e);
 
+/**
+ * item 3 da especificao
+ * "Imprime a arvore rubro negra
+ * nesta operacao, cada noh da arvore serah
+ * representado pela sua chave de identificacao seguida da sua cor"
+ * @param c ponteiro para o conjunto ordenado
+ * @param s espaco entre os nohs na apresentacao da arvore
+ */
+void conjord_imprime_arvore_rb(conjord *c, int s);
+
 /**
  * foi utlizado macro em vez de funcao
  * pra evitar o footprint da chamada
@@ -105,7 +116,8 @@ void conjord_imprime_rb(rb_n *t, int s, int e);
  * foi primeiro implementado com um loop
  * mas pensando melhor dessa forma mais rapido
  */
-#define LTELA printf(LIMPA_TELA);
+#define LTELA printf(LIMPA_TELA)
+#define TIPO_DE_TERMINAL TCOLOR
 
 #endif
 
diff --git a/src/testa_rb.c b/src/testa_rb.c
index b5381bf..9659682 100644
--- a/src/testa_rb.c
+++ b/src/testa_rb.c
@@ -50,257 +50,273 @@ int testa_arvore_rb(const char *m)
      */
     rb_seta_impr_elem(imprime_meu_tipo);
 
-    /**
-     * cria noh raiz, utiliza a tecnica de macro pois simplifica e deixa
-     * uma interface mais intuitiva ao usuario da biblioteca
-     * @parametro 0 nome variavel do noh raiz
-     * @parametro 1 chave do noh raiz
-     * @parametro 2 dado criado neste noh, pode ser de qqr tipo
-     */
-    rb_n *conjunto_a = rb_cr(10, &mt0);
-
+    conjord *cj_a = conjord_cria("A");
+    conjord_insere_elemento(cj_a, 10, &mt0);
     LTELA;
-    rb_pr(conjunto_a, TCOLOR);
-    printf("\n");
-    printf("= arvore ===================\n");
-    conjord_imprime_rb(conjunto_a, 1, TCOLOR);
-    printf("= ==========================\n");
-    printf("%s", m);
+    conjord_imprime_arvore_rb(cj_a, 1);
     getc(stdin);
 
-    meu_tipo mt8;
-    mt8.nome = (char *) malloc(sizeof("nome para teste") + 1);
-    strncpy(mt8.nome, "nome para teste", sizeof("nome para teste") + 1);
-    mt8.telefone = (char *) malloc(sizeof("999999999") + 1);
-    strncpy(mt8.telefone, "999999999", sizeof("999999999") + 1);
-
-    rb_n *novo_noh = (rb_n *) malloc (sizeof(rb_n));
-    novo_noh->k = 9;
-    novo_noh->d = &mt8;
-
-    rb_insert(&conjunto_a, novo_noh);
-
     meu_tipo mt1;
     mt1.nome = (char *) malloc(sizeof("nome para teste") + 1);
     strncpy(mt1.nome, "nome para teste", sizeof("nome para teste") + 1);
     mt1.telefone = (char *) malloc(sizeof("999999999") + 1);
     strncpy(mt1.telefone, "999999999", sizeof("999999999") + 1);
 
-    novo_noh = (rb_n *) malloc (sizeof(rb_n));
-    novo_noh->k = 9;
-    novo_noh->d = &mt1;
-
-    rb_insert(&conjunto_a, novo_noh);
-
-    LTELA;
-    rb_pr(conjunto_a, TCOLOR);
-    printf("\n");
-    printf("= arvore ===================\n");
-    conjord_imprime_rb(conjunto_a, 1, TCOLOR);
-    printf("= ==========================\n");
-    printf("%s", m);
-    getc(stdin);
-
-    meu_tipo mt2;
-    mt2.nome = (char *) malloc(sizeof("nome para teste") + 1);
-    strncpy(mt2.nome, "nome para teste", sizeof("nome para teste") + 1);
-    mt2.telefone = (char *) malloc(sizeof("999999999") + 1);
-    strncpy(mt2.telefone, "999999999", sizeof("999999999") + 1);
-
-    novo_noh = (rb_n *) malloc (sizeof(rb_n));
-    novo_noh->k = 11;
-    novo_noh->d = &mt2;
-    rb_insert(&conjunto_a, novo_noh);
-
-    LTELA;
-    rb_pr(conjunto_a, TCOLOR);
-    printf("\n");
-    printf("= arvore ===================\n");
-    conjord_imprime_rb(conjunto_a, 1, TCOLOR);
-    printf("= ==========================\n");
-    printf("%s", m);
-    getc(stdin);
-
-    meu_tipo mt3;
-    mt3.nome = (char *) malloc(sizeof("nome para teste") + 1);
-    strncpy(mt3.nome, "nome para teste", sizeof("nome para teste") + 1);
-    mt3.telefone = (char *) malloc(sizeof("999999999") + 1);
-    strncpy(mt3.telefone, "999999999", sizeof("999999999") + 1);
-
-    novo_noh = (rb_n *) malloc (sizeof(rb_n));
-    novo_noh->k = 8;
-    novo_noh->d = &mt3;
-    rb_insert(&conjunto_a, novo_noh);
-
-    LTELA;
-    rb_pr(conjunto_a, TCOLOR);
-    printf("\n");
-    printf("= arvore ===================\n");
-    conjord_imprime_rb(conjunto_a, 1, TCOLOR);
-    printf("= ==========================\n");
-    printf("%s", m);
-    getc(stdin);
-
-    meu_tipo mt4;
-    mt4.nome = (char *) malloc(sizeof("nome para teste") + 1);
-    strncpy(mt4.nome, "nome para teste", sizeof("nome para teste") + 1);
-    mt4.telefone = (char *) malloc(sizeof("999999999") + 1);
-    strncpy(mt4.telefone, "999999999", sizeof("999999999") + 1);
-
-    novo_noh = (rb_n *) malloc (sizeof(rb_n));
-    novo_noh->k = 6;
-    novo_noh->d = &mt4;
-    rb_insert(&conjunto_a, novo_noh);
-
-    LTELA;
-    rb_pr(conjunto_a, TCOLOR);
-    printf("\n");
-    printf("= arvore ===================\n");
-    conjord_imprime_rb(conjunto_a, 1, TCOLOR);
-    printf("= ==========================\n");
-    printf("%s", m);
-    getc(stdin);
-
-    meu_tipo mt5;
-    mt5.nome = (char *) malloc(sizeof("nome para teste") + 1);
-    strncpy(mt5.nome, "nome para teste", sizeof("nome para teste") + 1);
-    mt5.telefone = (char *) malloc(sizeof("999999999") + 1);
-    strncpy(mt5.telefone, "999999999", sizeof("999999999") + 1);
-
-    novo_noh = (rb_n *) malloc (sizeof(rb_n));
-    novo_noh->k = 5;
-    novo_noh->d = &mt5;
-    rb_insert(&conjunto_a, novo_noh);
-
+    conjord_insere_elemento(cj_a, 11, &mt1);
     LTELA;
-    rb_pr(conjunto_a, TCOLOR);
-    printf("\n");
-    printf("= arvore ===================\n");
-    conjord_imprime_rb(conjunto_a, 1, TCOLOR);
-    printf("= ==========================\n");
-    printf("%s", m);
+    conjord_imprime_arvore_rb(cj_a, 1);
 
-    meu_tipo mt6;
-    mt6.nome = (char *) malloc(sizeof("nome para teste") + 1);
-    strncpy(mt6.nome, "nome para teste", sizeof("nome para teste") + 1);
-    mt6.telefone = (char *) malloc(sizeof("999999999") + 1);
-    strncpy(mt6.telefone, "999999999", sizeof("999999999") + 1);
-
-    novo_noh = (rb_n *) malloc (sizeof(rb_n));
-    novo_noh->k = 4;
-    novo_noh->d = &mt6;
-    rb_insert(&conjunto_a, novo_noh);
-
-    LTELA;
-    rb_pr(conjunto_a, TCOLOR);
-    printf("\n");
-    printf("= arvore ===================\n");
-    conjord_imprime_rb(conjunto_a, 1, TCOLOR);
-    printf("= ==========================\n");
-    printf("%s", m);
-    getc(stdin);
-
-    meu_tipo mt7;
-    mt7.nome = (char *) malloc(sizeof("nome para teste") + 1);
-    strncpy(mt7.nome, "nome para teste", sizeof("nome para teste") + 1);
-    mt7.telefone = (char *) malloc(sizeof("999999999") + 1);
-    strncpy(mt7.telefone, "999999999", sizeof("999999999") + 1);
-
-    novo_noh = (rb_n *) malloc (sizeof(rb_n));
-    novo_noh->k = 3;
-    novo_noh->d = &mt7;
-    rb_insert(&conjunto_a, novo_noh);
-
-    LTELA;
-    rb_pr(conjunto_a, TCOLOR);
-    printf("\n");
-    printf("= arvore ===================\n");
-    conjord_imprime_rb(conjunto_a, 1, TCOLOR);
-    printf("= ==========================\n");
-    printf("%s", m);
-    getc(stdin);
-
-    rb_delete(&conjunto_a, rb_search(conjunto_a, 3));
-    printf("\n");
-    LTELA;
-    rb_pr(conjunto_a, TCOLOR);
-    printf("\n");
-    printf("= arvore ===================\n");
-    conjord_imprime_rb(conjunto_a, 1, TCOLOR);
-    printf("= ==========================\n");
-    printf("%s", m);
-    getc(stdin);
-
-    rb_delete(&conjunto_a, rb_search(conjunto_a, 11));
-    LTELA;
-    rb_pr(conjunto_a, TCOLOR);
-    printf("\n");
-    printf("= arvore ===================\n");
-    conjord_imprime_rb(conjunto_a, 1, TCOLOR);
-    printf("= ==========================\n");
-    printf("%s", m);
-    getc(stdin);
-
-    rb_delete(&conjunto_a, rb_search(conjunto_a, 4));
-    LTELA;
-    rb_pr(conjunto_a, TCOLOR);
-    printf("\n");
-    printf("= arvore ===================\n");
-    conjord_imprime_rb(conjunto_a, 1, TCOLOR);
-    printf("= ==========================\n");
-    printf("%s", m);
-    getc(stdin);
-
-    rb_delete(&conjunto_a, rb_search(conjunto_a, 8));
-    LTELA;
-    rb_pr(conjunto_a, TCOLOR);
-    printf("\n");
-    printf("= arvore ===================\n");
-    conjord_imprime_rb(conjunto_a, 1, TCOLOR);
-    printf("= ==========================\n");
-    printf("%s", m);
-    getc(stdin);
-
-    rb_delete(&conjunto_a, rb_search(conjunto_a, 9));
-    LTELA;
-    rb_pr(conjunto_a, TCOLOR);
-    printf("\n");
-    printf("= arvore ===================\n");
-    conjord_imprime_rb(conjunto_a, 1, TCOLOR);
-    printf("= ==========================\n");
-    printf("%s", m);
-    getc(stdin);
-    rb_pr(conjunto_a, TCOLOR);
-    printf("\n");
-
-    rb_delete(&conjunto_a, rb_search(conjunto_a, 5));
-    LTELA;
-    rb_pr(conjunto_a, TCOLOR);
-    printf("\n");
-    printf("= arvore ===================\n");
-    conjord_imprime_rb(conjunto_a, 1, TCOLOR);
-    printf("= ==========================\n");
-    printf("%s", m);
-    getc(stdin);
-
-    rb_delete(&conjunto_a, rb_search(conjunto_a, 10));
-    LTELA;
-    rb_pr(conjunto_a, TCOLOR);
-    printf("\n");
-    printf("= arvore ===================\n");
-    conjord_imprime_rb(conjunto_a, 1, TCOLOR);
-    printf("= ==========================\n");
-    printf("%s", m);
-    getc(stdin);
-
-    rb_delete(&conjunto_a, rb_search(conjunto_a, 6));
-    LTELA;
-    printf("nada\n");
-    printf("= arvore ===================\n");
-    conjord_imprime_rb(conjunto_a, 1, TCOLOR);
-    printf("= ==========================\n");
-    rb_pr(conjunto_a, TCOLOR);
-    printf("\n");
+    /**
+     * cria noh raiz, utiliza a tecnica de macro pois simplifica e deixa
+     * uma interface mais intuitiva ao usuario da biblioteca
+     * @parametro 0 nome variavel do noh raiz
+     * @parametro 1 chave do noh raiz
+     * @parametro 2 dado criado neste noh, pode ser de qqr tipo
+     */
+//     rb_n *conjunto_a = rb_cr(10, &mt0);
+// 
+//     LTELA;
+//     rb_pr(conjunto_a, TCOLOR);
+//     printf("\n");
+//     printf("= arvore ===================\n");
+//     conjord_imprime_rb(conjunto_a, 1, TCOLOR);
+//     printf("= ==========================\n");
+//     printf("%s", m);
+//     getc(stdin);
+// 
+//     meu_tipo mt8;
+//     mt8.nome = (char *) malloc(sizeof("nome para teste") + 1);
+//     strncpy(mt8.nome, "nome para teste", sizeof("nome para teste") + 1);
+//     mt8.telefone = (char *) malloc(sizeof("999999999") + 1);
+//     strncpy(mt8.telefone, "999999999", sizeof("999999999") + 1);
+// 
+//     rb_n *novo_noh = (rb_n *) malloc (sizeof(rb_n));
+//     novo_noh->k = 9;
+//     novo_noh->d = &mt8;
+// 
+//     rb_insert(&conjunto_a, novo_noh);
+// 
+//     meu_tipo mt1;
+//     mt1.nome = (char *) malloc(sizeof("nome para teste") + 1);
+//     strncpy(mt1.nome, "nome para teste", sizeof("nome para teste") + 1);
+//     mt1.telefone = (char *) malloc(sizeof("999999999") + 1);
+//     strncpy(mt1.telefone, "999999999", sizeof("999999999") + 1);
+// 
+//     novo_noh = (rb_n *) malloc (sizeof(rb_n));
+//     novo_noh->k = 9;
+//     novo_noh->d = &mt1;
+// 
+//     rb_insert(&conjunto_a, novo_noh);
+// 
+//     LTELA;
+//     rb_pr(conjunto_a, TCOLOR);
+//     printf("\n");
+//     printf("= arvore ===================\n");
+//     conjord_imprime_rb(conjunto_a, 1, TCOLOR);
+//     printf("= ==========================\n");
+//     printf("%s", m);
+//     getc(stdin);
+// 
+//     meu_tipo mt2;
+//     mt2.nome = (char *) malloc(sizeof("nome para teste") + 1);
+//     strncpy(mt2.nome, "nome para teste", sizeof("nome para teste") + 1);
+//     mt2.telefone = (char *) malloc(sizeof("999999999") + 1);
+//     strncpy(mt2.telefone, "999999999", sizeof("999999999") + 1);
+// 
+//     novo_noh = (rb_n *) malloc (sizeof(rb_n));
+//     novo_noh->k = 11;
+//     novo_noh->d = &mt2;
+//     rb_insert(&conjunto_a, novo_noh);
+// 
+//     LTELA;
+//     rb_pr(conjunto_a, TCOLOR);
+//     printf("\n");
+//     printf("= arvore ===================\n");
+//     conjord_imprime_rb(conjunto_a, 1, TCOLOR);
+//     printf("= ==========================\n");
+//     printf("%s", m);
+//     getc(stdin);
+// 
+//     meu_tipo mt3;
+//     mt3.nome = (char *) malloc(sizeof("nome para teste") + 1);
+//     strncpy(mt3.nome, "nome para teste", sizeof("nome para teste") + 1);
+//     mt3.telefone = (char *) malloc(sizeof("999999999") + 1);
+//     strncpy(mt3.telefone, "999999999", sizeof("999999999") + 1);
+// 
+//     novo_noh = (rb_n *) malloc (sizeof(rb_n));
+//     novo_noh->k = 8;
+//     novo_noh->d = &mt3;
+//     rb_insert(&conjunto_a, novo_noh);
+// 
+//     LTELA;
+//     rb_pr(conjunto_a, TCOLOR);
+//     printf("\n");
+//     printf("= arvore ===================\n");
+//     conjord_imprime_rb(conjunto_a, 1, TCOLOR);
+//     printf("= ==========================\n");
+//     printf("%s", m);
+//     getc(stdin);
+// 
+//     meu_tipo mt4;
+//     mt4.nome = (char *) malloc(sizeof("nome para teste") + 1);
+//     strncpy(mt4.nome, "nome para teste", sizeof("nome para teste") + 1);
+//     mt4.telefone = (char *) malloc(sizeof("999999999") + 1);
+//     strncpy(mt4.telefone, "999999999", sizeof("999999999") + 1);
+// 
+//     novo_noh = (rb_n *) malloc (sizeof(rb_n));
+//     novo_noh->k = 6;
+//     novo_noh->d = &mt4;
+//     rb_insert(&conjunto_a, novo_noh);
+// 
+//     LTELA;
+//     rb_pr(conjunto_a, TCOLOR);
+//     printf("\n");
+//     printf("= arvore ===================\n");
+//     conjord_imprime_rb(conjunto_a, 1, TCOLOR);
+//     printf("= ==========================\n");
+//     printf("%s", m);
+//     getc(stdin);
+// 
+//     meu_tipo mt5;
+//     mt5.nome = (char *) malloc(sizeof("nome para teste") + 1);
+//     strncpy(mt5.nome, "nome para teste", sizeof("nome para teste") + 1);
+//     mt5.telefone = (char *) malloc(sizeof("999999999") + 1);
+//     strncpy(mt5.telefone, "999999999", sizeof("999999999") + 1);
+// 
+//     novo_noh = (rb_n *) malloc (sizeof(rb_n));
+//     novo_noh->k = 5;
+//     novo_noh->d = &mt5;
+//     rb_insert(&conjunto_a, novo_noh);
+// 
+//     LTELA;
+//     rb_pr(conjunto_a, TCOLOR);
+//     printf("\n");
+//     printf("= arvore ===================\n");
+//     conjord_imprime_rb(conjunto_a, 1, TCOLOR);
+//     printf("= ==========================\n");
+//     printf("%s", m);
+// 
+//     meu_tipo mt6;
+//     mt6.nome = (char *) malloc(sizeof("nome para teste") + 1);
+//     strncpy(mt6.nome, "nome para teste", sizeof("nome para teste") + 1);
+//     mt6.telefone = (char *) malloc(sizeof("999999999") + 1);
+//     strncpy(mt6.telefone, "999999999", sizeof("999999999") + 1);
+// 
+//     novo_noh = (rb_n *) malloc (sizeof(rb_n));
+//     novo_noh->k = 4;
+//     novo_noh->d = &mt6;
+//     rb_insert(&conjunto_a, novo_noh);
+// 
+//     LTELA;
+//     rb_pr(conjunto_a, TCOLOR);
+//     printf("\n");
+//     printf("= arvore ===================\n");
+//     conjord_imprime_rb(conjunto_a, 1, TCOLOR);
+//     printf("= ==========================\n");
+//     printf("%s", m);
+//     getc(stdin);
+// 
+//     meu_tipo mt7;
+//     mt7.nome = (char *) malloc(sizeof("nome para teste") + 1);
+//     strncpy(mt7.nome, "nome para teste", sizeof("nome para teste") + 1);
+//     mt7.telefone = (char *) malloc(sizeof("999999999") + 1);
+//     strncpy(mt7.telefone, "999999999", sizeof("999999999") + 1);
+// 
+//     novo_noh = (rb_n *) malloc (sizeof(rb_n));
+//     novo_noh->k = 3;
+//     novo_noh->d = &mt7;
+//     rb_insert(&conjunto_a, novo_noh);
+// 
+//     LTELA;
+//     rb_pr(conjunto_a, TCOLOR);
+//     printf("\n");
+//     printf("= arvore ===================\n");
+//     conjord_imprime_rb(conjunto_a, 1, TCOLOR);
+//     printf("= ==========================\n");
+//     printf("%s", m);
+//     getc(stdin);
+// 
+//     rb_delete(&conjunto_a, rb_search(conjunto_a, 3));
+//     printf("\n");
+//     LTELA;
+//     rb_pr(conjunto_a, TCOLOR);
+//     printf("\n");
+//     printf("= arvore ===================\n");
+//     conjord_imprime_rb(conjunto_a, 1, TCOLOR);
+//     printf("= ==========================\n");
+//     printf("%s", m);
+//     getc(stdin);
+// 
+//     rb_delete(&conjunto_a, rb_search(conjunto_a, 11));
+//     LTELA;
+//     rb_pr(conjunto_a, TCOLOR);
+//     printf("\n");
+//     printf("= arvore ===================\n");
+//     conjord_imprime_rb(conjunto_a, 1, TCOLOR);
+//     printf("= ==========================\n");
+//     printf("%s", m);
+//     getc(stdin);
+// 
+//     rb_delete(&conjunto_a, rb_search(conjunto_a, 4));
+//     LTELA;
+//     rb_pr(conjunto_a, TCOLOR);
+//     printf("\n");
+//     printf("= arvore ===================\n");
+//     conjord_imprime_rb(conjunto_a, 1, TCOLOR);
+//     printf("= ==========================\n");
+//     printf("%s", m);
+//     getc(stdin);
+// 
+//     rb_delete(&conjunto_a, rb_search(conjunto_a, 8));
+//     LTELA;
+//     rb_pr(conjunto_a, TCOLOR);
+//     printf("\n");
+//     printf("= arvore ===================\n");
+//     conjord_imprime_rb(conjunto_a, 1, TCOLOR);
+//     printf("= ==========================\n");
+//     printf("%s", m);
+//     getc(stdin);
+// 
+//     rb_delete(&conjunto_a, rb_search(conjunto_a, 9));
+//     LTELA;
+//     rb_pr(conjunto_a, TCOLOR);
+//     printf("\n");
+//     printf("= arvore ===================\n");
+//     conjord_imprime_rb(conjunto_a, 1, TCOLOR);
+//     printf("= ==========================\n");
+//     printf("%s", m);
+//     getc(stdin);
+//     rb_pr(conjunto_a, TCOLOR);
+//     printf("\n");
+// 
+//     rb_delete(&conjunto_a, rb_search(conjunto_a, 5));
+//     LTELA;
+//     rb_pr(conjunto_a, TCOLOR);
+//     printf("\n");
+//     printf("= arvore ===================\n");
+//     conjord_imprime_rb(conjunto_a, 1, TCOLOR);
+//     printf("= ==========================\n");
+//     printf("%s", m);
+//     getc(stdin);
+// 
+//     rb_delete(&conjunto_a, rb_search(conjunto_a, 10));
+//     LTELA;
+//     rb_pr(conjunto_a, TCOLOR);
+//     printf("\n");
+//     printf("= arvore ===================\n");
+//     conjord_imprime_rb(conjunto_a, 1, TCOLOR);
+//     printf("= ==========================\n");
+//     printf("%s", m);
+//     getc(stdin);
+// 
+//     rb_delete(&conjunto_a, rb_search(conjunto_a, 6));
+//     LTELA;
+//     printf("nada\n");
+//     printf("= arvore ===================\n");
+//     conjord_imprime_rb(conjunto_a, 1, TCOLOR);
+//     printf("= ==========================\n");
+//     rb_pr(conjunto_a, TCOLOR);
+//     printf("\n");
     /**
      * testando apenas rb no momento
     conjord *conj_a = conjord_cria();
diff --git a/src/testa_rb.c_ b/src/testa_rb.c_
new file mode 100644
index 0000000..b5381bf
--- /dev/null
+++ b/src/testa_rb.c_
@@ -0,0 +1,320 @@
+/**
+ * aluno: joilnen leite
+ */
+
+/**
+ * inclusao da bilioteca implementada baseada em arvores red black
+ */
+#include "conjunto_ordenado.h"
+#include <stdio.h>
+#include <string.h>
+
+void tela_testa_rb(const char *m)
+{
+    LTELA;
+    printf("Testa rb\n");
+    printf("\033[24d");
+    printf("%s", m);
+}
+
+/**
+ * funcao  de impressao do dipo especifico criado pelo o usuario da biblioteca
+ * @noh rb
+ */
+void imprime_meu_tipo(void *);
+
+/**
+ * funcao main de teste separada do codigo da biblioteca como especificado
+ */
+int testa_arvore_rb(const char *m)
+{
+    /**
+     * definicao de um tipo exemplo pelo o usuario
+     */
+    typedef struct {
+        char *nome;
+        char *telefone;
+    } meu_tipo;
+
+    /**
+     * criacao do dado para o tipo do usuario
+     */
+    meu_tipo mt0;
+    mt0.nome = (char *) malloc(sizeof("nome para teste") + 1);
+    strncpy(mt0.nome, "nome para teste", sizeof("nome para teste") + 1);
+    mt0.telefone = (char *) malloc(sizeof("999999999") + 1);
+    strncpy(mt0.telefone, "999999999", sizeof("999999999") + 1);
+
+    /**
+     * seta a funcao para impressao utiliza aqui a tecnica de ponteiro para funcao
+     */
+    rb_seta_impr_elem(imprime_meu_tipo);
+
+    /**
+     * cria noh raiz, utiliza a tecnica de macro pois simplifica e deixa
+     * uma interface mais intuitiva ao usuario da biblioteca
+     * @parametro 0 nome variavel do noh raiz
+     * @parametro 1 chave do noh raiz
+     * @parametro 2 dado criado neste noh, pode ser de qqr tipo
+     */
+    rb_n *conjunto_a = rb_cr(10, &mt0);
+
+    LTELA;
+    rb_pr(conjunto_a, TCOLOR);
+    printf("\n");
+    printf("= arvore ===================\n");
+    conjord_imprime_rb(conjunto_a, 1, TCOLOR);
+    printf("= ==========================\n");
+    printf("%s", m);
+    getc(stdin);
+
+    meu_tipo mt8;
+    mt8.nome = (char *) malloc(sizeof("nome para teste") + 1);
+    strncpy(mt8.nome, "nome para teste", sizeof("nome para teste") + 1);
+    mt8.telefone = (char *) malloc(sizeof("999999999") + 1);
+    strncpy(mt8.telefone, "999999999", sizeof("999999999") + 1);
+
+    rb_n *novo_noh = (rb_n *) malloc (sizeof(rb_n));
+    novo_noh->k = 9;
+    novo_noh->d = &mt8;
+
+    rb_insert(&conjunto_a, novo_noh);
+
+    meu_tipo mt1;
+    mt1.nome = (char *) malloc(sizeof("nome para teste") + 1);
+    strncpy(mt1.nome, "nome para teste", sizeof("nome para teste") + 1);
+    mt1.telefone = (char *) malloc(sizeof("999999999") + 1);
+    strncpy(mt1.telefone, "999999999", sizeof("999999999") + 1);
+
+    novo_noh = (rb_n *) malloc (sizeof(rb_n));
+    novo_noh->k = 9;
+    novo_noh->d = &mt1;
+
+    rb_insert(&conjunto_a, novo_noh);
+
+    LTELA;
+    rb_pr(conjunto_a, TCOLOR);
+    printf("\n");
+    printf("= arvore ===================\n");
+    conjord_imprime_rb(conjunto_a, 1, TCOLOR);
+    printf("= ==========================\n");
+    printf("%s", m);
+    getc(stdin);
+
+    meu_tipo mt2;
+    mt2.nome = (char *) malloc(sizeof("nome para teste") + 1);
+    strncpy(mt2.nome, "nome para teste", sizeof("nome para teste") + 1);
+    mt2.telefone = (char *) malloc(sizeof("999999999") + 1);
+    strncpy(mt2.telefone, "999999999", sizeof("999999999") + 1);
+
+    novo_noh = (rb_n *) malloc (sizeof(rb_n));
+    novo_noh->k = 11;
+    novo_noh->d = &mt2;
+    rb_insert(&conjunto_a, novo_noh);
+
+    LTELA;
+    rb_pr(conjunto_a, TCOLOR);
+    printf("\n");
+    printf("= arvore ===================\n");
+    conjord_imprime_rb(conjunto_a, 1, TCOLOR);
+    printf("= ==========================\n");
+    printf("%s", m);
+    getc(stdin);
+
+    meu_tipo mt3;
+    mt3.nome = (char *) malloc(sizeof("nome para teste") + 1);
+    strncpy(mt3.nome, "nome para teste", sizeof("nome para teste") + 1);
+    mt3.telefone = (char *) malloc(sizeof("999999999") + 1);
+    strncpy(mt3.telefone, "999999999", sizeof("999999999") + 1);
+
+    novo_noh = (rb_n *) malloc (sizeof(rb_n));
+    novo_noh->k = 8;
+    novo_noh->d = &mt3;
+    rb_insert(&conjunto_a, novo_noh);
+
+    LTELA;
+    rb_pr(conjunto_a, TCOLOR);
+    printf("\n");
+    printf("= arvore ===================\n");
+    conjord_imprime_rb(conjunto_a, 1, TCOLOR);
+    printf("= ==========================\n");
+    printf("%s", m);
+    getc(stdin);
+
+    meu_tipo mt4;
+    mt4.nome = (char *) malloc(sizeof("nome para teste") + 1);
+    strncpy(mt4.nome, "nome para teste", sizeof("nome para teste") + 1);
+    mt4.telefone = (char *) malloc(sizeof("999999999") + 1);
+    strncpy(mt4.telefone, "999999999", sizeof("999999999") + 1);
+
+    novo_noh = (rb_n *) malloc (sizeof(rb_n));
+    novo_noh->k = 6;
+    novo_noh->d = &mt4;
+    rb_insert(&conjunto_a, novo_noh);
+
+    LTELA;
+    rb_pr(conjunto_a, TCOLOR);
+    printf("\n");
+    printf("= arvore ===================\n");
+    conjord_imprime_rb(conjunto_a, 1, TCOLOR);
+    printf("= ==========================\n");
+    printf("%s", m);
+    getc(stdin);
+
+    meu_tipo mt5;
+    mt5.nome = (char *) malloc(sizeof("nome para teste") + 1);
+    strncpy(mt5.nome, "nome para teste", sizeof("nome para teste") + 1);
+    mt5.telefone = (char *) malloc(sizeof("999999999") + 1);
+    strncpy(mt5.telefone, "999999999", sizeof("999999999") + 1);
+
+    novo_noh = (rb_n *) malloc (sizeof(rb_n));
+    novo_noh->k = 5;
+    novo_noh->d = &mt5;
+    rb_insert(&conjunto_a, novo_noh);
+
+    LTELA;
+    rb_pr(conjunto_a, TCOLOR);
+    printf("\n");
+    printf("= arvore ===================\n");
+    conjord_imprime_rb(conjunto_a, 1, TCOLOR);
+    printf("= ==========================\n");
+    printf("%s", m);
+
+    meu_tipo mt6;
+    mt6.nome = (char *) malloc(sizeof("nome para teste") + 1);
+    strncpy(mt6.nome, "nome para teste", sizeof("nome para teste") + 1);
+    mt6.telefone = (char *) malloc(sizeof("999999999") + 1);
+    strncpy(mt6.telefone, "999999999", sizeof("999999999") + 1);
+
+    novo_noh = (rb_n *) malloc (sizeof(rb_n));
+    novo_noh->k = 4;
+    novo_noh->d = &mt6;
+    rb_insert(&conjunto_a, novo_noh);
+
+    LTELA;
+    rb_pr(conjunto_a, TCOLOR);
+    printf("\n");
+    printf("= arvore ===================\n");
+    conjord_imprime_rb(conjunto_a, 1, TCOLOR);
+    printf("= ==========================\n");
+    printf("%s", m);
+    getc(stdin);
+
+    meu_tipo mt7;
+    mt7.nome = (char *) malloc(sizeof("nome para teste") + 1);
+    strncpy(mt7.nome, "nome para teste", sizeof("nome para teste") + 1);
+    mt7.telefone = (char *) malloc(sizeof("999999999") + 1);
+    strncpy(mt7.telefone, "999999999", sizeof("999999999") + 1);
+
+    novo_noh = (rb_n *) malloc (sizeof(rb_n));
+    novo_noh->k = 3;
+    novo_noh->d = &mt7;
+    rb_insert(&conjunto_a, novo_noh);
+
+    LTELA;
+    rb_pr(conjunto_a, TCOLOR);
+    printf("\n");
+    printf("= arvore ===================\n");
+    conjord_imprime_rb(conjunto_a, 1, TCOLOR);
+    printf("= ==========================\n");
+    printf("%s", m);
+    getc(stdin);
+
+    rb_delete(&conjunto_a, rb_search(conjunto_a, 3));
+    printf("\n");
+    LTELA;
+    rb_pr(conjunto_a, TCOLOR);
+    printf("\n");
+    printf("= arvore ===================\n");
+    conjord_imprime_rb(conjunto_a, 1, TCOLOR);
+    printf("= ==========================\n");
+    printf("%s", m);
+    getc(stdin);
+
+    rb_delete(&conjunto_a, rb_search(conjunto_a, 11));
+    LTELA;
+    rb_pr(conjunto_a, TCOLOR);
+    printf("\n");
+    printf("= arvore ===================\n");
+    conjord_imprime_rb(conjunto_a, 1, TCOLOR);
+    printf("= ==========================\n");
+    printf("%s", m);
+    getc(stdin);
+
+    rb_delete(&conjunto_a, rb_search(conjunto_a, 4));
+    LTELA;
+    rb_pr(conjunto_a, TCOLOR);
+    printf("\n");
+    printf("= arvore ===================\n");
+    conjord_imprime_rb(conjunto_a, 1, TCOLOR);
+    printf("= ==========================\n");
+    printf("%s", m);
+    getc(stdin);
+
+    rb_delete(&conjunto_a, rb_search(conjunto_a, 8));
+    LTELA;
+    rb_pr(conjunto_a, TCOLOR);
+    printf("\n");
+    printf("= arvore ===================\n");
+    conjord_imprime_rb(conjunto_a, 1, TCOLOR);
+    printf("= ==========================\n");
+    printf("%s", m);
+    getc(stdin);
+
+    rb_delete(&conjunto_a, rb_search(conjunto_a, 9));
+    LTELA;
+    rb_pr(conjunto_a, TCOLOR);
+    printf("\n");
+    printf("= arvore ===================\n");
+    conjord_imprime_rb(conjunto_a, 1, TCOLOR);
+    printf("= ==========================\n");
+    printf("%s", m);
+    getc(stdin);
+    rb_pr(conjunto_a, TCOLOR);
+    printf("\n");
+
+    rb_delete(&conjunto_a, rb_search(conjunto_a, 5));
+    LTELA;
+    rb_pr(conjunto_a, TCOLOR);
+    printf("\n");
+    printf("= arvore ===================\n");
+    conjord_imprime_rb(conjunto_a, 1, TCOLOR);
+    printf("= ==========================\n");
+    printf("%s", m);
+    getc(stdin);
+
+    rb_delete(&conjunto_a, rb_search(conjunto_a, 10));
+    LTELA;
+    rb_pr(conjunto_a, TCOLOR);
+    printf("\n");
+    printf("= arvore ===================\n");
+    conjord_imprime_rb(conjunto_a, 1, TCOLOR);
+    printf("= ==========================\n");
+    printf("%s", m);
+    getc(stdin);
+
+    rb_delete(&conjunto_a, rb_search(conjunto_a, 6));
+    LTELA;
+    printf("nada\n");
+    printf("= arvore ===================\n");
+    conjord_imprime_rb(conjunto_a, 1, TCOLOR);
+    printf("= ==========================\n");
+    rb_pr(conjunto_a, TCOLOR);
+    printf("\n");
+    /**
+     * testando apenas rb no momento
+    conjord *conj_a = conjord_cria();
+    printf("eh vazio %d", conjord_eh_vazio(conj_a));
+    */
+}
+
+/**
+ * definicao da funcao de impressao estipulado pelo cliente, aqui apenas um
+ * exemplo
+ */
+void imprime_meu_tipo(void *n)
+{
+
+}
+
+
diff --git a/src/testa_rb.h_ b/src/testa_rb.h_
new file mode 100644
index 0000000..d568f6b
--- /dev/null
+++ b/src/testa_rb.h_
@@ -0,0 +1,17 @@
+#ifndef TESTA_ARVORE_RB_
+#define TESTA_ARVORE_RB_
+
+/**
+ * aluno: joilnen leite
+ */
+
+/**
+ * declaracao da funcao de teste da 
+ * arvore vermelha e preta
+ */
+void tela_testa_rb(const char *m);
+void testa_arvore_rb(const char *m);
+
+#endif
+
+

commit d34ae11e21929bc68af921767b81b5a7a7991e78
Author: Joilnen <joilnen@gmail.com>
Date:   Fri Dec 31 13:45:43 2021 -0300

    adcionando funcao que verifica a cardinalidade do conjunto

diff --git a/src/conjunto_ordenado.c b/src/conjunto_ordenado.c
index 5d5f73f..69788bf 100644
--- a/src/conjunto_ordenado.c
+++ b/src/conjunto_ordenado.c
@@ -39,6 +39,14 @@ void conjord_insere_elemento(conjord *a, int chave, void *elemento)
     }
 }
 
+int conjord_cardinalidade(conjord *c)
+{
+    if(c)
+        return c->cardinalidade;
+    else
+        return -1;
+}
+
 /**
  * imprime elementos do conjunto subitem 1 do item 2
  * "imprimir os elementos de um conjunto, em ordem crescente das chaves"
diff --git a/src/conjunto_ordenado.h b/src/conjunto_ordenado.h
index de0b121..fb527ed 100644
--- a/src/conjunto_ordenado.h
+++ b/src/conjunto_ordenado.h
@@ -39,7 +39,7 @@ void conjord_imprime();
 /**
  * retorna a cardinalidade do conjunto
  */
-unsigned int conjord_cardinalidade();
+int conjord_cardinalidade();
 
 /**
  * testa se o conjunto estah vazio

commit 6419abfeef9fe808f1d8a727aa58d23d98239705
Author: Joilnen <joilnen@gmail.com>
Date:   Sat Jan 1 10:57:14 2022 -0300

    melhorando o codigo de formatacao e adaptando a terminais mais primitivos

diff --git a/src/conjunto_ordenado.h b/src/conjunto_ordenado.h
index fb527ed..dfc6cd4 100644
--- a/src/conjunto_ordenado.h
+++ b/src/conjunto_ordenado.h
@@ -118,6 +118,7 @@ void conjord_imprime_arvore_rb(conjord *c, int s);
  */
 #define LTELA printf(LIMPA_TELA)
 #define TIPO_DE_TERMINAL TCOLOR
+#define CM printf("%s", m); fflush(stdout); getc(stdin)
 
 #endif
 
diff --git a/src/main.c b/src/main.c
index 0c5ddeb..2b46c12 100644
--- a/src/main.c
+++ b/src/main.c
@@ -11,7 +11,7 @@ int main()
     /**
      * mensagem de controle
      */
-    const char mc[] = "\033[24;65f* tecle enter * ";
+    const char mc[] = "\033[24;65H* tecle enter * ";
 
     /**
      * aqui poderia ser escrito 
@@ -28,21 +28,25 @@ int main()
     {
         switch (op)
         {
-            case 0: tela_item_1(mc); break;
-            case 1: tela_item_2(mc); break;
-            case 2: tela_item_3(mc); break;
-            case 3: tela_testa_rb(mc);
-        }
-        getc(stdin);
-        switch (op)
-        {
-            case 0: testa_item_1(mc); break;
-            case 1: testa_item_1(mc); break;
-            case 2: testa_item_1(mc); break;
-            case 3: testa_arvore_rb(mc);
+            case 0:
+               tela_item_1(mc);
+               testa_item_1(mc);
+            break;
+            case 1:
+               tela_item_2(mc);
+               testa_item_1(mc);
+            break;
+            case 2:
+               tela_item_3(mc);
+               testa_item_1(mc);
+            break;
+            case 3:
+               tela_testa_rb(mc);
+               testa_arvore_rb(mc);
         }
     }
 
     return 0;
 }
 
+
diff --git a/src/testa_item_1.c b/src/testa_item_1.c
index 54986a7..612a912 100644
--- a/src/testa_item_1.c
+++ b/src/testa_item_1.c
@@ -11,6 +11,6 @@ void tela_item_1(const char *m)
 {
     LTELA;
     printf("Sera efetuado testes do item 1\n");
-    printf("%s", m);
+    CM;
 }
 
diff --git a/src/testa_item_2.c b/src/testa_item_2.c
index 1c7407a..481f6e6 100644
--- a/src/testa_item_2.c
+++ b/src/testa_item_2.c
@@ -6,7 +6,7 @@ void tela_item_2(const char *m)
 {
     LTELA;
     printf("Testa item 2\n");
-    printf("%s", m);
+    CM;
 }
 
 
diff --git a/src/testa_item_3.c b/src/testa_item_3.c
index 7142cb2..358d1a8 100644
--- a/src/testa_item_3.c
+++ b/src/testa_item_3.c
@@ -6,7 +6,7 @@ void tela_item_3(const char *m)
 {
     LTELA;
     printf("Testa item 3\n");
-    printf("%s", m);
+    CM;
 }
 
 
diff --git a/src/testa_rb.c b/src/testa_rb.c
index 9659682..d5fe07a 100644
--- a/src/testa_rb.c
+++ b/src/testa_rb.c
@@ -13,8 +13,7 @@ void tela_testa_rb(const char *m)
 {
     LTELA;
     printf("Testa rb\n");
-    printf("\033[24d");
-    printf("%s", m);
+    CM;
 }
 
 /**
@@ -54,7 +53,7 @@ int testa_arvore_rb(const char *m)
     conjord_insere_elemento(cj_a, 10, &mt0);
     LTELA;
     conjord_imprime_arvore_rb(cj_a, 1);
-    getc(stdin);
+    CM;
 
     meu_tipo mt1;
     mt1.nome = (char *) malloc(sizeof("nome para teste") + 1);
@@ -65,6 +64,7 @@ int testa_arvore_rb(const char *m)
     conjord_insere_elemento(cj_a, 11, &mt1);
     LTELA;
     conjord_imprime_arvore_rb(cj_a, 1);
+    CM;
 
     /**
      * cria noh raiz, utiliza a tecnica de macro pois simplifica e deixa

commit d57fd62ae426ffb03d0c2b05973eb0c3a571334f
Author: Joilnen <joilnen@gmail.com>
Date:   Sat Jan 1 12:09:24 2022 -0300

    ajustado a posicao da mensagem de controle pra caber no mais rudimentar
    vt100 de 21(4)x80(1)

diff --git a/src/main.c b/src/main.c
index 2b46c12..b5a68f2 100644
--- a/src/main.c
+++ b/src/main.c
@@ -11,7 +11,7 @@ int main()
     /**
      * mensagem de controle
      */
-    const char mc[] = "\033[24;65H* tecle enter * ";
+    const char mc[] = "\033[24;64H* tecle enter * ";
 
     /**
      * aqui poderia ser escrito 

commit 65031dda6033a9ff25add41b54bc036848aa3d1c
Author: Joilnen <joilnen@gmail.com>
Date:   Sat Jan 1 12:44:58 2022 -0300

    passei a funcao de impressao da arvore para o fonte da arvore nada da arvore
    eh manipulado fora do seu fonte

diff --git a/src/conjunto_ordenado.c b/src/conjunto_ordenado.c
index 69788bf..65745cf 100644
--- a/src/conjunto_ordenado.c
+++ b/src/conjunto_ordenado.c
@@ -75,75 +75,7 @@ int conjord_esvazia(conjord *a)
 
 void conjord_imprime_arvore_rb(conjord *c, int s)
 {  
-    const int dist =  8;
-    int e = TIPO_DE_TERMINAL;
-    rb_n *t = c->pr;
-    if (t == &rb_s)
-        return;  
-  
-    s += dist;  
-  
-    conjord_imprime_rb(t->r, s, e);  
-
-    // for (int i = dist; i < s; i++)  
-    //     printf(" ");  
-    // printf("%*s", s, "");
-    printf("%*c", s - dist, ' ');
-    if(t->c == BLACK)
-    {
-        if(e == TCOLOR)
-            printf("\033[44m\033[37mk:%dc:%d\033[0m\n", t->k, t->c);
-        else
-            printf("k:%dc:%d\n", t->k, t->c);
-
-    }
-    else
-    {
-        if(e == TCOLOR)
-            printf("\033[41m\033[37mk:%dc:%d\033[0m\n", t->k, t->c);
-        else
-            printf("\033[7mk:%dc:%d\033[0m\n", t->k, t->c);
-    }
-
-    conjord_imprime_rb(t->l, s, e);  
+    rb_pr2(c->pr, s, TCOLOR);  
 }
 
-/**
- * imprime arvore
- * @param t noh raiz
- * @param s espaco entre os nohs na impressao
- * @param e tipo do terminal
- */
-void conjord_imprime_rb(rb_n *t, int s, int e)  {  
-    const int dist =  8;
-    if (t == &rb_s)
-        return;  
-  
-    s += dist;  
-  
-    conjord_imprime_rb(t->r, s, e);  
-
-    // for (int i = dist; i < s; i++)  
-    //     printf(" ");  
-    // printf("%*s", s, "");
-    printf("%*c", s - dist, ' ');
-    if(t->c == BLACK)
-    {
-        if(e == TCOLOR)
-            printf("\033[44m\033[37mk:%dc:%d\033[0m\n", t->k, t->c);
-        else
-            printf("k:%dc:%d\n", t->k, t->c);
-
-    }
-    else
-    {
-        if(e == TCOLOR)
-            printf("\033[41m\033[37mk:%dc:%d\033[0m\n", t->k, t->c);
-        else
-            printf("\033[7mk:%dc:%d\033[0m\n", t->k, t->c);
-    }
-
-    conjord_imprime_rb(t->l, s, e);  
-}  
-
 
diff --git a/src/red_black.c b/src/red_black.c
index 96a1c53..4628fa7 100644
--- a/src/red_black.c
+++ b/src/red_black.c
@@ -398,6 +398,37 @@ void rb_pr(rb_n *a, int t)
     }
 }
 
+void rb_pr2(rb_n *t, int s, int e)  {  
+    const int dist =  8;
+    if (t == &rb_s)
+        return;  
+  
+    s += dist;  
+  
+    rb_pr2(t->r, s, e);  
+
+    // for (int i = dist; i < s; i++)  
+    //     printf(" ");  
+    // printf("%*s", s, "");
+    printf("%*c", s - dist, ' ');
+    if(t->c == BLACK)
+    {
+        if(e == TCOLOR)
+            printf("\033[44m\033[37mk:%dc:%d\033[0m\n", t->k, t->c);
+        else
+            printf("k:%dc:%d\n", t->k, t->c);
+
+    }
+    else
+    {
+        if(e == TCOLOR)
+            printf("\033[41m\033[37mk:%dc:%d\033[0m\n", t->k, t->c);
+        else
+            printf("\033[7mk:%dc:%d\033[0m\n", t->k, t->c);
+    }
+
+    rb_pr2(t->l, s, e);  
+}  
 
 rb_n *rb_search(rb_n *t, int k)
 {
diff --git a/src/red_black.h b/src/red_black.h
index 6b6c1ce..eff729e 100644
--- a/src/red_black.h
+++ b/src/red_black.h
@@ -163,4 +163,11 @@ int rb_seta_impr_elem(void (*i)(void *n));
  */
 void rb_pr(rb_n *a, int t);
 
+/**
+ * imprime arvore uma segunda versao
+ * @param a raiz
+ * @param t tipo de terminal
+ */
+void rb_pr2(rb_n *t, int s, int e);
+
 #endif

commit a380e2b75a5394085e45a2ccf9b61dab5c7ebc0e
Author: Joilnen <joilnen@gmail.com>
Date:   Sat Jan 1 13:37:22 2022 -0300

    aumentando o teste na arvore, parece robusta

diff --git a/src/conjunto_ordenado.c b/src/conjunto_ordenado.c
index 65745cf..a0c92d3 100644
--- a/src/conjunto_ordenado.c
+++ b/src/conjunto_ordenado.c
@@ -39,6 +39,11 @@ void conjord_insere_elemento(conjord *a, int chave, void *elemento)
     }
 }
 
+void conjord_deleta_elemento(conjord *a, int chave)
+{
+    rb_delete(&a->pr, rb_search(a->pr, chave));
+}
+
 int conjord_cardinalidade(conjord *c)
 {
     if(c)
@@ -75,7 +80,7 @@ int conjord_esvazia(conjord *a)
 
 void conjord_imprime_arvore_rb(conjord *c, int s)
 {  
-    rb_pr2(c->pr, s, TCOLOR);  
+    rb_pr(c->pr, s, TCOLOR);  
 }
 
 
diff --git a/src/conjunto_ordenado.h b/src/conjunto_ordenado.h
index dfc6cd4..660aa13 100644
--- a/src/conjunto_ordenado.h
+++ b/src/conjunto_ordenado.h
@@ -30,6 +30,11 @@ conjord *conjord_cria(char *nome);
  */
 void conjord_insere_elemento(conjord *a, int chave, void *elemento);
 
+/**
+ * insere elemento no conjunto ordenado
+ */
+void conjord_deleta_elemento(conjord *a, int chave);
+
 /**
  * imprime elementos do conjunto subitem 1 do item 2
  * "imprimir os elementos de um conjunto, em ordem crescente das chaves"
diff --git a/src/red_black.c b/src/red_black.c
index 4628fa7..d75b7fd 100644
--- a/src/red_black.c
+++ b/src/red_black.c
@@ -375,30 +375,38 @@ int rb_seta_impr_elem(void (*i)(void *n))
     rb_impr_elem = i;
 }
 
-void rb_pr(rb_n *a, int t)
+void rb_pr(rb_n *t, int s, int e)
 {
-    if (a != &rb_s)
+    const int dist = 5;
+    if (t == &rb_s)
+        return;  
+  
+    s += dist;  
+  
+    rb_pr(t->r, s, e);  
+
+    printf("%*c", s - dist, ' ');
+    if(t->c == BLACK)
     {
-        if (a->c == BLACK)
-        {
-            if(t == TCOLOR)
-                printf("%sk:%dc:%d%s ", S_AZUL, a->k, a->c, S_NORM);
-            else
-                printf("k:%dc:%d ", a->k, a->c);
-        }
+        if(e == TCOLOR)
+            printf("\033[44m\033[37m%d\033[0m\n", t->k);
         else
-        {
-            if (t == TCOLOR)
-                printf("%sk:%dc:%d%s ", S_VERM, a->k, a->c, S_NORM);
-            else
-                printf("%sk:%dc:%d%s ", S_INV, a->k, a->c, S_NORM);
-        }
-        rb_pr(a->l, t);
-        rb_pr(a->r, t);
+            printf("%d\n", t->k);
+
+    }
+    else
+    {
+        if(e == TCOLOR)
+            printf("\033[41m\033[37m%d\033[0m\n", t->k);
+        else
+            printf("\033[7m%d\033[0m\n", t->k, t->c);
     }
+
+    rb_pr(t->l, s, e);  
 }
 
-void rb_pr2(rb_n *t, int s, int e)  {  
+void rb_pr2(rb_n *t, int s, int e)
+{  
     const int dist =  8;
     if (t == &rb_s)
         return;  
diff --git a/src/red_black.h b/src/red_black.h
index eff729e..b349178 100644
--- a/src/red_black.h
+++ b/src/red_black.h
@@ -161,7 +161,7 @@ int rb_seta_impr_elem(void (*i)(void *n));
  * @param a raiz
  * @param t tipo de terminal
  */
-void rb_pr(rb_n *a, int t);
+void rb_pr(rb_n *t, int s, int e);
 
 /**
  * imprime arvore uma segunda versao
diff --git a/src/testa_rb.c b/src/testa_rb.c
index d5fe07a..b4559fa 100644
--- a/src/testa_rb.c
+++ b/src/testa_rb.c
@@ -66,6 +66,39 @@ int testa_arvore_rb(const char *m)
     conjord_imprime_arvore_rb(cj_a, 1);
     CM;
 
+    int ctest;
+    conjord *cj_b = conjord_cria("B");
+    for (ctest = 12; ctest < 23; ++ctest)
+    {
+        conjord_insere_elemento(cj_b, ctest, NULL);
+        LTELA;
+        conjord_imprime_arvore_rb(cj_b, 1);
+        CM;
+    }
+
+    for (ctest = 0; ctest < 13; ++ctest)
+    {
+        conjord_insere_elemento(cj_b, ctest, NULL);
+        LTELA;
+        conjord_imprime_arvore_rb(cj_b, 1);
+        CM;
+    }
+
+    for (ctest = 13; ctest < 23; ++ctest)
+    {
+        conjord_deleta_elemento(cj_b, ctest);
+        LTELA;
+        conjord_imprime_arvore_rb(cj_b, 1);
+        CM;
+    }
+
+    for (ctest = 0; ctest < 13; ++ctest)
+    {
+        conjord_deleta_elemento(cj_b, ctest);
+        LTELA;
+        conjord_imprime_arvore_rb(cj_b, 1);
+        CM;
+    }
     /**
      * cria noh raiz, utiliza a tecnica de macro pois simplifica e deixa
      * uma interface mais intuitiva ao usuario da biblioteca

commit 7426f462a6f234b9c363292cc7f92b07b03ae8f5
Author: Joilnen <joilnen@gmail.com>
Date:   Sat Jan 1 15:17:06 2022 -0300

    teste massivo na arvore rb, funcionando perfeitamente, muito bom

diff --git a/src/conjunto_ordenado.c b/src/conjunto_ordenado.c
index a0c92d3..d284131 100644
--- a/src/conjunto_ordenado.c
+++ b/src/conjunto_ordenado.c
@@ -83,4 +83,13 @@ void conjord_imprime_arvore_rb(conjord *c, int s)
     rb_pr(c->pr, s, TCOLOR);  
 }
 
+void conjord_imprime_lista(int *l, int s)
+{
+    int i;
+    for (i = 0; i < s; i++)
+    {
+        printf("\033[%d;78H%d", l[i] + 1, l[i]);
+    }
+}
+
 
diff --git a/src/conjunto_ordenado.h b/src/conjunto_ordenado.h
index 660aa13..b2cb82b 100644
--- a/src/conjunto_ordenado.h
+++ b/src/conjunto_ordenado.h
@@ -112,6 +112,8 @@ void conjord_imprime_rb(rb_n *t, int s, int e);
  */
 void conjord_imprime_arvore_rb(conjord *c, int s);
 
+void conjord_imprime_lista(int *l, int s);
+
 /**
  * foi utlizado macro em vez de funcao
  * pra evitar o footprint da chamada
diff --git a/src/testa_rb.c b/src/testa_rb.c
index b4559fa..2e01fec 100644
--- a/src/testa_rb.c
+++ b/src/testa_rb.c
@@ -68,37 +68,38 @@ int testa_arvore_rb(const char *m)
 
     int ctest;
     conjord *cj_b = conjord_cria("B");
-    for (ctest = 12; ctest < 23; ++ctest)
+    const int size_n = 23;
+    int test_n[size_n];
+    for (ctest = 0; ctest < size_n; ++ctest)
     {
-        conjord_insere_elemento(cj_b, ctest, NULL);
-        LTELA;
-        conjord_imprime_arvore_rb(cj_b, 1);
-        CM;
+        if(ctest < 10) test_n[ctest] = ctest + 13;
+        else  test_n[ctest] = ctest - 10;
     }
 
-    for (ctest = 0; ctest < 13; ++ctest)
+    LTELA;
+    conjord_imprime_lista(test_n, size_n);
+    CM;
+    for (ctest = 0; ctest < size_n; ++ctest)
     {
-        conjord_insere_elemento(cj_b, ctest, NULL);
+        conjord_insere_elemento(cj_b, test_n[ctest], NULL);
         LTELA;
+        conjord_imprime_lista(&test_n[ctest + 1], size_n - ctest - 1);
+        printf("\033[H");
         conjord_imprime_arvore_rb(cj_b, 1);
+        fflush(stdout);
         CM;
     }
 
-    for (ctest = 13; ctest < 23; ++ctest)
+    for (ctest = 0; ctest < 23; ++ctest)
     {
-        conjord_deleta_elemento(cj_b, ctest);
         LTELA;
+        conjord_imprime_lista(test_n, ctest + 1);
+        conjord_deleta_elemento(cj_b, test_n[ctest]);
+        printf("\033[H");
         conjord_imprime_arvore_rb(cj_b, 1);
         CM;
     }
 
-    for (ctest = 0; ctest < 13; ++ctest)
-    {
-        conjord_deleta_elemento(cj_b, ctest);
-        LTELA;
-        conjord_imprime_arvore_rb(cj_b, 1);
-        CM;
-    }
     /**
      * cria noh raiz, utiliza a tecnica de macro pois simplifica e deixa
      * uma interface mais intuitiva ao usuario da biblioteca

commit 205d70bd8f89b9718e3fc888da4533544281fae8
Author: Joilnen <joilnen@gmail.com>
Date:   Sat Jan 1 15:19:28 2022 -0300

    teste massivo na arvore

diff --git a/src/conjunto_ordenado.c b/src/conjunto_ordenado.c
index d284131..90f99c4 100644
--- a/src/conjunto_ordenado.c
+++ b/src/conjunto_ordenado.c
@@ -87,9 +87,7 @@ void conjord_imprime_lista(int *l, int s)
 {
     int i;
     for (i = 0; i < s; i++)
-    {
         printf("\033[%d;78H%d", l[i] + 1, l[i]);
-    }
 }
 
 

commit 5c83aaaf1d166e620793cc871c19680a53b98517
Author: Joilnen <joilnen@gmail.com>
Date:   Sat Jan 1 15:36:15 2022 -0300

    ajustando para 21 linhas que sao os terminais mais antigos

diff --git a/src/main.c b/src/main.c
index b5a68f2..3155c68 100644
--- a/src/main.c
+++ b/src/main.c
@@ -11,7 +11,7 @@ int main()
     /**
      * mensagem de controle
      */
-    const char mc[] = "\033[24;64H* tecle enter * ";
+    const char mc[] = "\033[24;62H* tecle enter * ";
 
     /**
      * aqui poderia ser escrito 
diff --git a/src/testa_rb.c b/src/testa_rb.c
index 2e01fec..8d4e13f 100644
--- a/src/testa_rb.c
+++ b/src/testa_rb.c
@@ -68,11 +68,11 @@ int testa_arvore_rb(const char *m)
 
     int ctest;
     conjord *cj_b = conjord_cria("B");
-    const int size_n = 23;
+    const int size_n = 21;
     int test_n[size_n];
     for (ctest = 0; ctest < size_n; ++ctest)
     {
-        if(ctest < 10) test_n[ctest] = ctest + 13;
+        if(ctest < 10) test_n[ctest] = ctest + 11;
         else  test_n[ctest] = ctest - 10;
     }
 
@@ -90,7 +90,7 @@ int testa_arvore_rb(const char *m)
         CM;
     }
 
-    for (ctest = 0; ctest < 23; ++ctest)
+    for (ctest = 0; ctest < size_n; ++ctest)
     {
         LTELA;
         conjord_imprime_lista(test_n, ctest + 1);

commit f1b1a079a4d65d70b841b5b6ebdfe2ea9e9e0ca8
Author: Joilnen <joilnen@gmail.com>
Date:   Sat Jan 1 16:33:37 2022 -0300

    pequeno ajuste no teste da arvore

diff --git a/src/testa_rb.c b/src/testa_rb.c
index 8d4e13f..8a5729b 100644
--- a/src/testa_rb.c
+++ b/src/testa_rb.c
@@ -51,9 +51,9 @@ int testa_arvore_rb(const char *m)
 
     conjord *cj_a = conjord_cria("A");
     conjord_insere_elemento(cj_a, 10, &mt0);
-    LTELA;
-    conjord_imprime_arvore_rb(cj_a, 1);
-    CM;
+    // LTELA;
+    // conjord_imprime_arvore_rb(cj_a, 1);
+    // CM;
 
     meu_tipo mt1;
     mt1.nome = (char *) malloc(sizeof("nome para teste") + 1);
@@ -62,9 +62,9 @@ int testa_arvore_rb(const char *m)
     strncpy(mt1.telefone, "999999999", sizeof("999999999") + 1);
 
     conjord_insere_elemento(cj_a, 11, &mt1);
-    LTELA;
-    conjord_imprime_arvore_rb(cj_a, 1);
-    CM;
+    // LTELA;
+    // conjord_imprime_arvore_rb(cj_a, 1);
+    // CM;
 
     int ctest;
     conjord *cj_b = conjord_cria("B");
@@ -86,7 +86,6 @@ int testa_arvore_rb(const char *m)
         conjord_imprime_lista(&test_n[ctest + 1], size_n - ctest - 1);
         printf("\033[H");
         conjord_imprime_arvore_rb(cj_b, 1);
-        fflush(stdout);
         CM;
     }
 
@@ -99,6 +98,7 @@ int testa_arvore_rb(const char *m)
         conjord_imprime_arvore_rb(cj_b, 1);
         CM;
     }
+    LTELA;
 
     /**
      * cria noh raiz, utiliza a tecnica de macro pois simplifica e deixa

commit 637e6a6ef176073c5a2dc508caf32ffd0086089e
Author: Joilnen <joilnen@gmail.com>
Date:   Sat Jan 1 16:35:15 2022 -0300

    movendo arquivos desnecessarios no momento

diff --git a/src/testa_rb.c_ b/tests/testa_rb.c_
similarity index 100%
rename from src/testa_rb.c_
rename to tests/testa_rb.c_
diff --git a/src/testa_rb.h_ b/tests/testa_rb.h_
similarity index 100%
rename from src/testa_rb.h_
rename to tests/testa_rb.h_

commit 82225ccfc50804e2170be7795bf3e4fbaca03303
Author: Joilnen <joilnen@gmail.com>
Date:   Sun Jan 2 00:07:39 2022 -0300

    impressao de elementos precisa ordenar e passar o CM para esse caso de teste

diff --git a/src/conjunto_ordenado.c b/src/conjunto_ordenado.c
index 90f99c4..b969f97 100644
--- a/src/conjunto_ordenado.c
+++ b/src/conjunto_ordenado.c
@@ -90,4 +90,28 @@ void conjord_imprime_lista(int *l, int s)
         printf("\033[%d;78H%d", l[i] + 1, l[i]);
 }
 
+void (*conjord_imprime_elemento)(void *n);
+
+int conjord_seta_imprime_elemento(void (*i)(void *n))
+{
+    conjord_imprime_elemento = i;
+}
+
+static void conjord_imprime_conjunto_helper(rb_n *n)
+{
+    if (n == &rb_s)
+        return;
+
+    printf("chave: %d\n", n->k);
+    conjord_imprime_elemento(n->d);
+    getc(stdin);
+    conjord_imprime_conjunto_helper(n->l);
+    conjord_imprime_conjunto_helper(n->r);
+}
+
+void conjord_imprime_conjunto(conjord *c)
+{
+    if (c && c->pr)
+        conjord_imprime_conjunto_helper(c->pr);
+}
 
diff --git a/src/conjunto_ordenado.h b/src/conjunto_ordenado.h
index b2cb82b..e4491be 100644
--- a/src/conjunto_ordenado.h
+++ b/src/conjunto_ordenado.h
@@ -114,6 +114,15 @@ void conjord_imprime_arvore_rb(conjord *c, int s);
 
 void conjord_imprime_lista(int *l, int s);
 
+extern void (*conjord_imprime_elemento)(void *n);
+/**
+ * seta a rotina de impressao do dado criado pelo cliente
+ */
+int conjord_seta_imprime_elemento(void (*i)(void *n));
+
+void conjord_imprime_conjunto(conjord *c);
+
+
 /**
  * foi utlizado macro em vez de funcao
  * pra evitar o footprint da chamada
diff --git a/src/main.c b/src/main.c
index 3155c68..7d68692 100644
--- a/src/main.c
+++ b/src/main.c
@@ -34,11 +34,11 @@ int main()
             break;
             case 1:
                tela_item_2(mc);
-               testa_item_1(mc);
+               testa_item_2(mc);
             break;
             case 2:
                tela_item_3(mc);
-               testa_item_1(mc);
+               testa_item_3(mc);
             break;
             case 3:
                tela_testa_rb(mc);
diff --git a/src/red_black.c b/src/red_black.c
index d75b7fd..5cd3def 100644
--- a/src/red_black.c
+++ b/src/red_black.c
@@ -370,11 +370,6 @@ int rb_rot_dir(rb_n **t, rb_n *x)
     return 0;
 }
 
-int rb_seta_impr_elem(void (*i)(void *n))
-{
-    rb_impr_elem = i;
-}
-
 void rb_pr(rb_n *t, int s, int e)
 {
     const int dist = 5;
diff --git a/src/red_black.h b/src/red_black.h
index b349178..27ff6bc 100644
--- a/src/red_black.h
+++ b/src/red_black.h
@@ -151,11 +151,6 @@ int rb_rot_dir(rb_n **t, rb_n *x);
  */
 extern void (*rb_impr_elem)(void *);
 
-/**
- * seta a rotina de impressao do dado criado pelo cliente
- */
-int rb_seta_impr_elem(void (*i)(void *n));
-
 /**
  * imprime arvore 
  * @param a raiz
diff --git a/src/testa_item_1.c b/src/testa_item_1.c
index 612a912..5f9431c 100644
--- a/src/testa_item_1.c
+++ b/src/testa_item_1.c
@@ -1,10 +1,59 @@
 #include <stdio.h>
+#include <string.h>
 #include "conjunto_ordenado.h"
 #include "testa_item_1.h"
 
+static void imprime_meu_tipo(void *);
+
+typedef struct {
+    char *nome;
+    char *telefone;
+} meu_tipo;
+
 void testa_item_1(const char *m)
 {
+    /**
+     * definicao de um tipo exemplo pelo o usuario
+     */
+
+    /**
+     * criacao do dado para o tipo do usuario
+     */
+    meu_tipo mt0;
+    mt0.nome = (char *) malloc(sizeof("nome para teste") + 1);
+    strncpy(mt0.nome, "nome para teste", sizeof("nome para teste") + 1);
+    mt0.telefone = (char *) malloc(sizeof("999999999") + 1);
+    strncpy(mt0.telefone, "999999999", sizeof("999999999") + 1);
+
+    /**
+     * seta a funcao para impressao utiliza aqui a tecnica de ponteiro para funcao
+     */
+    conjord_seta_imprime_elemento(imprime_meu_tipo);
 
+    conjord *cj_a = conjord_cria("A");
+    conjord_insere_elemento(cj_a, 10, &mt0);
+    // LTELA;
+    // conjord_imprime_arvore_rb(cj_a, 1);
+    // CM;
+
+    meu_tipo mt1;
+    mt1.nome = (char *) malloc(sizeof("nome para teste") + 1);
+    strncpy(mt1.nome, "Gertrudes", sizeof("Gertrudes") + 1);
+    mt1.telefone = (char *) malloc(sizeof("999999999") + 1);
+    strncpy(mt1.telefone, "999999999", sizeof("999999999") + 1);
+
+    conjord_insere_elemento(cj_a, 11, &mt1);
+    // LTELA;
+    // conjord_imprime_arvore_rb(cj_a, 1);
+    // CM;
+
+    LTELA;
+    conjord_imprime_elemento(&mt1);
+    CM;
+    LTELA;
+    conjord_imprime_elemento(&mt0);
+    CM;
+    conjord_imprime_conjunto(cj_a);
 }
 
 void tela_item_1(const char *m)
@@ -14,3 +63,13 @@ void tela_item_1(const char *m)
     CM;
 }
 
+
+void imprime_meu_tipo(void *n)
+{
+    printf("===\n");
+    printf("Nome: %s\n", ((meu_tipo *)n)->nome);
+    printf("Telefone: %s\n", ((meu_tipo *)n)->telefone);
+    printf("===\n");
+}
+
+
diff --git a/src/testa_rb.c b/src/testa_rb.c
index 8a5729b..cbaae9d 100644
--- a/src/testa_rb.c
+++ b/src/testa_rb.c
@@ -8,6 +8,7 @@
 #include "conjunto_ordenado.h"
 #include <stdio.h>
 #include <string.h>
+#include "testa_rb.h"
 
 void tela_testa_rb(const char *m)
 {
@@ -20,12 +21,12 @@ void tela_testa_rb(const char *m)
  * funcao  de impressao do dipo especifico criado pelo o usuario da biblioteca
  * @noh rb
  */
-void imprime_meu_tipo(void *);
+static void imprime_meu_tipo(void *);
 
 /**
  * funcao main de teste separada do codigo da biblioteca como especificado
  */
-int testa_arvore_rb(const char *m)
+void testa_arvore_rb(const char *m)
 {
     /**
      * definicao de um tipo exemplo pelo o usuario
@@ -47,7 +48,7 @@ int testa_arvore_rb(const char *m)
     /**
      * seta a funcao para impressao utiliza aqui a tecnica de ponteiro para funcao
      */
-    rb_seta_impr_elem(imprime_meu_tipo);
+    conjord_seta_imprime_elemento(imprime_meu_tipo);
 
     conjord *cj_a = conjord_cria("A");
     conjord_insere_elemento(cj_a, 10, &mt0);

commit 5741993e5f532d3b174e8d4a2cc1d8088d108364
Author: Joilnen <joilnen@gmail.com>
Date:   Sun Jan 2 00:17:18 2022 -0300

    impressao dos elementos trabalhando nisto

diff --git a/src/conjunto_ordenado.c b/src/conjunto_ordenado.c
index b969f97..2aebba6 100644
--- a/src/conjunto_ordenado.c
+++ b/src/conjunto_ordenado.c
@@ -102,7 +102,7 @@ static void conjord_imprime_conjunto_helper(rb_n *n)
     if (n == &rb_s)
         return;
 
-    printf("chave: %d\n", n->k);
+    printf("chave: %d | ", n->k);
     conjord_imprime_elemento(n->d);
     getc(stdin);
     conjord_imprime_conjunto_helper(n->l);
diff --git a/src/testa_item_1.c b/src/testa_item_1.c
index 5f9431c..f895ca2 100644
--- a/src/testa_item_1.c
+++ b/src/testa_item_1.c
@@ -66,10 +66,8 @@ void tela_item_1(const char *m)
 
 void imprime_meu_tipo(void *n)
 {
-    printf("===\n");
-    printf("Nome: %s\n", ((meu_tipo *)n)->nome);
-    printf("Telefone: %s\n", ((meu_tipo *)n)->telefone);
-    printf("===\n");
+    printf("Nome: %s | ", ((meu_tipo *)n)->nome);
+    printf("Telefone: %s", ((meu_tipo *)n)->telefone);
 }
 
 

commit 0eade589606ac59e8c981ae716777dbb00523a0e
Author: Joilnen <joilnen@gmail.com>
Date:   Sun Jan 2 10:33:58 2022 -0300

    feito exemplo do item 1.1 da avaliacao

diff --git a/src/conjunto_ordenado.c b/src/conjunto_ordenado.c
index 2aebba6..74dcaf8 100644
--- a/src/conjunto_ordenado.c
+++ b/src/conjunto_ordenado.c
@@ -21,7 +21,7 @@ conjord *conjord_cria(char *nome)
 /**
  * insere elemento no conjunto ordenado
  */
-void conjord_insere_elemento(conjord *a, int chave, void *elemento)
+int conjord_insere_elemento(conjord *a, int chave, void *elemento)
 {
     if (a->pr)
     {
@@ -30,6 +30,8 @@ void conjord_insere_elemento(conjord *a, int chave, void *elemento)
         n->d = elemento;
         if(!rb_insert(&a->pr, n))
             a->cardinalidade++;
+        else
+            return -1;
     }
     else
     {
@@ -37,6 +39,8 @@ void conjord_insere_elemento(conjord *a, int chave, void *elemento)
         a->pr = raiz[a->idx] = rb_cr(chave, elemento);
         a->cardinalidade++;
     }
+
+    return 0;
 }
 
 void conjord_deleta_elemento(conjord *a, int chave)
@@ -46,7 +50,7 @@ void conjord_deleta_elemento(conjord *a, int chave)
 
 int conjord_cardinalidade(conjord *c)
 {
-    if(c)
+    if (c)
         return c->cardinalidade;
     else
         return -1;
@@ -102,10 +106,9 @@ static void conjord_imprime_conjunto_helper(rb_n *n)
     if (n == &rb_s)
         return;
 
-    printf("chave: %d | ", n->k);
-    conjord_imprime_elemento(n->d);
-    getc(stdin);
     conjord_imprime_conjunto_helper(n->l);
+    printf("chave: %d\t", n->k);
+    conjord_imprime_elemento(n->d);
     conjord_imprime_conjunto_helper(n->r);
 }
 
@@ -115,3 +118,4 @@ void conjord_imprime_conjunto(conjord *c)
         conjord_imprime_conjunto_helper(c->pr);
 }
 
+
diff --git a/src/conjunto_ordenado.h b/src/conjunto_ordenado.h
index e4491be..1b90579 100644
--- a/src/conjunto_ordenado.h
+++ b/src/conjunto_ordenado.h
@@ -28,7 +28,7 @@ conjord *conjord_cria(char *nome);
 /**
  * insere elemento no conjunto ordenado
  */
-void conjord_insere_elemento(conjord *a, int chave, void *elemento);
+int conjord_insere_elemento(conjord *a, int chave, void *elemento);
 
 /**
  * insere elemento no conjunto ordenado
diff --git a/src/testa_item_1.c b/src/testa_item_1.c
index f895ca2..b2da5ea 100644
--- a/src/testa_item_1.c
+++ b/src/testa_item_1.c
@@ -1,5 +1,6 @@
 #include <stdio.h>
 #include <string.h>
+#include <time.h>
 #include "conjunto_ordenado.h"
 #include "testa_item_1.h"
 
@@ -10,6 +11,28 @@ typedef struct {
     char *telefone;
 } meu_tipo;
 
+static void adiciona_lista_de_elementos(conjord *c)
+{
+    int i;
+    for (i = 0; i < 20;)
+    {
+        srand(time(NULL));
+        meu_tipo *mt0 = (meu_tipo *) malloc (sizeof(meu_tipo));
+        mt0->nome = (char *) malloc(sizeof("nome para teste1") + 1);
+        strncpy(mt0->nome, "nome para teste1", sizeof("nome para teste1") + 1);
+        mt0->telefone = (char *) malloc(sizeof("999999999") + 1);
+        strncpy(mt0->telefone, "999999999", sizeof("999999999") + 1);
+        int chave = rand() % 99 + 1;
+        if (!conjord_insere_elemento(c, chave, mt0))
+        {
+            ++i;
+            printf("chave:%d \t", chave);
+            printf("nome:%s\t", mt0->nome);
+            printf("telefone:%s\n", mt0->telefone);
+        }
+    }
+}
+
 void testa_item_1(const char *m)
 {
     /**
@@ -31,29 +54,13 @@ void testa_item_1(const char *m)
     conjord_seta_imprime_elemento(imprime_meu_tipo);
 
     conjord *cj_a = conjord_cria("A");
-    conjord_insere_elemento(cj_a, 10, &mt0);
-    // LTELA;
-    // conjord_imprime_arvore_rb(cj_a, 1);
-    // CM;
-
-    meu_tipo mt1;
-    mt1.nome = (char *) malloc(sizeof("nome para teste") + 1);
-    strncpy(mt1.nome, "Gertrudes", sizeof("Gertrudes") + 1);
-    mt1.telefone = (char *) malloc(sizeof("999999999") + 1);
-    strncpy(mt1.telefone, "999999999", sizeof("999999999") + 1);
-
-    conjord_insere_elemento(cj_a, 11, &mt1);
-    // LTELA;
-    // conjord_imprime_arvore_rb(cj_a, 1);
-    // CM;
-
     LTELA;
-    conjord_imprime_elemento(&mt1);
+    adiciona_lista_de_elementos(cj_a);
     CM;
+
     LTELA;
-    conjord_imprime_elemento(&mt0);
-    CM;
     conjord_imprime_conjunto(cj_a);
+    CM;
 }
 
 void tela_item_1(const char *m)
@@ -66,8 +73,8 @@ void tela_item_1(const char *m)
 
 void imprime_meu_tipo(void *n)
 {
-    printf("Nome: %s | ", ((meu_tipo *)n)->nome);
-    printf("Telefone: %s", ((meu_tipo *)n)->telefone);
+    printf("Nome: %s \t", ((meu_tipo *)n)->nome);
+    printf("Telefone: %s\n", ((meu_tipo *)n)->telefone);
 }
 
 

commit 2f1baaa0aa0bc3607571a4cf50506504e9751db3
Author: Joilnen <joilnen@gmail.com>
Date:   Sun Jan 2 10:41:00 2022 -0300

    consertando a geracao randomica, seed soh precisa ser chamado uma vez
    por chamada de funcao

diff --git a/src/testa_item_1.c b/src/testa_item_1.c
index b2da5ea..ad97d29 100644
--- a/src/testa_item_1.c
+++ b/src/testa_item_1.c
@@ -14,9 +14,9 @@ typedef struct {
 static void adiciona_lista_de_elementos(conjord *c)
 {
     int i;
+    srand(time(NULL));
     for (i = 0; i < 20;)
     {
-        srand(time(NULL));
         meu_tipo *mt0 = (meu_tipo *) malloc (sizeof(meu_tipo));
         mt0->nome = (char *) malloc(sizeof("nome para teste1") + 1);
         strncpy(mt0->nome, "nome para teste1", sizeof("nome para teste1") + 1);

commit 010bf3164df357a2de71aedba35af18529277b2c
Author: Joilnen <joilnen@gmail.com>
Date:   Sun Jan 2 12:28:00 2022 -0300

    testes dos items 1.1 2.1 e 3

diff --git a/src/conjunto_ordenado.h b/src/conjunto_ordenado.h
index 1b90579..4befff1 100644
--- a/src/conjunto_ordenado.h
+++ b/src/conjunto_ordenado.h
@@ -130,10 +130,11 @@ void conjord_imprime_conjunto(conjord *c);
  * varias a vezes eh preferivel q seja inline
  * mas como n tem funcao inline usei a macro
  * foi primeiro implementado com um loop
- * mas pensando melhor dessa forma mais rapido
+ * mas pensando melhor dessa forma eh mais rapido
  */
 #define LTELA printf(LIMPA_TELA)
 #define TIPO_DE_TERMINAL TCOLOR
+#define INFO(x) printf("%s%s%s%s", S_INV, S_INFO, x, S_NORM)
 #define CM printf("%s", m); fflush(stdout); getc(stdin)
 
 #endif
diff --git a/src/jcurses.h b/src/jcurses.h
index 3a8e187..930eec5 100644
--- a/src/jcurses.h
+++ b/src/jcurses.h
@@ -15,5 +15,6 @@
 #define S_VERM "\033[41m\033[37m"
 #define S_INV  "\033[7m"
 #define S_NORM "\033[0m"
+#define S_INFO "\033[21;0H"
 
 #endif
diff --git a/src/testa_item_1.c b/src/testa_item_1.c
index ad97d29..5dbb8ab 100644
--- a/src/testa_item_1.c
+++ b/src/testa_item_1.c
@@ -17,6 +17,13 @@ static void adiciona_lista_de_elementos(conjord *c)
     srand(time(NULL));
     for (i = 0; i < 20;)
     {
+        /**
+         * definicao de um tipo exemplo pelo o usuario
+         */
+
+        /**
+         * criacao do dado para o tipo do usuario
+         */
         meu_tipo *mt0 = (meu_tipo *) malloc (sizeof(meu_tipo));
         mt0->nome = (char *) malloc(sizeof("nome para teste1") + 1);
         strncpy(mt0->nome, "nome para teste1", sizeof("nome para teste1") + 1);
@@ -35,19 +42,6 @@ static void adiciona_lista_de_elementos(conjord *c)
 
 void testa_item_1(const char *m)
 {
-    /**
-     * definicao de um tipo exemplo pelo o usuario
-     */
-
-    /**
-     * criacao do dado para o tipo do usuario
-     */
-    meu_tipo mt0;
-    mt0.nome = (char *) malloc(sizeof("nome para teste") + 1);
-    strncpy(mt0.nome, "nome para teste", sizeof("nome para teste") + 1);
-    mt0.telefone = (char *) malloc(sizeof("999999999") + 1);
-    strncpy(mt0.telefone, "999999999", sizeof("999999999") + 1);
-
     /**
      * seta a funcao para impressao utiliza aqui a tecnica de ponteiro para funcao
      */
@@ -56,10 +50,17 @@ void testa_item_1(const char *m)
     conjord *cj_a = conjord_cria("A");
     LTELA;
     adiciona_lista_de_elementos(cj_a);
+    INFO("* item 2.1 insere 20 elem. chave unica 1 a 99");
+    CM;
+
+    LTELA;
+    conjord_imprime_arvore_rb(cj_a, 1);
+    INFO("* item 3 arvore atual");
     CM;
 
     LTELA;
     conjord_imprime_conjunto(cj_a);
+    INFO("* item 1.1 crescente por chave de id.");
     CM;
 }
 

commit 90526d2f12d97779824353129dc723606b7971ac
Author: Joilnen <joilnen@gmail.com>
Date:   Sun Jan 2 12:48:39 2022 -0300

    melhorando a mensagem de informacao dos testes

diff --git a/src/jcurses.h b/src/jcurses.h
index 930eec5..8616442 100644
--- a/src/jcurses.h
+++ b/src/jcurses.h
@@ -15,6 +15,6 @@
 #define S_VERM "\033[41m\033[37m"
 #define S_INV  "\033[7m"
 #define S_NORM "\033[0m"
-#define S_INFO "\033[21;0H"
+#define S_INFO "\033[24;0H"
 
 #endif

commit b54954412c2f5a7d8a897bf84e860fa89bb0ed45
Author: Joilnen <joilnen@gmail.com>
Date:   Sun Jan 2 14:49:32 2022 -0300

    melhorando as informacaoes da demonstracao

diff --git a/src/conjunto_ordenado.c b/src/conjunto_ordenado.c
index 74dcaf8..2a2ae6a 100644
--- a/src/conjunto_ordenado.c
+++ b/src/conjunto_ordenado.c
@@ -18,6 +18,19 @@ conjord *conjord_cria(char *nome)
     return c;
 }
 
+/**
+ * cria conjunto ordenado e retorna o ponteiro para ele
+ */
+void conjord_destroi(conjord *c)
+{
+    if(!c)
+        return;
+    if(!c->pr)
+        return;
+    free(c->pr);
+    free(c);
+}
+
 /**
  * insere elemento no conjunto ordenado
  */
diff --git a/src/conjunto_ordenado.h b/src/conjunto_ordenado.h
index 4befff1..b94287e 100644
--- a/src/conjunto_ordenado.h
+++ b/src/conjunto_ordenado.h
@@ -59,7 +59,7 @@ int conjord_esvazia();
 /**
  * destroi e desaloca uma instancia de conjunto ordenado
  */
-void conjord_destroi(conjord **a);
+void conjord_destroi(conjord *a);
 
 /**
  * exclui elemento do conjunto ordenado através da chave
@@ -135,6 +135,7 @@ void conjord_imprime_conjunto(conjord *c);
 #define LTELA printf(LIMPA_TELA)
 #define TIPO_DE_TERMINAL TCOLOR
 #define INFO(x) printf("%s%s%s%s", S_INV, S_INFO, x, S_NORM)
+#define INFO_ST(x) printf("%s%s%s%s", S_INV, S_INFO_ST, x, S_NORM)
 #define CM printf("%s", m); fflush(stdout); getc(stdin)
 
 #endif
diff --git a/src/jcurses.h b/src/jcurses.h
index 8616442..de499cd 100644
--- a/src/jcurses.h
+++ b/src/jcurses.h
@@ -16,5 +16,6 @@
 #define S_INV  "\033[7m"
 #define S_NORM "\033[0m"
 #define S_INFO "\033[24;0H"
+#define S_INFO_ST "\033[0;65H"
 
 #endif
diff --git a/src/testa_item_1.c b/src/testa_item_1.c
index 5dbb8ab..271d50a 100644
--- a/src/testa_item_1.c
+++ b/src/testa_item_1.c
@@ -50,7 +50,7 @@ void testa_item_1(const char *m)
     conjord *cj_a = conjord_cria("A");
     LTELA;
     adiciona_lista_de_elementos(cj_a);
-    INFO("* item 2.1 insere 20 elem. chave unica 1 a 99");
+    INFO("* item 2.1 insere 20 elem. chave unica entre 1 a 99");
     CM;
 
     LTELA;
@@ -62,6 +62,8 @@ void testa_item_1(const char *m)
     conjord_imprime_conjunto(cj_a);
     INFO("* item 1.1 crescente por chave de id.");
     CM;
+
+    conjord_destroi(cj_a);
 }
 
 void tela_item_1(const char *m)

commit b090880ff232c54f785a787d9dcb9a4f731f10d8
Author: Joilnen <joilnen@gmail.com>
Date:   Mon Jan 3 06:32:32 2022 -0300

    criado o mecanismo de checagem dos testes da avaliacao, muita operacao booleana
    interessante

diff --git a/src/checklist.c b/src/checklist.c
new file mode 100644
index 0000000..189eb62
--- /dev/null
+++ b/src/checklist.c
@@ -0,0 +1,30 @@
+#include <stdio.h>
+#include <string.h>
+#include "conjunto_ordenado.h"
+#include "checklist.h"
+
+void tela_checklist(int i)
+{
+    int l = 5, c = 24, bo = 1UL;
+    static unsigned int cklst_estado = 0;
+    cklst_estado |= i ; 
+
+    CKLSITEM(l++, c + 11, 0, "avaliacao");
+    CKLSITEM(l++, c, 0, " ");
+    CKLSITEM(l++, c, cklst_estado & bo, ITEM1_1); bo <<= 1;
+    CKLSITEM(l++, c, cklst_estado & bo, ITEM1_2); bo <<= 1;
+    CKLSITEM(l++, c, cklst_estado & bo, ITEM1_3); bo <<= 1;
+    CKLSITEM(l++, c, cklst_estado & bo, ITEM1_4); bo <<= 1;
+    CKLSITEM(l++, c, 0, " ");
+    CKLSITEM(l++, c, cklst_estado & bo, ITEM2_1); bo <<= 1;
+    CKLSITEM(l++, c, cklst_estado & bo, ITEM2_2); bo <<= 1;
+    CKLSITEM(l++, c, cklst_estado & bo, ITEM2_3); bo <<= 1;
+    CKLSITEM(l++, c, 0, " ");
+    CKLSITEM(l++, c, cklst_estado & bo, ITEM3_1); bo <<= 1;
+    CKLSITEM(l++, c, cklst_estado & bo, ITEM3_2); bo <<= 1;
+    CKLSITEM(l++, c, cklst_estado & bo, ITEM3_3); bo <<= 1;
+    CKLSITEM(l++, c, 0, " ");
+    CKLSITEM(l, c, cklst_estado & bo, ITEM4);
+}
+
+
diff --git a/src/checklist.h b/src/checklist.h
new file mode 100644
index 0000000..fbe2506
--- /dev/null
+++ b/src/checklist.h
@@ -0,0 +1,26 @@
+#ifndef CHECKLIST_H_
+#define CHECKLIST_H_
+
+void tela_checklist(int i);
+
+#define ITEM1_1 "1.1 listar ordenado por chave"
+#define ITEM1_2 "1.2 cardinalidade do conjunto"
+#define ITEM1_3 "1.3 verificar se conj. vazio"
+#define ITEM1_4 "1.4 tornar o conjunto vazio"
+
+#define ITEM2_1 "2.1 inserir elemento no conjunto"
+#define ITEM2_2 "2.2 excluir elemento do conjunto"
+#define ITEM2_3 "2.3 verif. se elem. esta no conj."
+
+#define ITEM3_1 "3.1 itersecao entre conjuntos"
+#define ITEM3_2 "3.2 uniao entre conjuntos"
+#define ITEM3_3 "3.3 subtracao de conjuntos"
+
+#define ITEM4 "4 imprimir arvore rubro negra"
+
+enum {I1_1, I1_2, I1_3, I1_4, I2_1, I2_2, I2_3, \
+      I3_1, I3_2, I3_3, I4};
+
+#endif
+
+
diff --git a/src/conjunto_ordenado.h b/src/conjunto_ordenado.h
index b94287e..cccae08 100644
--- a/src/conjunto_ordenado.h
+++ b/src/conjunto_ordenado.h
@@ -137,6 +137,9 @@ void conjord_imprime_conjunto(conjord *c);
 #define INFO(x) printf("%s%s%s%s", S_INV, S_INFO, x, S_NORM)
 #define INFO_ST(x) printf("%s%s%s%s", S_INV, S_INFO_ST, x, S_NORM)
 #define CM printf("%s", m); fflush(stdout); getc(stdin)
+#define CKLSITEM(l,c,b,x) \
+    if (b) printf(S_CHKLST_DONE, l, c, x); \
+    else printf(S_CHKLST, l, c, x)
 
 #endif
 
diff --git a/src/jcurses.h b/src/jcurses.h
index de499cd..a1245e4 100644
--- a/src/jcurses.h
+++ b/src/jcurses.h
@@ -17,5 +17,7 @@
 #define S_NORM "\033[0m"
 #define S_INFO "\033[24;0H"
 #define S_INFO_ST "\033[0;65H"
+#define S_CHKLST "\033[%d;%dH%s\033[0m"
+#define S_CHKLST_DONE "\033[7m\033[%d;%dH%s\033[0m"
 
 #endif
diff --git a/src/makefile b/src/makefile
index 94af2b5..2ddd9d1 100644
--- a/src/makefile
+++ b/src/makefile
@@ -4,9 +4,9 @@
 
 C=gcc
 S=main.c conjunto_ordenado.c red_black.c testa_rb.c \
-  testa_item_1.c testa_item_2.c testa_item_3.c
+  testa_item_1.c testa_item_2.c testa_item_3.c checklist.c
 O=main.o conjunto_ordenado.o red_black.o testa_rb.o \
-  testa_item_1.o testa_item_2.o testa_item_3.o
+  testa_item_1.o testa_item_2.o testa_item_3.o checklist.o
 E=rodeme
 D=-g
 
diff --git a/src/testa_item_1.c b/src/testa_item_1.c
index 271d50a..0368fd7 100644
--- a/src/testa_item_1.c
+++ b/src/testa_item_1.c
@@ -3,6 +3,7 @@
 #include <time.h>
 #include "conjunto_ordenado.h"
 #include "testa_item_1.h"
+#include "checklist.h"
 
 static void imprime_meu_tipo(void *);
 
@@ -47,7 +48,15 @@ void testa_item_1(const char *m)
      */
     conjord_seta_imprime_elemento(imprime_meu_tipo);
 
+    LTELA;
+    tela_checklist(0);
+    CM;
+
     conjord *cj_a = conjord_cria("A");
+    LTELA;
+    tela_checklist(1 << I1_1);
+    CM;
+
     LTELA;
     adiciona_lista_de_elementos(cj_a);
     INFO("* item 2.1 insere 20 elem. chave unica entre 1 a 99");
@@ -55,13 +64,16 @@ void testa_item_1(const char *m)
 
     LTELA;
     conjord_imprime_arvore_rb(cj_a, 1);
-    INFO("* item 3 arvore atual");
+    INFO("* item 4 arvore atual");
     CM;
 
     LTELA;
     conjord_imprime_conjunto(cj_a);
     INFO("* item 1.1 crescente por chave de id.");
     CM;
+    LTELA;
+    tela_checklist((1 << I4));
+    CM;
 
     conjord_destroi(cj_a);
 }

commit c8ea0e7d23cf1512d5904a92c9b1b3829c266051
Author: Joilnen <joilnen@gmail.com>
Date:   Mon Jan 3 07:30:00 2022 -0300

    melhorarando a intercalacao das telas e as mensagens

diff --git a/src/conjunto_ordenado.h b/src/conjunto_ordenado.h
index cccae08..557b131 100644
--- a/src/conjunto_ordenado.h
+++ b/src/conjunto_ordenado.h
@@ -134,7 +134,8 @@ void conjord_imprime_conjunto(conjord *c);
  */
 #define LTELA printf(LIMPA_TELA)
 #define TIPO_DE_TERMINAL TCOLOR
-#define INFO(x) printf("%s%s%s%s", S_INV, S_INFO, x, S_NORM)
+#define INFO(x) printf("%s%s%s", S_INFO, x, S_NORM)
+#define INFO2(x) printf("%s%s%s", S_INFO2, x, S_NORM)
 #define INFO_ST(x) printf("%s%s%s%s", S_INV, S_INFO_ST, x, S_NORM)
 #define CM printf("%s", m); fflush(stdout); getc(stdin)
 #define CKLSITEM(l,c,b,x) \
diff --git a/src/jcurses.h b/src/jcurses.h
index a1245e4..212a524 100644
--- a/src/jcurses.h
+++ b/src/jcurses.h
@@ -18,6 +18,7 @@
 #define S_INFO "\033[24;0H"
 #define S_INFO_ST "\033[0;65H"
 #define S_CHKLST "\033[%d;%dH%s\033[0m"
-#define S_CHKLST_DONE "\033[7m\033[%d;%dH%s\033[0m"
+#define S_CHKLST_DONE "\033[46m\033[30m\033[%d;%dH%s\033[0m"
+#define S_INFO2 "\033[46m\033[30m\033[24;0H"
 
 #endif
diff --git a/src/testa_item_1.c b/src/testa_item_1.c
index 0368fd7..ad8efc5 100644
--- a/src/testa_item_1.c
+++ b/src/testa_item_1.c
@@ -53,26 +53,30 @@ void testa_item_1(const char *m)
     CM;
 
     conjord *cj_a = conjord_cria("A");
-    LTELA;
-    tela_checklist(1 << I1_1);
-    CM;
-
     LTELA;
     adiciona_lista_de_elementos(cj_a);
     INFO("* item 2.1 insere 20 elem. chave unica entre 1 a 99");
     CM;
+    LTELA;
+    tela_checklist(1 << I2_1);
+    CM;
 
     LTELA;
     conjord_imprime_arvore_rb(cj_a, 1);
     INFO("* item 4 arvore atual");
     CM;
 
+    LTELA;
+    tela_checklist((1 << I4));
+    CM;
+
     LTELA;
     conjord_imprime_conjunto(cj_a);
     INFO("* item 1.1 crescente por chave de id.");
     CM;
+
     LTELA;
-    tela_checklist((1 << I4));
+    tela_checklist((1 << I1_1));
     CM;
 
     conjord_destroi(cj_a);

commit 350d45fbce1de5c007d3e6d9b390c4c5e966a7d1
Author: Joilnen <joilnen@gmail.com>
Date:   Mon Jan 3 12:48:39 2022 -0300

    decrementando cardinalidade na delecao de elemento do conjunto

diff --git a/src/conjunto_ordenado.c b/src/conjunto_ordenado.c
index 2a2ae6a..818e71d 100644
--- a/src/conjunto_ordenado.c
+++ b/src/conjunto_ordenado.c
@@ -59,6 +59,9 @@ int conjord_insere_elemento(conjord *a, int chave, void *elemento)
 void conjord_deleta_elemento(conjord *a, int chave)
 {
     rb_delete(&a->pr, rb_search(a->pr, chave));
+    a->cardinalidade--;
+    if(a->cardinalidade < 0)
+        a->cardinalidade = 0;
 }
 
 int conjord_cardinalidade(conjord *c)

commit 940e73df5354e8b438e0d5020e21246c429ea148
Author: Joilnen <joilnen@gmail.com>
Date:   Mon Jan 3 13:06:56 2022 -0300

    removendo funcoes que n foram usadas

diff --git a/src/red_black.c b/src/red_black.c
index 5cd3def..f97445b 100644
--- a/src/red_black.c
+++ b/src/red_black.c
@@ -307,11 +307,6 @@ int rb_delete(rb_n **t, rb_n *z)
     return 0;
 }
 
-int rb_exclui_elem(rb_n *a, int k)
-{
-    return 0;
-}
-
 rb_n* rb_intersec(rb_n *a, rb_n *b)
 {
     return NULL;
diff --git a/src/red_black.h b/src/red_black.h
index 27ff6bc..98705dc 100644
--- a/src/red_black.h
+++ b/src/red_black.h
@@ -86,12 +86,6 @@ rb_n *rb_search(rb_n *t, int k);
  */
 int rb_delete(rb_n **t, rb_n *z);
 
-/**
- * @param a noh raiz da arvore
- * @param k chave do elemento a ser excluido
- */
-int rb_exclui_elem(rb_n *a, int k);
-
 /**
  * @param a noh raiz da arvore
  * @param k chave do elemento a ser checado

commit c3bd058cfe0ab65b6cde02f11b92ccbb1b69a65f
Author: Joilnen <joilnen@gmail.com>
Date:   Mon Jan 3 14:53:07 2022 -0300

    adicionando arquivos para documentacao

diff --git a/doc/tex/code/del.c b/doc/tex/code/del.c
new file mode 100644
index 0000000..6af7bfe
--- /dev/null
+++ b/doc/tex/code/del.c
@@ -0,0 +1,121 @@
+/**
+ * deleta noh da arvore red black
+ * @param t ponteiro duplo para raiz, assim pq ele pode ser alterado dentro da funcao
+ * e manter a alteracao depois do retorno da fucao
+ * @param z ponteiro para o noh a ser deletado, para deletar por chave o TAD deve
+ * passar a saida da funcao pesquisar, num arranjo funcional na chamada
+ */
+int rb_delete(rb_n **t, rb_n *z)
+{
+    rb_n *x = &rb_s;
+    rb_n *y = z;
+    unsigned char yoc = z->c;
+
+    if (z->l == &rb_s)
+    {
+        x = z->r;
+        rb_transplant(t, z, z->r);
+    }
+    else if (z->r == &rb_s)
+    {
+        x = z->l;
+        rb_transplant(t, z, z->l);
+    }
+    else
+    {
+        // y = tree_minimum(z->r);
+        y = sucessor(z);
+        yoc = y->c;
+        x = y->r;
+        if (y->p == z)
+            x->p = y;
+        else
+        {
+            rb_transplant(t, y, y->r);
+            y->r = z->r;
+            y->r->p = y;
+        }
+        rb_transplant(t, z, y);
+        y->l = z->l;
+        y->l->p = y;
+        y->c = z->c;
+    }
+
+    if (yoc == BLACK)
+    {
+        rb_n *w = &rb_s;
+        while (x != *t && x->c == BLACK)
+        {
+            if (x == x->p->l)
+            {
+                w = x->p->r;
+                if (w->c == RED)
+                {
+                    w->c = BLACK;
+                    x->p->c = RED;
+                    rb_rot_esq(t, x->p);
+                    w = x->p->r;
+                }
+
+                if (w->l->c == BLACK && w->r->c == BLACK) 
+                {
+                    w->c = RED;
+                    x = x->p;
+                }
+                else
+                {
+                    if (w->r->c == BLACK)
+                    {
+                        w->l->c = BLACK;
+                        w->c = RED;
+                        rb_rot_dir(t, w);
+                        w = x->p->r;
+                    }
+
+                    w->c = x->p->c;
+                    x->p->c = BLACK;
+                    w->r->c = BLACK;
+                    rb_rot_esq(t, x->p);
+                    x = *t;
+                }
+            }
+            else 
+            {
+                w = x->p->l;
+                if (w->c == RED)
+                {
+                    w->c = BLACK;
+                    x->p->c = RED;
+                    rb_rot_dir(t, x->p);
+                    w = x->p->l;
+                }
+
+                if (w->l->c == BLACK && w->r->c == BLACK)
+                {
+                    w->c = RED;
+                    x = x->p;
+                }
+                else
+                {
+                    if (w->l->c == BLACK)
+                    {
+                        w->r->c = BLACK;
+                        w->c = RED;
+                        rb_rot_esq(t, w);
+                        w = x->p->l;
+                    }
+
+                    w->c = x->p->c;
+                    x->p->c = BLACK;
+                    w->l->c = BLACK;
+                    rb_rot_dir(t, x->p);
+                    x = *t;
+                }
+            }
+        }
+        x->c = BLACK;
+    } /* if (yoc == BLACK) */
+
+    return 0;
+}
+
diff --git a/doc/tex/code/inc.c b/doc/tex/code/inc.c
new file mode 100644
index 0000000..63e50ca
--- /dev/null
+++ b/doc/tex/code/inc.c
@@ -0,0 +1,103 @@
+/**
+ * inclusao baseado no livro do cormen
+ * e nas notas de aula da prof. Luciana
+ */
+int rb_insert(rb_n **t, rb_n *z)
+{
+    /**
+     * y receberah noh pai imediato do noh adicionado
+     * x eh um ponteiro temporario para iteracao feita 
+     * no loop while a seguir para chegar ao noh folha
+     */
+    rb_n *y = &rb_s;
+    rb_n *x = *t;
+
+    /**
+     * itera para chegar no noh folha
+     * da posicao a ser inserido o novo noh
+     */
+    while (x != &rb_s)
+    {
+        y = x;
+        if (z->k < x->k)
+            x = x->l;
+        else if (z->k > x->k)
+            x = x->r;
+        else
+            return -1;
+    }
+
+    /**
+     * seta noh pai para o noh adicionado
+     */
+    z->p = y;
+
+    /**
+     * se esse noh adicionado eh unico y permance
+     * nulo que neste caso apontaria para o pai que eh nulo
+     * neste cenario torna o noh adicionado raiz
+     * caso n adiciona na esquera ou diretia de acordo
+     * com o valor da chave, noh recebe RED como padrao
+     */
+    if (y == &rb_s)
+        *t = z;
+    else if (z->k < y->k)
+        y->l = z;
+    else
+        y->r = z;
+    z->l = z->r = &rb_s;
+    z->c = RED;
+
+    /** ajuste */
+    while (z->p->c == RED)
+    {
+        if (z->p == z->p->p->l)
+        {
+            y = z->p->p->r;
+            if (y->c == RED)
+            {
+                z->p->c = BLACK;
+                y->c = BLACK;
+                z->p->p->c = RED;
+                z = z->p->p;
+            }
+            else 
+            {
+                if (z == z->p->r)
+                {
+                    z = z->p;
+                    rb_rot_esq(t, z);
+                }
+                z->p->c = BLACK;
+                z->p->p->c = RED;
+                rb_rot_dir(t, z->p->p);
+            }
+        }
+        else
+        {
+            y = z->p->p->l;
+            if (y->c == RED)
+            {
+                z->p->c = BLACK;
+                y->c = BLACK;
+                z->p->p->c = RED;
+                z = z->p->p;
+            }
+            else 
+            {
+                if (z == z->p->l)
+                {
+                    z = z->p;
+                    rb_rot_dir(t, z);
+                }
+                z->p->c = BLACK;
+                z->p->p->c = RED;
+                rb_rot_esq(t, z->p->p);
+            }
+        }
+    }
+    (*t)->c = BLACK;
+
+    return 0;
+}
+
diff --git a/doc/tex/code/incdel.c b/doc/tex/code/incdel.c
new file mode 100644
index 0000000..f49e5b6
--- /dev/null
+++ b/doc/tex/code/incdel.c
@@ -0,0 +1,83 @@
+/**
+ * funcao que faz trocas auxiliares na delecao
+ * @param u noh que eh trocado por outro em seu lugar
+ * @param v noh que eh colocado no lugar do noh anterior
+ */
+static int rb_transplant(rb_n **t, rb_n *u, rb_n *v)
+{
+    if (u->p == &rb_s)
+        *t = v;
+    else if (u == u->p->l)
+        u->p->l = v;
+    else
+        u->p->r = v;
+    if(v)
+        v->p = u->p;
+}
+
+/**
+ * @param x noh raiz
+ * retorma o noh mais a esquerda na arvore 
+ * ou subarvore
+ */
+static rb_n *tree_minimum(rb_n *x)
+{
+    rb_n *a = x;
+    while (a->l != &rb_s)
+        a = a->l;
+    return a;
+}
+
+/**
+ * sucessor baseado nas notas e no livro do cormen, reescrito
+ * e consegui diminuir em duas linhas do algoritmo original
+ */
+static rb_n* sucessor(rb_n *x)
+{
+    rb_n *y = NULL;
+    if (x->r != &rb_s)
+        return tree_minimum(x->r);
+    while ((y = x->p) && x == y->r)
+        x = y;
+    return y;
+}
+
+
+int rb_rot_esq(rb_n **t, rb_n *x)
+{
+    rb_n *y = x->r;
+    x->r = y->l;
+    if (y->l != &rb_s)
+        y->l->p = x;
+    y->p = x->p;
+    if (x->p == &rb_s)
+        *t = y;
+    else if (x == x->p->l)
+        x->p->l = y;
+    else
+        x->p->r = y;
+    y->l = x;
+    x->p = y;
+
+    return 0;
+}
+
+int rb_rot_dir(rb_n **t, rb_n *x)
+{
+    rb_n *y = x->l;
+    x->l = y->r;
+    if (y->r != &rb_s)
+        y->r->p = x;
+    y->p = x->p;
+    if (x->p == &rb_s)
+        *t = y;
+    else if (x == x->p->r)
+        x->p->r = y;
+    else
+        x->p->l = y;
+    y->r = x;
+    x->p = y;
+
+    return 0;
+}
+
diff --git a/doc/tex/code/utils.c b/doc/tex/code/utils.c
new file mode 100644
index 0000000..ae8b953
--- /dev/null
+++ b/doc/tex/code/utils.c
@@ -0,0 +1,84 @@
+/**
+ * funcao que faz trocas auxiliares na delecao
+ * @param u noh que eh trocado por outro em seu lugar
+ * @param v noh que eh colocado no lugar do noh anterior
+ */
+static int rb_transplant(rb_n **t, rb_n *u, rb_n *v)
+{
+    if (u->p == &rb_s)
+        *t = v;
+    else if (u == u->p->l)
+        u->p->l = v;
+    else
+        u->p->r = v;
+    if(v)
+        v->p = u->p;
+    return 0;
+}
+
+/**
+ * @param x noh raiz
+ * retorma o noh mais a esquerda na arvore 
+ * ou subarvore
+ */
+static rb_n *tree_minimum(rb_n *x)
+{
+    rb_n *a = x;
+    while (a->l != &rb_s)
+        a = a->l;
+    return a;
+}
+
+/**
+ * sucessor baseado nas notas e no livro do cormen, reescrito
+ * e consegui diminuir em duas linhas do algoritmo original
+ */
+static rb_n* sucessor(rb_n *x)
+{
+    rb_n *y = NULL;
+    if (x->r != &rb_s)
+        return tree_minimum(x->r);
+    while ((y = x->p) && x == y->r)
+        x = y;
+    return y;
+}
+
+
+int rb_rot_esq(rb_n **t, rb_n *x)
+{
+    rb_n *y = x->r;
+    x->r = y->l;
+    if (y->l != &rb_s)
+        y->l->p = x;
+    y->p = x->p;
+    if (x->p == &rb_s)
+        *t = y;
+    else if (x == x->p->l)
+        x->p->l = y;
+    else
+        x->p->r = y;
+    y->l = x;
+    x->p = y;
+
+    return 0;
+}
+
+int rb_rot_dir(rb_n **t, rb_n *x)
+{
+    rb_n *y = x->l;
+    x->l = y->r;
+    if (y->r != &rb_s)
+        y->r->p = x;
+    y->p = x->p;
+    if (x->p == &rb_s)
+        *t = y;
+    else if (x == x->p->r)
+        x->p->r = y;
+    else
+        x->p->l = y;
+    y->r = x;
+    x->p = y;
+
+    return 0;
+}
+
diff --git a/doc/tex/relatorio.pdf b/doc/tex/relatorio.pdf
index ef705d1..6145a9e 100644
Binary files a/doc/tex/relatorio.pdf and b/doc/tex/relatorio.pdf differ
diff --git a/doc/tex/relatorio.tex b/doc/tex/relatorio.tex
index 9c07db1..7f65f48 100644
--- a/doc/tex/relatorio.tex
+++ b/doc/tex/relatorio.tex
@@ -147,7 +147,6 @@ com \enf{insere_elemento}
  * @rb_n noh red black
  * @k chave (k de key)
  * @c cor (c de color ou cor, 0-black, 1-red)
- * @t tipo (t de tipo ou type)
  * @d dado (de de data ou dados)
  * @l @r @p l-eft filho a esquerda, r-ight filho a direta e p-arent, noh pai
  */
@@ -200,9 +199,16 @@ int rotaciona_direita(rb_n *r, rb_n *w);
 
 void (*imprime_elemento)(rb_n *);
 int seta_imprime_elemento(void (*i)(rb_n *n));
+
+
 \end{lstlisting}
 
-\begin{figure}
+\lstinputlisting [language=c] {code/inc.c}
+\lstinputlisting [language=c] {code/del.c}
+\lstinputlisting [language=c] {code/utils.c}
+
+\section {TAD}
+\begin{figure}[H]
     \begin{center}
     \includegraphics [scale = .4] {figs/ADT}
         \caption{Diagrama TAD}
diff --git a/src/red_black.c b/src/red_black.c
index f97445b..447027f 100644
--- a/src/red_black.c
+++ b/src/red_black.c
@@ -157,6 +157,8 @@ static int rb_transplant(rb_n **t, rb_n *u, rb_n *v)
         u->p->r = v;
     if(v)
         v->p = u->p;
+
+    return 0;
 }
 
 /**

commit 606e835804dbc1341a9aa23b5432009a907b80b9
Author: Joilnen <joilnen@gmail.com>
Date:   Mon Jan 3 14:53:53 2022 -0300

    removendo arquivo nao mais usado

diff --git a/doc/tex/code/incdel.c b/doc/tex/code/incdel.c
deleted file mode 100644
index f49e5b6..0000000
--- a/doc/tex/code/incdel.c
+++ /dev/null
@@ -1,83 +0,0 @@
-/**
- * funcao que faz trocas auxiliares na delecao
- * @param u noh que eh trocado por outro em seu lugar
- * @param v noh que eh colocado no lugar do noh anterior
- */
-static int rb_transplant(rb_n **t, rb_n *u, rb_n *v)
-{
-    if (u->p == &rb_s)
-        *t = v;
-    else if (u == u->p->l)
-        u->p->l = v;
-    else
-        u->p->r = v;
-    if(v)
-        v->p = u->p;
-}
-
-/**
- * @param x noh raiz
- * retorma o noh mais a esquerda na arvore 
- * ou subarvore
- */
-static rb_n *tree_minimum(rb_n *x)
-{
-    rb_n *a = x;
-    while (a->l != &rb_s)
-        a = a->l;
-    return a;
-}
-
-/**
- * sucessor baseado nas notas e no livro do cormen, reescrito
- * e consegui diminuir em duas linhas do algoritmo original
- */
-static rb_n* sucessor(rb_n *x)
-{
-    rb_n *y = NULL;
-    if (x->r != &rb_s)
-        return tree_minimum(x->r);
-    while ((y = x->p) && x == y->r)
-        x = y;
-    return y;
-}
-
-
-int rb_rot_esq(rb_n **t, rb_n *x)
-{
-    rb_n *y = x->r;
-    x->r = y->l;
-    if (y->l != &rb_s)
-        y->l->p = x;
-    y->p = x->p;
-    if (x->p == &rb_s)
-        *t = y;
-    else if (x == x->p->l)
-        x->p->l = y;
-    else
-        x->p->r = y;
-    y->l = x;
-    x->p = y;
-
-    return 0;
-}
-
-int rb_rot_dir(rb_n **t, rb_n *x)
-{
-    rb_n *y = x->l;
-    x->l = y->r;
-    if (y->r != &rb_s)
-        y->r->p = x;
-    y->p = x->p;
-    if (x->p == &rb_s)
-        *t = y;
-    else if (x == x->p->r)
-        x->p->r = y;
-    else
-        x->p->l = y;
-    y->r = x;
-    x->p = y;
-
-    return 0;
-}
-

commit f92cf9336c85bcbdf8ceb1d29de72be3eeb8249e
Author: Joilnen <joilnen@gmail.com>
Date:   Mon Jan 3 16:16:01 2022 -0300

    atualizando documentacao

diff --git a/doc/tex/code/inc.c b/doc/tex/code/inc.c
index 63e50ca..96c00d1 100644
--- a/doc/tex/code/inc.c
+++ b/doc/tex/code/inc.c
@@ -1,20 +1,25 @@
 /**
- * inclusao baseado no livro do cormen
- * e nas notas de aula da prof. Luciana
+ * inclusão baseado nas notas de aula da prof. Luciana
  */
 int rb_insert(rb_n **t, rb_n *z)
 {
     /**
-     * y receberah noh pai imediato do noh adicionado
-     * x eh um ponteiro temporario para iteracao feita 
-     * no loop while a seguir para chegar ao noh folha
+     * y aponta para nó sentinela, rb_s (nó sentinela)
+     * x é um ponteiro temporário para iteração feita 
+     * no loop while mas tem como valor inicial a raiz
+     * passada em t que é ponteiro duplo por que, poderá 
+     * ser alterada nesta função e desejamos que estas alterações
+     * persistam
      */
     rb_n *y = &rb_s;
     rb_n *x = *t;
 
     /**
-     * itera para chegar no noh folha
-     * da posicao a ser inserido o novo noh
+     * itera para chegar no nó folha da posicao a ser inserido o novo noh,
+     * como está explícito, caso a chave seja menor que a do nó testado atualiza a refencia x 
+     * com o nó a esquerda caso seja maior com o nó a diretia, em caso diferente destes
+     * retorna a função com código de erro, seria o caso em que já existe chave igual
+     * na árvore
      */
     while (x != &rb_s)
     {
diff --git a/doc/tex/relatorio.pdf b/doc/tex/relatorio.pdf
index 6145a9e..fa90c6d 100644
Binary files a/doc/tex/relatorio.pdf and b/doc/tex/relatorio.pdf differ
diff --git a/doc/tex/relatorio.tex b/doc/tex/relatorio.tex
index 7f65f48..fe33786 100644
--- a/doc/tex/relatorio.tex
+++ b/doc/tex/relatorio.tex
@@ -7,10 +7,11 @@
 
 % \fancyhead{}
 % \fancyfoot{}
-\usepackage{listings}
+\usepackage{listingsutf8}
 \usepackage{xcolor}
 
-\definecolor{codegreen}{rgb}{0,0.6,0}
+% \definecolor{codegreen}{rgb}{0,0.6,0}
+\definecolor{codegreen}{rgb}{.6,.3,0}
 \definecolor{codegray}{rgb}{0.5,0.5,0.5}
 \definecolor{codepurple}{rgb}{0.58,0,0.82}
 \definecolor{backcolour}{rgb}{0.95,0.95,0.92}
@@ -35,7 +36,12 @@
     tabsize=2
 }
 
-\lstset{style=mystyle}
+\lstset{
+    style=mystyle,
+    language=C,
+    inputencoding=utf8,
+    texcl=true
+}
 
 % \renewcommand{\headrulewidth}{0pt} \renewcommand{\footrulewidth}{0pt} 
 % \fancyhead[LO, LE]{\thepage}

commit a0cf7950524a228bcb8782679de240207ca846d9
Author: Joilnen <joilnen@gmail.com>
Date:   Mon Jan 3 17:25:43 2022 -0300

    tela incial de informacoes

diff --git a/src/testa_item_1.c b/src/testa_item_1.c
index ad8efc5..b2c47b6 100644
--- a/src/testa_item_1.c
+++ b/src/testa_item_1.c
@@ -85,11 +85,17 @@ void testa_item_1(const char *m)
 void tela_item_1(const char *m)
 {
     LTELA;
-    printf("Sera efetuado testes do item 1\n");
+    int l = 5, c = 24;
+    CKLSITEM(l++, c, 0, "serah efetuado os testes:");
+    CKLSITEM(l++, c, 0, "insersao de elementos no conjnto");
+    CKLSITEM(l++, c, 0, "com chaves randomicas, mostra do");
+    CKLSITEM(l++, c, 0, "estado da arvore red black");
+    CKLSITEM(l++, c, 0, "e ordenacao dos elementos do conjunto");
+    CKLSITEM(l++, c, 0, "o tipo de dado do usuario aqui eh uma");
+    CKLSITEM(l++, c, 0, "estrutura com duas strings, nome e telefone");
     CM;
 }
 
-
 void imprime_meu_tipo(void *n)
 {
     printf("Nome: %s \t", ((meu_tipo *)n)->nome);

commit 08ede9cad4fad62c5d02b318fefd968723b5260d
Author: Joilnen <joilnen@gmail.com>
Date:   Tue Jan 4 02:31:34 2022 -0300

    inicio do segundo lote de testes

diff --git a/src/testa_item_1.c b/src/testa_item_1.c
index b2c47b6..ebf7d4f 100644
--- a/src/testa_item_1.c
+++ b/src/testa_item_1.c
@@ -55,7 +55,7 @@ void testa_item_1(const char *m)
     conjord *cj_a = conjord_cria("A");
     LTELA;
     adiciona_lista_de_elementos(cj_a);
-    INFO("* item 2.1 insere 20 elem. chave unica entre 1 a 99");
+    INFO("* item 2.1 inserir 20 elem. chave unica entre 1 a 99");
     CM;
     LTELA;
     tela_checklist(1 << I2_1);
@@ -63,7 +63,7 @@ void testa_item_1(const char *m)
 
     LTELA;
     conjord_imprime_arvore_rb(cj_a, 1);
-    INFO("* item 4 arvore atual");
+    INFO("* item 4 mostrar arvore atual");
     CM;
 
     LTELA;
@@ -72,7 +72,7 @@ void testa_item_1(const char *m)
 
     LTELA;
     conjord_imprime_conjunto(cj_a);
-    INFO("* item 1.1 crescente por chave de id.");
+    INFO("* item 1.1 ordenar por chave de identificao");
     CM;
 
     LTELA;
@@ -87,7 +87,7 @@ void tela_item_1(const char *m)
     LTELA;
     int l = 5, c = 24;
     CKLSITEM(l++, c, 0, "serah efetuado os testes:");
-    CKLSITEM(l++, c, 0, "insersao de elementos no conjnto");
+    CKLSITEM(l++, c, 0, "insersao de elementos no conjunto");
     CKLSITEM(l++, c, 0, "com chaves randomicas, mostra do");
     CKLSITEM(l++, c, 0, "estado da arvore red black");
     CKLSITEM(l++, c, 0, "e ordenacao dos elementos do conjunto");
diff --git a/src/testa_item_2.c b/src/testa_item_2.c
index 481f6e6..349d25e 100644
--- a/src/testa_item_2.c
+++ b/src/testa_item_2.c
@@ -5,13 +5,26 @@
 void tela_item_2(const char *m)
 {
     LTELA;
-    printf("Testa item 2\n");
+    int l = 5, c = 24, f;
+    char mens[6][40] =
+    {
+        "serah efetuado os testes:",
+        "exclusao de elemento do conjunto",
+        "verif. se elemento pertence ao conjunto",
+        "cardinalide do conjunto",
+        "verif. se conjunto eh vazio",
+        "tornar conjunto vazio"
+    };
+    for (f = 0; f < 7; f++)
+        CKLSITEM(l++, c, 0, mens[f]);
     CM;
 }
 
 
 void testa_item_2(const char *m)
 {
-
+    LTELA;
+    printf("Testa item 2\n");
+    CM;
 }
 

commit 100022cf815464feeaf910c8b514f28fb9b62163
Author: Joilnen <joilnen@gmail.com>
Date:   Tue Jan 4 02:59:12 2022 -0300

    ressaltando algumas mensagens na aprensentacao dos testes

diff --git a/src/jcurses.h b/src/jcurses.h
index 212a524..cb6e417 100644
--- a/src/jcurses.h
+++ b/src/jcurses.h
@@ -15,7 +15,7 @@
 #define S_VERM "\033[41m\033[37m"
 #define S_INV  "\033[7m"
 #define S_NORM "\033[0m"
-#define S_INFO "\033[24;0H"
+#define S_INFO "\033[24;0H\033[7m"
 #define S_INFO_ST "\033[0;65H"
 #define S_CHKLST "\033[%d;%dH%s\033[0m"
 #define S_CHKLST_DONE "\033[46m\033[30m\033[%d;%dH%s\033[0m"
diff --git a/src/testa_item_1.c b/src/testa_item_1.c
index ebf7d4f..90757c4 100644
--- a/src/testa_item_1.c
+++ b/src/testa_item_1.c
@@ -86,7 +86,7 @@ void tela_item_1(const char *m)
 {
     LTELA;
     int l = 5, c = 24;
-    CKLSITEM(l++, c, 0, "serah efetuado os testes:");
+    CKLSITEM(l++, c, 0, "\033[21mserah efetuado os testes:\033[0m");
     CKLSITEM(l++, c, 0, "insersao de elementos no conjunto");
     CKLSITEM(l++, c, 0, "com chaves randomicas, mostra do");
     CKLSITEM(l++, c, 0, "estado da arvore red black");
diff --git a/src/testa_item_2.c b/src/testa_item_2.c
index 349d25e..80d0813 100644
--- a/src/testa_item_2.c
+++ b/src/testa_item_2.c
@@ -8,7 +8,7 @@ void tela_item_2(const char *m)
     int l = 5, c = 24, f;
     char mens[6][40] =
     {
-        "serah efetuado os testes:",
+        "\033[21mserah efetuado os testes:\033[0m",
         "exclusao de elemento do conjunto",
         "verif. se elemento pertence ao conjunto",
         "cardinalide do conjunto",

commit 372fbb71f972ced89f2440f43c73610d7e35a716
Author: Joilnen <joilnen@gmail.com>
Date:   Tue Jan 4 03:25:11 2022 -0300

    limpando o codigo de codigos escape, n eh elegante

diff --git a/src/jcurses.h b/src/jcurses.h
index cb6e417..95c78df 100644
--- a/src/jcurses.h
+++ b/src/jcurses.h
@@ -11,6 +11,8 @@
  */
 
 #define LIMPA_TELA "\033[H\033[J"
+#define S_CM "\033[24;62H"
+#define S_UNDERL "\033[21m"
 #define S_AZUL "\033[44m\033[37m"
 #define S_VERM "\033[41m\033[37m"
 #define S_INV  "\033[7m"
diff --git a/src/main.c b/src/main.c
index 7d68692..9ee3774 100644
--- a/src/main.c
+++ b/src/main.c
@@ -11,7 +11,7 @@ int main()
     /**
      * mensagem de controle
      */
-    const char mc[] = "\033[24;62H* tecle enter * ";
+    const char mc[] = S_CM"* tecle enter * ";
 
     /**
      * aqui poderia ser escrito 
diff --git a/src/testa_item_1.c b/src/testa_item_1.c
index 90757c4..d60c52d 100644
--- a/src/testa_item_1.c
+++ b/src/testa_item_1.c
@@ -86,7 +86,7 @@ void tela_item_1(const char *m)
 {
     LTELA;
     int l = 5, c = 24;
-    CKLSITEM(l++, c, 0, "\033[21mserah efetuado os testes:\033[0m");
+    CKLSITEM(l++, c, 0, S_UNDERL"serah efetuado os testes:"S_NORM);
     CKLSITEM(l++, c, 0, "insersao de elementos no conjunto");
     CKLSITEM(l++, c, 0, "com chaves randomicas, mostra do");
     CKLSITEM(l++, c, 0, "estado da arvore red black");

commit ba37dde91269497881bab9a995a59756bacb5452
Author: Joilnen <joilnen@gmail.com>
Date:   Tue Jan 4 03:31:58 2022 -0300

    removendo comentario que n eh mais necessario

diff --git a/src/main.c b/src/main.c
index 9ee3774..a51b854 100644
--- a/src/main.c
+++ b/src/main.c
@@ -13,17 +13,6 @@ int main()
      */
     const char mc[] = S_CM"* tecle enter * ";
 
-    /**
-     * aqui poderia ser escrito 
-     * "case 0:
-     *      tela_item_1();
-     *      getc(stdin);
-     *      testa_item_1();
-     *      break;
-     * "
-     * em um unico swtich mas assim ficou mais legivel 
-     * e limpo
-     */
     for (op = 0; op < nitems; ++op)
     {
         switch (op)

commit 5086ad523fa39de8a0f081f42cda914b2f41acc7
Author: Joilnen <joilnen@gmail.com>
Date:   Tue Jan 4 03:41:43 2022 -0300

    ainda limpando os codigos escapes

diff --git a/src/conjunto_ordenado.c b/src/conjunto_ordenado.c
index 818e71d..3a1d69f 100644
--- a/src/conjunto_ordenado.c
+++ b/src/conjunto_ordenado.c
@@ -107,7 +107,7 @@ void conjord_imprime_lista(int *l, int s)
 {
     int i;
     for (i = 0; i < s; i++)
-        printf("\033[%d;78H%d", l[i] + 1, l[i]);
+        printf(S_LIST, l[i] + 1, l[i]);
 }
 
 void (*conjord_imprime_elemento)(void *n);
diff --git a/src/jcurses.h b/src/jcurses.h
index 95c78df..22c0ae9 100644
--- a/src/jcurses.h
+++ b/src/jcurses.h
@@ -22,5 +22,6 @@
 #define S_CHKLST "\033[%d;%dH%s\033[0m"
 #define S_CHKLST_DONE "\033[46m\033[30m\033[%d;%dH%s\033[0m"
 #define S_INFO2 "\033[46m\033[30m\033[24;0H"
+#define S_LIST "\033[%d;78H%d"
 
 #endif
diff --git a/src/testa_item_1.c b/src/testa_item_1.c
index d60c52d..0b9b846 100644
--- a/src/testa_item_1.c
+++ b/src/testa_item_1.c
@@ -72,7 +72,7 @@ void testa_item_1(const char *m)
 
     LTELA;
     conjord_imprime_conjunto(cj_a);
-    INFO("* item 1.1 ordenar por chave de identificao");
+    INFO("* item 1.1 ordenar por chave de identificacao");
     CM;
 
     LTELA;

commit 0fdc05f41a92a0e5c25c94a58c7866071d81df92
Author: Joilnen <joilnen@gmail.com>
Date:   Tue Jan 4 06:29:34 2022 -0300

    adicionado autor no primeiro comentario

diff --git a/src/checklist.h b/src/checklist.h
index fbe2506..730b616 100644
--- a/src/checklist.h
+++ b/src/checklist.h
@@ -1,6 +1,10 @@
 #ifndef CHECKLIST_H_
 #define CHECKLIST_H_
 
+/*
+ * aluno: joilnen leite
+ */
+
 void tela_checklist(int i);
 
 #define ITEM1_1 "1.1 listar ordenado por chave"
diff --git a/src/conjunto_ordenado.h b/src/conjunto_ordenado.h
index 557b131..ded9113 100644
--- a/src/conjunto_ordenado.h
+++ b/src/conjunto_ordenado.h
@@ -1,6 +1,10 @@
 #ifndef CONJUNTO_ORDENADO_H
 #define CONJUNTO_ORDENADO_H
 
+/*
+ * aluno: joilnen leite
+ */
+
 #include "jcurses.h"
 #include "red_black.h"
 
diff --git a/src/jcurses.h b/src/jcurses.h
index 22c0ae9..19af7b9 100644
--- a/src/jcurses.h
+++ b/src/jcurses.h
@@ -1,6 +1,10 @@
 #ifndef JOILNEN_CURSES_H
 #define JOILNEN_CURSES_H
 
+/*
+ * aluno: joilnen
+ */
+
 /**
  * marcros que criei baseado no que pesquisei
  * sobre formatacao e codifificacao de terminal vt100
diff --git a/src/main.c b/src/main.c
index a51b854..f669c60 100644
--- a/src/main.c
+++ b/src/main.c
@@ -1,4 +1,4 @@
-/**
+/*
  * aluno: joilnen leite
  */
 #include <stdio.h>
diff --git a/src/testa.h b/src/testa.h
index 494ed68..302e359 100644
--- a/src/testa.h
+++ b/src/testa.h
@@ -1,6 +1,10 @@
 #ifndef TESTA_H_
 #define TESTA_H_
 
+/*
+ * aluno: joilnen leite
+ */
+
 #include "jcurses.h"
 #include "testa_item_1.h"
 #include "testa_item_2.h"
diff --git a/src/testa_item_2.c b/src/testa_item_2.c
index 80d0813..9de4f95 100644
--- a/src/testa_item_2.c
+++ b/src/testa_item_2.c
@@ -1,6 +1,10 @@
 #include <stdio.h>
 #include "conjunto_ordenado.h"
-#include "testa_item_2.h"
+#include "testa.h"
+
+/*
+ * aluno: joilnen leite
+ */
 
 void tela_item_2(const char *m)
 {
diff --git a/src/testa_item_2.h b/src/testa_item_2.h
index ad0f154..3544916 100644
--- a/src/testa_item_2.h
+++ b/src/testa_item_2.h
@@ -1,6 +1,10 @@
 #ifndef TESTA_ITEM_2_H_
 #define TESTA_ITEM_2_H_
 
+/*
+ * aluno: joilnen leite
+ */
+
 void tela_item_2(const char *m);
 void testa_item_2(const char *m);
 
diff --git a/src/testa_item_3.c b/src/testa_item_3.c
index 358d1a8..e86262d 100644
--- a/src/testa_item_3.c
+++ b/src/testa_item_3.c
@@ -2,6 +2,10 @@
 #include "conjunto_ordenado.h"
 #include "testa_item_3.h"
 
+/*
+ * aluno: joilnen leite
+ */
+
 void tela_item_3(const char *m)
 {
     LTELA;
diff --git a/src/testa_item_3.h b/src/testa_item_3.h
index 3808f42..30f724e 100644
--- a/src/testa_item_3.h
+++ b/src/testa_item_3.h
@@ -1,6 +1,10 @@
 #ifndef TESTA_ITEM_3_H_
 #define TESTA_ITEM_3_H_
 
+/*
+ * aluno: joilnen leite
+ */
+
 void tela_item_3(const char *m);
 void testa_item_3(const char *m);
 
diff --git a/src/testa_rb.c b/src/testa_rb.c
index cbaae9d..d218910 100644
--- a/src/testa_rb.c
+++ b/src/testa_rb.c
@@ -1,4 +1,4 @@
-/**
+/*
  * aluno: joilnen leite
  */
 
diff --git a/src/testa_rb.h b/src/testa_rb.h
index d568f6b..8224693 100644
--- a/src/testa_rb.h
+++ b/src/testa_rb.h
@@ -1,7 +1,7 @@
 #ifndef TESTA_ARVORE_RB_
 #define TESTA_ARVORE_RB_
 
-/**
+/*
  * aluno: joilnen leite
  */
 

commit f85a3e3d312e500fa7672fd55879a9dc26fb70f8
Author: Joilnen <joilnen@gmail.com>
Date:   Tue Jan 4 09:38:27 2022 -0300

    criado segundo lote de testes, delecao, tornar vazio, cardinalidade e outros

diff --git a/src/conjunto_ordenado.c b/src/conjunto_ordenado.c
index 3a1d69f..1ee4218 100644
--- a/src/conjunto_ordenado.c
+++ b/src/conjunto_ordenado.c
@@ -58,10 +58,15 @@ int conjord_insere_elemento(conjord *a, int chave, void *elemento)
 
 void conjord_deleta_elemento(conjord *a, int chave)
 {
-    rb_delete(&a->pr, rb_search(a->pr, chave));
-    a->cardinalidade--;
-    if(a->cardinalidade < 0)
-        a->cardinalidade = 0;
+    rb_n *t = rb_search(a->pr, chave);
+
+    if(t)
+    {
+        rb_delete(&a->pr, t);
+        a->cardinalidade--;
+        if(a->cardinalidade < 0)
+            a->cardinalidade = 0;
+    }
 }
 
 int conjord_cardinalidade(conjord *c)
@@ -89,13 +94,29 @@ int conjord_eh_vazio(const conjord *a)
     return !a->pr;
 }
 
+static void conjord_esvazia_helper(rb_n *r)
+{
+    if (r == &rb_s)
+        return;
+    rb_n *temp = r->p;
+    conjord_esvazia_helper(r->l);
+    free(r->d);
+    r->d = NULL;
+    conjord_esvazia_helper(r->r);
+}
 /**
  * deleta todos os elementos do 
  * conjunto e zera a cardinalidade
  */
-int conjord_esvazia(conjord *a)
+int conjord_esvazia(conjord *c)
 {
-
+    if (c && c->pr)
+    {
+        conjord_esvazia_helper(c->pr);
+        c->cardinalidade = 0;
+        free(c->pr);
+        c->pr = NULL;
+    }
 }
 
 void conjord_imprime_arvore_rb(conjord *c, int s)
diff --git a/src/conjunto_ordenado.h b/src/conjunto_ordenado.h
index ded9113..3366c55 100644
--- a/src/conjunto_ordenado.h
+++ b/src/conjunto_ordenado.h
@@ -145,6 +145,8 @@ void conjord_imprime_conjunto(conjord *c);
 #define CKLSITEM(l,c,b,x) \
     if (b) printf(S_CHKLST_DONE, l, c, x); \
     else printf(S_CHKLST, l, c, x)
+#define INFO_FILE(x) printf("%s%s%s", S_INFO_ST, x, S_NORM)
+#define INFO_CARD(x) printf("%scardinalidade: %d%s", S_CARD, x, S_NORM)
 
 #endif
 
diff --git a/src/jcurses.h b/src/jcurses.h
index 19af7b9..767dde3 100644
--- a/src/jcurses.h
+++ b/src/jcurses.h
@@ -23,9 +23,11 @@
 #define S_NORM "\033[0m"
 #define S_INFO "\033[24;0H\033[7m"
 #define S_INFO_ST "\033[0;65H"
+#define S_CARD "\033[0;60H"
 #define S_CHKLST "\033[%d;%dH%s\033[0m"
 #define S_CHKLST_DONE "\033[46m\033[30m\033[%d;%dH%s\033[0m"
 #define S_INFO2 "\033[46m\033[30m\033[24;0H"
 #define S_LIST "\033[%d;78H%d"
+#define S_FILEN "\033[0;55H"
 
 #endif
diff --git a/src/testa_item_1.c b/src/testa_item_1.c
index 0b9b846..925553b 100644
--- a/src/testa_item_1.c
+++ b/src/testa_item_1.c
@@ -55,7 +55,7 @@ void testa_item_1(const char *m)
     conjord *cj_a = conjord_cria("A");
     LTELA;
     adiciona_lista_de_elementos(cj_a);
-    INFO("* item 2.1 inserir 20 elem. chave unica entre 1 a 99");
+    INFO("* item 2.1 inserido 20 elem. chave unica entre 1 a 99");
     CM;
     LTELA;
     tela_checklist(1 << I2_1);
@@ -63,7 +63,7 @@ void testa_item_1(const char *m)
 
     LTELA;
     conjord_imprime_arvore_rb(cj_a, 1);
-    INFO("* item 4 mostrar arvore atual");
+    INFO("* item 4 mostra da arvore atual");
     CM;
 
     LTELA;
@@ -72,7 +72,7 @@ void testa_item_1(const char *m)
 
     LTELA;
     conjord_imprime_conjunto(cj_a);
-    INFO("* item 1.1 ordenar por chave de identificacao");
+    INFO("* item 1.1 ordenado por chave de identificacao");
     CM;
 
     LTELA;
@@ -93,6 +93,7 @@ void tela_item_1(const char *m)
     CKLSITEM(l++, c, 0, "e ordenacao dos elementos do conjunto");
     CKLSITEM(l++, c, 0, "o tipo de dado do usuario aqui eh uma");
     CKLSITEM(l++, c, 0, "estrutura com duas strings, nome e telefone");
+    INFO_FILE(__FILE__);
     CM;
 }
 
diff --git a/src/testa_item_2.c b/src/testa_item_2.c
index 9de4f95..c5c36d7 100644
--- a/src/testa_item_2.c
+++ b/src/testa_item_2.c
@@ -1,34 +1,114 @@
 #include <stdio.h>
+#include <string.h>
+#include <time.h>
 #include "conjunto_ordenado.h"
 #include "testa.h"
+#include "checklist.h"
 
 /*
  * aluno: joilnen leite
  */
 
+static void imprime_meu_tipo(void *);
+
+typedef struct {
+    char *nome;
+    int milhas;
+} meu_tipo2;
+
+static void adiciona_lista_de_elementos(conjord *c)
+{
+    int i;
+    srand(time(NULL));
+    for (i = 0; i < 20;)
+    {
+        /**
+         * definicao de um tipo exemplo pelo o usuario
+         */
+
+        /**
+         * criacao do dado para o tipo do usuario
+         */
+        meu_tipo2 *mt0 = (meu_tipo2 *) malloc (sizeof(meu_tipo2));
+        mt0->nome = (char *) malloc(sizeof("nome para teste1") + 1);
+        strncpy(mt0->nome, "nome para teste1", sizeof("nome para teste1") + 1);
+        mt0->milhas = 19;
+        int chave = rand() % 99 + 1;
+        if (!conjord_insere_elemento(c, chave, mt0))
+        {
+            ++i;
+            printf("chave:%d \t", chave);
+            printf("nome:%s\t", mt0->nome);
+            printf("milhas:%d\n", mt0->milhas);
+        }
+    }
+}
+
+void testa_item_2(const char *m)
+{
+    /**
+     * seta a funcao para impressao utiliza aqui a tecnica de ponteiro para funcao
+     */
+    conjord_seta_imprime_elemento(imprime_meu_tipo);
+    conjord *cj_a = conjord_cria("A");
+    int imp;
+
+    LTELA;
+    adiciona_lista_de_elementos(cj_a);
+    INFO("* item 2.2 excluir todos com chave impar");
+    CM;
+
+    for (imp = 1; imp < 100; imp += 2)
+        conjord_deleta_elemento(cj_a, imp);
+    LTELA;
+    conjord_imprime_conjunto(cj_a);
+    INFO("* item 1.4 excluir todos");
+    INFO_CARD(conjord_cardinalidade(cj_a));
+    CM;
+
+    LTELA;
+    conjord_esvazia(cj_a);
+    INFO_CARD(conjord_cardinalidade(cj_a));
+    INFO("* item 1.3 conjunto vazio");
+    CM;
+
+    LTELA;
+    tela_checklist(1 << I1_2);
+    tela_checklist(1 << I1_3);
+    tela_checklist(1 << I1_4);
+    tela_checklist(1 << I2_2);
+    tela_checklist(1 << I2_3);
+    CM;
+}
+
 void tela_item_2(const char *m)
 {
     LTELA;
     int l = 5, c = 24, f;
-    char mens[6][40] =
+    char mens[8][45] =
     {
-        "\033[21mserah efetuado os testes:\033[0m",
+        S_UNDERL"serah efetuado os testes:"S_NORM,
         "exclusao de elemento do conjunto",
         "verif. se elemento pertence ao conjunto",
         "cardinalide do conjunto",
         "verif. se conjunto eh vazio",
-        "tornar conjunto vazio"
+        "tornar conjunto vazio",
+        "o tipo de dado do usuario aqui eh uma",
+        "estrutura com uma string e um inteiro"
     };
-    for (f = 0; f < 7; f++)
+    for (f = 0; f < 8; f++)
         CKLSITEM(l++, c, 0, mens[f]);
+    INFO_FILE(__FILE__);
     CM;
 }
 
-
-void testa_item_2(const char *m)
+void imprime_meu_tipo(void *n)
 {
-    LTELA;
-    printf("Testa item 2\n");
-    CM;
+    if(n)
+    {
+        printf("nome: %s \t", ((meu_tipo2 *)n)->nome);
+        printf("milhas: %d\n", ((meu_tipo2 *)n)->milhas);
+    }
 }
 
+
diff --git a/src/testa_item_3.c b/src/testa_item_3.c
index e86262d..1f68940 100644
--- a/src/testa_item_3.c
+++ b/src/testa_item_3.c
@@ -1,4 +1,5 @@
 #include <stdio.h>
+#include "jcurses.h"
 #include "conjunto_ordenado.h"
 #include "testa_item_3.h"
 
@@ -6,10 +7,32 @@
  * aluno: joilnen leite
  */
 
+/*
+ * aluno: joilnen leite
+ */
+
+static void imprime_meu_tipo(void *);
+
+typedef struct {
+    char letra;
+} meu_tipo3;
+
 void tela_item_3(const char *m)
 {
     LTELA;
-    printf("Testa item 3\n");
+    int l = 5, c = 24, f;
+    char mens[6][48] =
+    {
+        S_UNDERL"serah efetuado os testes:"S_NORM,
+        "interseccao de conjuntos",
+        "uniao de conjuntos",
+        "subtracao de conjuntos",
+        "o tipo de dado do usuario aqui eh um",
+        "caracter representando letras do alfabeto"
+    };
+    for (f = 0; f < 6; f++)
+        CKLSITEM(l++, c, 0, mens[f]);
+    INFO_FILE(__FILE__);
     CM;
 }
 
@@ -19,3 +42,11 @@ void testa_item_3(const char *m)
 
 }
 
+void imprime_meu_tipo(void *n)
+{
+    if(n)
+    {
+        printf("%c ", ((meu_tipo3 *)n)->letra);
+    }
+}
+

commit 33ec35c9d0e06aef527ddf78d41da1b9bddf8a82
Author: Joilnen <joilnen@gmail.com>
Date:   Tue Jan 4 14:40:07 2022 -0300

    inciando lote de teste 3 tentarei fazer um diagrama de venn em texto

diff --git a/src/conjunto_ordenado.c b/src/conjunto_ordenado.c
index 1ee4218..77ef88e 100644
--- a/src/conjunto_ordenado.c
+++ b/src/conjunto_ordenado.c
@@ -155,4 +155,21 @@ void conjord_imprime_conjunto(conjord *c)
         conjord_imprime_conjunto_helper(c->pr);
 }
 
+static void conjord_imprime_venn_helper(rb_n *n)
+{
+    static int ang = 0, ray = 0;
+    if (n == &rb_s)
+        return;
+
+    conjord_imprime_conjunto_helper(n->l);
+    printf("chave: %d\t", n->k);
+    conjord_imprime_elemento(n->d);
+    conjord_imprime_conjunto_helper(n->r);
+}
+
+void conjord_imprime_venn(conjord *c)
+{
+    if (c && c->pr)
+        conjord_imprime_conjunto_helper(c->pr);
+}
 
diff --git a/src/conjunto_ordenado.h b/src/conjunto_ordenado.h
index 3366c55..c87d10d 100644
--- a/src/conjunto_ordenado.h
+++ b/src/conjunto_ordenado.h
@@ -126,6 +126,8 @@ int conjord_seta_imprime_elemento(void (*i)(void *n));
 
 void conjord_imprime_conjunto(conjord *c);
 
+void conjord_imprime_venn(conjord *c);
+
 
 /**
  * foi utlizado macro em vez de funcao
diff --git a/src/testa_item_3.c b/src/testa_item_3.c
index 1f68940..1315387 100644
--- a/src/testa_item_3.c
+++ b/src/testa_item_3.c
@@ -1,8 +1,9 @@
 #include <stdio.h>
-#include "jcurses.h"
+#include <string.h>
+#include <time.h>
 #include "conjunto_ordenado.h"
-#include "testa_item_3.h"
-
+#include "testa.h"
+#include "checklist.h"
 /*
  * aluno: joilnen leite
  */
@@ -17,6 +18,12 @@ typedef struct {
     char letra;
 } meu_tipo3;
 
+
+static void adiciona_venn(conjord *c, int index)
+{
+
+}
+
 void tela_item_3(const char *m)
 {
     LTELA;
@@ -39,14 +46,43 @@ void tela_item_3(const char *m)
 
 void testa_item_3(const char *m)
 {
+    /**
+     * seta a funcao para impressao utiliza aqui a tecnica de ponteiro para funcao
+     */
+    conjord_seta_imprime_elemento(imprime_meu_tipo);
+    conjord *cj_a = conjord_cria("A");
+    int imp, pos0 = 0, pos1 = 1, pos2 = 2;
 
+    LTELA;
+    adiciona_venn(cj_a, pos0);
+    INFO("* item 2.2 excluir todos com chave impar");
+    CM;
+
+    // for (imp = 1; imp < 100; imp += 2)
+    //     conjord_deleta_elemento(cj_a, imp);
+    LTELA;
+    conjord_imprime_conjunto(cj_a);
+    INFO("* item 1.4 excluir todos");
+    INFO_CARD(conjord_cardinalidade(cj_a));
+    CM;
+
+    LTELA;
+    conjord_esvazia(cj_a);
+    INFO_CARD(conjord_cardinalidade(cj_a));
+    INFO("* item 1.3 conjunto vazio");
+    CM;
+
+    LTELA;
+    tela_checklist(1 << I3_1);
+    tela_checklist(1 << I3_2);
+    tela_checklist(1 << I3_3);
+    CM;
 }
 
 void imprime_meu_tipo(void *n)
 {
     if(n)
-    {
         printf("%c ", ((meu_tipo3 *)n)->letra);
-    }
 }
 
+

commit cf31603f0769c38142f76f178eae220925ea3c95
Author: Joilnen <joilnen@gmail.com>
Date:   Tue Jan 4 16:31:17 2022 -0300

    implementando um diagrama de venn, dificil soh em texto,
    imprime todo fora de lugra mas n quebra

diff --git a/src/conjunto_ordenado.c b/src/conjunto_ordenado.c
index 77ef88e..0f75d95 100644
--- a/src/conjunto_ordenado.c
+++ b/src/conjunto_ordenado.c
@@ -1,4 +1,5 @@
 #include <stdio.h>
+#include <math.h>
 #include "conjunto_ordenado.h"
 
 static rb_n **raiz;
@@ -155,21 +156,66 @@ void conjord_imprime_conjunto(conjord *c)
         conjord_imprime_conjunto_helper(c->pr);
 }
 
-static void conjord_imprime_venn_helper(rb_n *n)
+static void conjord_imprime_venn_helper(rb_n *n, float ang, int cor)
 {
-    static int ang = 0, ray = 0;
+    int l, c;
+    static int rai = 0;
     if (n == &rb_s)
         return;
 
-    conjord_imprime_conjunto_helper(n->l);
-    printf("chave: %d\t", n->k);
+    conjord_imprime_venn_helper(n->l, ang + M_PI/8, 0);
+
+    if (ang > (2 * M_PI))
+    {
+        ang = 0;
+        rai += 2;
+    }
+
+    if (!ang && !rai)
+    {
+        rai = 2;
+        ang = M_PI / 4; 
+    }
+    else
+    {
+        int pl = (int)(floor(cosf(ang)) * rai);
+        int pc = (int)(floor(sinf(ang)) * rai);
+        int cnt, ud, lr;
+        lr = (pl > 0) ?  1:  -1;
+        ud = (pc > 0) ?  1:  -1;
+        pl = abs(pl); pc = abs(pc);
+
+        for (cnt = 0; cnt < pl; cnt++);
+        {
+            if (lr > 0) printf("\033[C");
+            else printf("\033[D");
+        }
+
+        for (cnt = 0; cnt < pc; cnt++);
+        {
+            if (ud > 0) printf("\033[B");
+            else printf("\033[A");
+        }
+    }
+
     conjord_imprime_elemento(n->d);
-    conjord_imprime_conjunto_helper(n->r);
+    printf("\033[0m");
+
+    conjord_imprime_venn_helper(n->r, ang + M_PI/4, 0);
 }
 
-void conjord_imprime_venn(conjord *c)
+void conjord_imprime_venn(conjord *c, int pos)
 {
     if (c && c->pr)
-        conjord_imprime_conjunto_helper(c->pr);
+    {
+        if (pos == 2)
+            printf("\033[12;55H");
+        else if (pos == 1)
+            printf("\033[12;15H");
+        else
+            printf("\033[16;40H");
+        conjord_imprime_venn_helper(c->pr, 0, 0);
+    }
 }
 
+
diff --git a/src/conjunto_ordenado.h b/src/conjunto_ordenado.h
index c87d10d..836f8d9 100644
--- a/src/conjunto_ordenado.h
+++ b/src/conjunto_ordenado.h
@@ -126,7 +126,7 @@ int conjord_seta_imprime_elemento(void (*i)(void *n));
 
 void conjord_imprime_conjunto(conjord *c);
 
-void conjord_imprime_venn(conjord *c);
+void conjord_imprime_venn(conjord *c, int pos);
 
 
 /**
diff --git a/src/jcurses.h b/src/jcurses.h
index 767dde3..98b5ec3 100644
--- a/src/jcurses.h
+++ b/src/jcurses.h
@@ -29,5 +29,6 @@
 #define S_INFO2 "\033[46m\033[30m\033[24;0H"
 #define S_LIST "\033[%d;78H%d"
 #define S_FILEN "\033[0;55H"
+#define S_VENN S_CHKLST
 
 #endif
diff --git a/src/makefile b/src/makefile
index 2ddd9d1..064af43 100644
--- a/src/makefile
+++ b/src/makefile
@@ -13,7 +13,7 @@ D=-g
 .c.o:
 	$(C) -c $(D) $<
 all: $(O) 
-	$(C) -o $(E) $(O)
+	$(C) -o $(E) $(O) -lm
 clean:
 	rm -f *.o $(E)
 
diff --git a/src/testa_item_3.c b/src/testa_item_3.c
index 1315387..7521d2f 100644
--- a/src/testa_item_3.c
+++ b/src/testa_item_3.c
@@ -11,17 +11,28 @@
 /*
  * aluno: joilnen leite
  */
-
 static void imprime_meu_tipo(void *);
 
 typedef struct {
     char letra;
 } meu_tipo3;
 
-
-static void adiciona_venn(conjord *c, int index)
+static void adiciona_venn(conjord *c, int pos)
 {
+    int i;
+    for (i = 0; i < 10;)
+    {
+        /**
+         * criacao do dado para o tipo do usuario
+         */
+        meu_tipo3 *mt0 = (meu_tipo3 *) malloc (sizeof(meu_tipo3));
+        mt0->letra = 'A' + i;
+
+        if (!conjord_insere_elemento(c, i, mt0))
+            ++i;
+    }
 
+    conjord_imprime_venn(c, pos);
 }
 
 void tela_item_3(const char *m)
@@ -55,27 +66,7 @@ void testa_item_3(const char *m)
 
     LTELA;
     adiciona_venn(cj_a, pos0);
-    INFO("* item 2.2 excluir todos com chave impar");
-    CM;
-
-    // for (imp = 1; imp < 100; imp += 2)
-    //     conjord_deleta_elemento(cj_a, imp);
-    LTELA;
-    conjord_imprime_conjunto(cj_a);
-    INFO("* item 1.4 excluir todos");
-    INFO_CARD(conjord_cardinalidade(cj_a));
-    CM;
-
-    LTELA;
-    conjord_esvazia(cj_a);
-    INFO_CARD(conjord_cardinalidade(cj_a));
-    INFO("* item 1.3 conjunto vazio");
-    CM;
-
-    LTELA;
-    tela_checklist(1 << I3_1);
-    tela_checklist(1 << I3_2);
-    tela_checklist(1 << I3_3);
+    INFO("* item 3.1 operacoes com conjuntos");
     CM;
 }
 

commit 5a3952ee1b1535e9a9bca6a07cd133115f0d9a84
Author: Joilnen <joilnen@gmail.com>
Date:   Tue Jan 4 17:05:27 2022 -0300

    tentando consertar o venn

diff --git a/src/conjunto_ordenado.c b/src/conjunto_ordenado.c
index 0f75d95..c20c6cd 100644
--- a/src/conjunto_ordenado.c
+++ b/src/conjunto_ordenado.c
@@ -178,12 +178,12 @@ static void conjord_imprime_venn_helper(rb_n *n, float ang, int cor)
     }
     else
     {
-        int pl = (int)(floor(cosf(ang)) * rai);
-        int pc = (int)(floor(sinf(ang)) * rai);
+        int pl = (int)(cosf(ang) * rai);
+        int pc = (int)(sinf(ang) * rai);
         int cnt, ud, lr;
         lr = (pl > 0) ?  1:  -1;
         ud = (pc > 0) ?  1:  -1;
-        pl = abs(pl); pc = abs(pc);
+        pl = floor(pl); pc = floor(pc);
 
         for (cnt = 0; cnt < pl; cnt++);
         {
@@ -213,7 +213,7 @@ void conjord_imprime_venn(conjord *c, int pos)
         else if (pos == 1)
             printf("\033[12;15H");
         else
-            printf("\033[16;40H");
+            printf("\033[18;40H");
         conjord_imprime_venn_helper(c->pr, 0, 0);
     }
 }

commit ff49400b5be6f5bfeed95f63c2bc8ac3373f4b8a
Author: Joilnen <joilnen@gmail.com>
Date:   Tue Jan 4 17:42:43 2022 -0300

    experiencias nessa ideia de venn

diff --git a/src/conjunto_ordenado.c b/src/conjunto_ordenado.c
index c20c6cd..c4713a7 100644
--- a/src/conjunto_ordenado.c
+++ b/src/conjunto_ordenado.c
@@ -168,7 +168,7 @@ static void conjord_imprime_venn_helper(rb_n *n, float ang, int cor)
     if (ang > (2 * M_PI))
     {
         ang = 0;
-        rai += 2;
+        rai += 12;
     }
 
     if (!ang && !rai)
@@ -176,30 +176,33 @@ static void conjord_imprime_venn_helper(rb_n *n, float ang, int cor)
         rai = 2;
         ang = M_PI / 4; 
     }
-    else
+
+    int pl = (int)(cosf(ang) * rai);
+    int pc = (int)(sinf(ang) * rai);
+    int cnt, ud, lr;
+    lr = (pl > 0) ?  1:  -1;
+    ud = (pc > 0) ?  1:  -1;
+    pl = floor(pl); pc = floor(pc);
+
+    printf("\033[18;40H");
+    printf("\033[%d;%dH", 18 + pl, 40 + pc);
+    printf("%d %d %f", pl, pc, ang);
+    /****
+    for (cnt = 0; cnt < pl; cnt++);
+    {
+        if (lr > 0) printf("\033[C");
+        else printf("\033[D");
+    }
+
+    for (cnt = 0; cnt < pc; cnt++);
     {
-        int pl = (int)(cosf(ang) * rai);
-        int pc = (int)(sinf(ang) * rai);
-        int cnt, ud, lr;
-        lr = (pl > 0) ?  1:  -1;
-        ud = (pc > 0) ?  1:  -1;
-        pl = floor(pl); pc = floor(pc);
-
-        for (cnt = 0; cnt < pl; cnt++);
-        {
-            if (lr > 0) printf("\033[C");
-            else printf("\033[D");
-        }
-
-        for (cnt = 0; cnt < pc; cnt++);
-        {
-            if (ud > 0) printf("\033[B");
-            else printf("\033[A");
-        }
+        if (ud > 0) printf("\033[B");
+        else printf("\033[A");
     }
+    ****/
 
     conjord_imprime_elemento(n->d);
-    printf("\033[0m");
+    getc(stdin);
 
     conjord_imprime_venn_helper(n->r, ang + M_PI/4, 0);
 }

commit f2e0fc34b62d8f4067247e11836f36f7e25aadfa
Author: Joilnen <joilnen@gmail.com>
Date:   Tue Jan 4 18:09:41 2022 -0300

    venn

diff --git a/src/conjunto_ordenado.c b/src/conjunto_ordenado.c
index c4713a7..5ff4920 100644
--- a/src/conjunto_ordenado.c
+++ b/src/conjunto_ordenado.c
@@ -163,9 +163,9 @@ static void conjord_imprime_venn_helper(rb_n *n, float ang, int cor)
     if (n == &rb_s)
         return;
 
-    conjord_imprime_venn_helper(n->l, ang + M_PI/8, 0);
+    conjord_imprime_venn_helper(n->l, ang + 22.5, 0);
 
-    if (ang > (2 * M_PI))
+    if (ang > 360)
     {
         ang = 0;
         rai += 12;
@@ -174,11 +174,11 @@ static void conjord_imprime_venn_helper(rb_n *n, float ang, int cor)
     if (!ang && !rai)
     {
         rai = 2;
-        ang = M_PI / 4; 
+        ang = 45; 
     }
 
-    int pl = (int)(cosf(ang) * rai);
-    int pc = (int)(sinf(ang) * rai);
+    int pl = (int)(cosf(ang * M_PI / 180) * rai);
+    int pc = (int)(sinf(ang * M_PI / 180) * rai);
     int cnt, ud, lr;
     lr = (pl > 0) ?  1:  -1;
     ud = (pc > 0) ?  1:  -1;
@@ -186,7 +186,7 @@ static void conjord_imprime_venn_helper(rb_n *n, float ang, int cor)
 
     printf("\033[18;40H");
     printf("\033[%d;%dH", 18 + pl, 40 + pc);
-    printf("%d %d %f", pl, pc, ang);
+    // printf("%d %d %f", pl, pc, ang);
     /****
     for (cnt = 0; cnt < pl; cnt++);
     {
@@ -204,7 +204,7 @@ static void conjord_imprime_venn_helper(rb_n *n, float ang, int cor)
     conjord_imprime_elemento(n->d);
     getc(stdin);
 
-    conjord_imprime_venn_helper(n->r, ang + M_PI/4, 0);
+    conjord_imprime_venn_helper(n->r, ang + 45, 0);
 }
 
 void conjord_imprime_venn(conjord *c, int pos)

commit 6508aea78932f1485fd5b46f48921ecaa009384b
Author: Joilnen <joilnen@gmail.com>
Date:   Wed Jan 5 00:38:43 2022 -0300

    midpoing algo pra simular um diagrama de venn

diff --git a/src/conjunto_ordenado.c b/src/conjunto_ordenado.c
index 5ff4920..17a21c8 100644
--- a/src/conjunto_ordenado.c
+++ b/src/conjunto_ordenado.c
@@ -158,6 +158,7 @@ void conjord_imprime_conjunto(conjord *c)
 
 static void conjord_imprime_venn_helper(rb_n *n, float ang, int cor)
 {
+    /****
     int l, c;
     static int rai = 0;
     if (n == &rb_s)
@@ -186,6 +187,39 @@ static void conjord_imprime_venn_helper(rb_n *n, float ang, int cor)
 
     printf("\033[18;40H");
     printf("\033[%d;%dH", 18 + pl, 40 + pc);
+    ****/
+
+    int x = 0;  
+    int y = 4, p;  
+    int a = 18, b = 40, r = 2;
+    printf("\033[%d;%dHo", a, b+r);  
+    printf("\033[%d;%dHo", a, b-r);  
+    printf("\033[%d;%dHo", a-r, b);  
+    printf("\033[%d;%dHo", a+r, b);  
+
+    p = 5/4 - r;  
+
+    while (x <= y)  
+    {  
+        if (p < 0)  
+            p += (4*x) + 6;  
+        else  
+        {  
+            p += (2*(x-y)) + 5;  
+            y--;  
+        }  
+        x++;  
+        printf("\033[%d;%dHo", a+x, b+y);  
+        printf("\033[%d;%dHo", a-x, b+y);  
+        printf("\033[%d;%dHo", a+x, b-y);  
+        printf("\033[%d;%dHo", a+x, b-y);  
+        printf("\033[%d;%dHo", a+x, b+y);  
+        printf("\033[%d;%dHo", a+x, b-y);  
+        printf("\033[%d;%dHo", a-x, b+y);  
+        printf("\033[%d;%dHo", a-x, b-y);  
+    }  
+
+
     // printf("%d %d %f", pl, pc, ang);
     /****
     for (cnt = 0; cnt < pl; cnt++);
@@ -201,10 +235,12 @@ static void conjord_imprime_venn_helper(rb_n *n, float ang, int cor)
     }
     ****/
 
+    /****
     conjord_imprime_elemento(n->d);
     getc(stdin);
 
     conjord_imprime_venn_helper(n->r, ang + 45, 0);
+    ****/
 }
 
 void conjord_imprime_venn(conjord *c, int pos)

commit 0fc6c2b33b7839708675883a7956812be92af4e3
Author: Joilnen <joilnen@gmail.com>
Date:   Wed Jan 5 06:22:48 2022 -0300

    venn

diff --git a/src/testa_item_3.c b/src/testa_item_3.c
index 7521d2f..45cd0a9 100644
--- a/src/testa_item_3.c
+++ b/src/testa_item_3.c
@@ -17,18 +17,18 @@ typedef struct {
     char letra;
 } meu_tipo3;
 
-static void adiciona_venn(conjord *c, int pos)
+static void adiciona_venn(conjord *c, int pos, char *letras)
 {
-    int i;
-    for (i = 0; i < 10;)
+    char *i;
+    for (i = letras; *i; i++)
     {
         /**
          * criacao do dado para o tipo do usuario
          */
         meu_tipo3 *mt0 = (meu_tipo3 *) malloc (sizeof(meu_tipo3));
-        mt0->letra = 'A' + i;
+        mt0->letra = *i;
 
-        if (!conjord_insere_elemento(c, i, mt0))
+        if (!conjord_insere_elemento(c, *i, mt0))
             ++i;
     }
 
@@ -62,10 +62,14 @@ void testa_item_3(const char *m)
      */
     conjord_seta_imprime_elemento(imprime_meu_tipo);
     conjord *cj_a = conjord_cria("A");
+    conjord *cj_b = conjord_cria("B");
     int imp, pos0 = 0, pos1 = 1, pos2 = 2;
+    char elem0[] = "ABCDEFGHIJKLMNOP";
+    char elem1[] = "JKLMNOPQRSTUVXYZ";
 
     LTELA;
-    adiciona_venn(cj_a, pos0);
+    adiciona_venn(cj_a, pos1, elem0);
+    adiciona_venn(cj_b, pos2, elem1);
     INFO("* item 3.1 operacoes com conjuntos");
     CM;
 }

commit 8f5fb5a53d26f7c703c4561aab72d0d42d104473
Author: Joilnen <joilnen@gmail.com>
Date:   Wed Jan 5 18:12:29 2022 -0300

    diagrama de venn bem dificil tou quase desistindo

diff --git a/src/conjunto_ordenado.c b/src/conjunto_ordenado.c
index 17a21c8..d22c51b 100644
--- a/src/conjunto_ordenado.c
+++ b/src/conjunto_ordenado.c
@@ -156,47 +156,49 @@ void conjord_imprime_conjunto(conjord *c)
         conjord_imprime_conjunto_helper(c->pr);
 }
 
-static void conjord_imprime_venn_helper(rb_n *n, float ang, int cor)
+char buffer[100];
+int count_buffer = 0;
+static void conjord_retorna_elementos(rb_n *n)
 {
-    /****
-    int l, c;
-    static int rai = 0;
     if (n == &rb_s)
-        return;
-
-    conjord_imprime_venn_helper(n->l, ang + 22.5, 0);
-
-    if (ang > 360)
     {
-        ang = 0;
-        rai += 12;
-    }
-
-    if (!ang && !rai)
-    {
-        rai = 2;
-        ang = 45; 
+        buffer[count_buffer] = '\0';
+        return;
     }
 
-    int pl = (int)(cosf(ang * M_PI / 180) * rai);
-    int pc = (int)(sinf(ang * M_PI / 180) * rai);
-    int cnt, ud, lr;
-    lr = (pl > 0) ?  1:  -1;
-    ud = (pc > 0) ?  1:  -1;
-    pl = floor(pl); pc = floor(pc);
-
-    printf("\033[18;40H");
-    printf("\033[%d;%dH", 18 + pl, 40 + pc);
-    ****/
+    buffer[count_buffer++] = *(char *)n->d;
+    conjord_retorna_elementos(n->l);
+    conjord_retorna_elementos(n->r);
+}
 
-    int x = 0;  
-    int y = 4, p;  
+static void conjord_imprime_venn_helper(char *letra)
+{
+    static int n_letra = 0;
+    int x = 0, y = 4, p;  
     int a = 18, b = 40, r = 2;
-    printf("\033[%d;%dHo", a, b+r);  
-    printf("\033[%d;%dHo", a, b-r);  
-    printf("\033[%d;%dHo", a-r, b);  
-    printf("\033[%d;%dHo", a+r, b);  
+    int c0, c1;
 
+    if (!letra)
+        return;
+
+    for (c0 = 0; c0 < 4 && letra[c0]; c0++)
+    {
+        switch (c0)
+        {
+            case 0:
+                printf("\033[%d;%dH%c", a, b+r, letra[c0]);  
+            break;
+            case 1:
+                printf("\033[%d;%dH%c", a, b-r, letra[c0]);  
+            break;
+            case 2:
+                printf("\033[%d;%dH%c", a-r, b, letra[c0]);  
+            break;
+            case 3:
+                printf("\033[%d;%dH%c", a+r, b, letra[c0]);  
+        }
+    }
+    getc(stdin);
     p = 5/4 - r;  
 
     while (x <= y)  
@@ -209,38 +211,37 @@ static void conjord_imprime_venn_helper(rb_n *n, float ang, int cor)
             y--;  
         }  
         x++;  
-        printf("\033[%d;%dHo", a+x, b+y);  
-        printf("\033[%d;%dHo", a-x, b+y);  
-        printf("\033[%d;%dHo", a+x, b-y);  
-        printf("\033[%d;%dHo", a+x, b-y);  
-        printf("\033[%d;%dHo", a+x, b+y);  
-        printf("\033[%d;%dHo", a+x, b-y);  
-        printf("\033[%d;%dHo", a-x, b+y);  
-        printf("\033[%d;%dHo", a-x, b-y);  
+        for (; letra[c0]; c0++)
+        {
+            switch (c0 % 8)
+            {
+                case 0:
+                    printf("\033[%d;%dH%c", a+x, b+y, letra[c0]);  
+                    break;
+                case 1:
+                    printf("\033[%d;%dH%c", a-x, b+y, letra[c0]);  
+                    break;
+                case 2:
+                    printf("\033[%d;%dH%c", a+x, b-y, letra[c0]);  
+                    break;
+                case 3:
+                    printf("\033[%d;%dH%c", a+x, b-y, letra[c0]);  
+                    break;
+                case 4:
+                    printf("\033[%d;%dH%c", a+x, b+y, letra[c0]);  
+                    break;
+                case 5:
+                    printf("\033[%d;%dH%c", a+x, b-y, letra[c0]);  
+                    break;
+                case 6:
+                    printf("\033[%d;%dH%c", a-x, b+y, letra[c0]);  
+                    break;
+                case 7:
+                    printf("\033[%d;%dH%c", a-x, b-y, letra[c0]);  
+            }
+            getc(stdin);
+        }
     }  
-
-
-    // printf("%d %d %f", pl, pc, ang);
-    /****
-    for (cnt = 0; cnt < pl; cnt++);
-    {
-        if (lr > 0) printf("\033[C");
-        else printf("\033[D");
-    }
-
-    for (cnt = 0; cnt < pc; cnt++);
-    {
-        if (ud > 0) printf("\033[B");
-        else printf("\033[A");
-    }
-    ****/
-
-    /****
-    conjord_imprime_elemento(n->d);
-    getc(stdin);
-
-    conjord_imprime_venn_helper(n->r, ang + 45, 0);
-    ****/
 }
 
 void conjord_imprime_venn(conjord *c, int pos)
@@ -253,7 +254,10 @@ void conjord_imprime_venn(conjord *c, int pos)
             printf("\033[12;15H");
         else
             printf("\033[18;40H");
-        conjord_imprime_venn_helper(c->pr, 0, 0);
+        /* tricky */
+        conjord_retorna_elementos(c->pr);
+        printf("BUFFER %s\n", buffer);
+        conjord_imprime_venn_helper(buffer);
     }
 }
 
diff --git a/src/conjunto_ordenado.h b/src/conjunto_ordenado.h
index 836f8d9..e788918 100644
--- a/src/conjunto_ordenado.h
+++ b/src/conjunto_ordenado.h
@@ -119,6 +119,7 @@ void conjord_imprime_arvore_rb(conjord *c, int s);
 void conjord_imprime_lista(int *l, int s);
 
 extern void (*conjord_imprime_elemento)(void *n);
+extern void* (*conjord_retorna_elemento)(void *n);
 /**
  * seta a rotina de impressao do dado criado pelo cliente
  */

commit fe7504be3a66dd69bb77630476af1df338f68eb9
Author: Joilnen <joilnen@gmail.com>
Date:   Wed Jan 5 18:58:50 2022 -0300

    apenas algumas mensagens pra debug adicionadas

diff --git a/src/conjunto_ordenado.c b/src/conjunto_ordenado.c
index d22c51b..d4f8a02 100644
--- a/src/conjunto_ordenado.c
+++ b/src/conjunto_ordenado.c
@@ -166,8 +166,8 @@ static void conjord_retorna_elementos(rb_n *n)
         return;
     }
 
-    buffer[count_buffer++] = *(char *)n->d;
     conjord_retorna_elementos(n->l);
+    buffer[count_buffer++] = *(char *)n->d;
     conjord_retorna_elementos(n->r);
 }
 
@@ -256,7 +256,6 @@ void conjord_imprime_venn(conjord *c, int pos)
             printf("\033[18;40H");
         /* tricky */
         conjord_retorna_elementos(c->pr);
-        printf("BUFFER %s\n", buffer);
         conjord_imprime_venn_helper(buffer);
     }
 }
diff --git a/src/testa_item_3.c b/src/testa_item_3.c
index 45cd0a9..13c3b00 100644
--- a/src/testa_item_3.c
+++ b/src/testa_item_3.c
@@ -32,7 +32,6 @@ static void adiciona_venn(conjord *c, int pos, char *letras)
             ++i;
     }
 
-    conjord_imprime_venn(c, pos);
 }
 
 void tela_item_3(const char *m)
@@ -70,6 +69,7 @@ void testa_item_3(const char *m)
     LTELA;
     adiciona_venn(cj_a, pos1, elem0);
     adiciona_venn(cj_b, pos2, elem1);
+    conjord_imprime_venn(cj_a, pos0);
     INFO("* item 3.1 operacoes com conjuntos");
     CM;
 }

commit f30ce269aeb13ab515f6eff76a680687848153d1
Author: Joilnen <joilnen@gmail.com>
Date:   Thu Jan 6 12:23:44 2022 -0300

    consertado a inclusao do teste de contjuntos

diff --git a/src/conjunto_ordenado.c b/src/conjunto_ordenado.c
index d4f8a02..89518d2 100644
--- a/src/conjunto_ordenado.c
+++ b/src/conjunto_ordenado.c
@@ -156,7 +156,7 @@ void conjord_imprime_conjunto(conjord *c)
         conjord_imprime_conjunto_helper(c->pr);
 }
 
-char buffer[100];
+char buffer[100] = "";
 int count_buffer = 0;
 static void conjord_retorna_elementos(rb_n *n)
 {
@@ -168,6 +168,7 @@ static void conjord_retorna_elementos(rb_n *n)
 
     conjord_retorna_elementos(n->l);
     buffer[count_buffer++] = *(char *)n->d;
+    // printf("^%c\n", *(char *)n->d);
     conjord_retorna_elementos(n->r);
 }
 
diff --git a/src/testa_item_3.c b/src/testa_item_3.c
index 13c3b00..b6dc39b 100644
--- a/src/testa_item_3.c
+++ b/src/testa_item_3.c
@@ -20,7 +20,7 @@ typedef struct {
 static void adiciona_venn(conjord *c, int pos, char *letras)
 {
     char *i;
-    for (i = letras; *i; i++)
+    for (i = letras; *i;)
     {
         /**
          * criacao do dado para o tipo do usuario
@@ -69,6 +69,9 @@ void testa_item_3(const char *m)
     LTELA;
     adiciona_venn(cj_a, pos1, elem0);
     adiciona_venn(cj_b, pos2, elem1);
+    conjord_imprime_conjunto(cj_a);
+    CM;
+    // conjord_imprime_conjunto(cj_b);
     conjord_imprime_venn(cj_a, pos0);
     INFO("* item 3.1 operacoes com conjuntos");
     CM;
@@ -77,7 +80,7 @@ void testa_item_3(const char *m)
 void imprime_meu_tipo(void *n)
 {
     if(n)
-        printf("%c ", ((meu_tipo3 *)n)->letra);
+        printf("%c \n", ((meu_tipo3 *)n)->letra);
 }
 
 

commit 68b96c4cdb898cec0d91396dd468175f4aabedcc
Author: Joilnen <joilnen@gmail.com>
Date:   Thu Jan 6 13:29:35 2022 -0300

    impressao de conjuntos

diff --git a/src/conjunto_ordenado.c b/src/conjunto_ordenado.c
index 89518d2..f5706c1 100644
--- a/src/conjunto_ordenado.c
+++ b/src/conjunto_ordenado.c
@@ -1,4 +1,5 @@
 #include <stdio.h>
+#include <string.h>
 #include <math.h>
 #include "conjunto_ordenado.h"
 
@@ -156,19 +157,14 @@ void conjord_imprime_conjunto(conjord *c)
         conjord_imprime_conjunto_helper(c->pr);
 }
 
-char buffer[100] = "";
-int count_buffer = 0;
+static char buffer[100] = "";
+static int count_buffer = 0;
 static void conjord_retorna_elementos(rb_n *n)
 {
     if (n == &rb_s)
-    {
-        buffer[count_buffer] = '\0';
         return;
-    }
-
     conjord_retorna_elementos(n->l);
     buffer[count_buffer++] = *(char *)n->d;
-    // printf("^%c\n", *(char *)n->d);
     conjord_retorna_elementos(n->r);
 }
 
@@ -176,7 +172,7 @@ static void conjord_imprime_venn_helper(char *letra)
 {
     static int n_letra = 0;
     int x = 0, y = 4, p;  
-    int a = 18, b = 40, r = 2;
+    int a = 18, b = 40, r = 8;
     int c0, c1;
 
     if (!letra)

commit 3e2b62554d82b63b93e585c33352b25955d6ec30
Author: Joilnen <joilnen@gmail.com>
Date:   Sat Jan 8 15:29:43 2022 -0300

    uniao e subtracao de conjuntos funcionando serao usados pra fazer a interesec

diff --git a/src/conjunto_ordenado.c b/src/conjunto_ordenado.c
index f5706c1..22e4a61 100644
--- a/src/conjunto_ordenado.c
+++ b/src/conjunto_ordenado.c
@@ -157,104 +157,87 @@ void conjord_imprime_conjunto(conjord *c)
         conjord_imprime_conjunto_helper(c->pr);
 }
 
-static char buffer[100] = "";
-static int count_buffer = 0;
-static void conjord_retorna_elementos(rb_n *n)
+static void conjord_imprime_venn_helper(rb_n *n)
 {
     if (n == &rb_s)
         return;
-    conjord_retorna_elementos(n->l);
-    buffer[count_buffer++] = *(char *)n->d;
-    conjord_retorna_elementos(n->r);
+
+    conjord_imprime_venn_helper(n->l);
+    conjord_imprime_elemento(n->d);
+    printf(", ");
+    conjord_imprime_venn_helper(n->r);
+}
+
+void conjord_imprime_venn(conjord *c, int pos)
+{
+    if (c && c->pr)
+    {
+        printf("%s = {", c->nome);
+        conjord_imprime_venn_helper(c->pr);
+        printf("\033[D\033[D");
+        printf("}");
+    }
 }
 
-static void conjord_imprime_venn_helper(char *letra)
+/**
+ * insersecciona dois conjuntos formando um terceiro
+ * como resultado desta operacao retornando seu ponteiro
+ * a seguir A intesec B = (A uniao B) - [(A - B) uniao (B - A)]
+ */
+conjord *conjord_interseciona(conjord *a, conjord *b)
 {
-    static int n_letra = 0;
-    int x = 0, y = 4, p;  
-    int a = 18, b = 40, r = 8;
-    int c0, c1;
+    conjord *cj_c = conjord_cria("C");
+    conjord *cj_d = conjord_cria("D");
+    conjord *cj_e = conjord_cria("E");
+    conjord_une(conjord_une(cj_c, a), b);
+}
 
-    if (!letra)
+static void  conjord_une_helper(conjord *c, rb_n *n)
+{
+    if (n == &rb_s)
         return;
 
-    for (c0 = 0; c0 < 4 && letra[c0]; c0++)
-    {
-        switch (c0)
-        {
-            case 0:
-                printf("\033[%d;%dH%c", a, b+r, letra[c0]);  
-            break;
-            case 1:
-                printf("\033[%d;%dH%c", a, b-r, letra[c0]);  
-            break;
-            case 2:
-                printf("\033[%d;%dH%c", a-r, b, letra[c0]);  
-            break;
-            case 3:
-                printf("\033[%d;%dH%c", a+r, b, letra[c0]);  
-        }
-    }
-    getc(stdin);
-    p = 5/4 - r;  
-
-    while (x <= y)  
-    {  
-        if (p < 0)  
-            p += (4*x) + 6;  
-        else  
-        {  
-            p += (2*(x-y)) + 5;  
-            y--;  
-        }  
-        x++;  
-        for (; letra[c0]; c0++)
-        {
-            switch (c0 % 8)
-            {
-                case 0:
-                    printf("\033[%d;%dH%c", a+x, b+y, letra[c0]);  
-                    break;
-                case 1:
-                    printf("\033[%d;%dH%c", a-x, b+y, letra[c0]);  
-                    break;
-                case 2:
-                    printf("\033[%d;%dH%c", a+x, b-y, letra[c0]);  
-                    break;
-                case 3:
-                    printf("\033[%d;%dH%c", a+x, b-y, letra[c0]);  
-                    break;
-                case 4:
-                    printf("\033[%d;%dH%c", a+x, b+y, letra[c0]);  
-                    break;
-                case 5:
-                    printf("\033[%d;%dH%c", a+x, b-y, letra[c0]);  
-                    break;
-                case 6:
-                    printf("\033[%d;%dH%c", a-x, b+y, letra[c0]);  
-                    break;
-                case 7:
-                    printf("\033[%d;%dH%c", a-x, b-y, letra[c0]);  
-            }
-            getc(stdin);
-        }
-    }  
+    conjord_insere_elemento(c, n->k, n->d);
+    conjord_une_helper(c, n->l);
+    conjord_une_helper(c, n->r);
 }
 
-void conjord_imprime_venn(conjord *c, int pos)
+/**
+ * une dois conjuntos formando um terceiro
+ * como resultado desta operacao retornando seu ponteiro
+ * a seguir
+ */
+conjord *conjord_une(conjord *a, conjord *b)
 {
-    if (c && c->pr)
-    {
-        if (pos == 2)
-            printf("\033[12;55H");
-        else if (pos == 1)
-            printf("\033[12;15H");
-        else
-            printf("\033[18;40H");
-        /* tricky */
-        conjord_retorna_elementos(c->pr);
-        conjord_imprime_venn_helper(buffer);
-    }
+    conjord *cj_c = conjord_cria("C");
+    conjord_une_helper(cj_c, a->pr);
+    conjord_une_helper(cj_c, b->pr);
+    return cj_c;
 }
 
+static void  conjord_subtrai_helper(conjord *c, rb_n *n)
+{
+    if (n == &rb_s)
+        return;
+
+    conjord_deleta_elemento(c, n->k);
+    conjord_subtrai_helper(c, n->l);
+    conjord_subtrai_helper(c, n->r);
+}
+
+/**
+ * subtrai dois conjuntos formando um terceiro
+ * como resultado desta operacao retornando seu ponteiro
+ * a seguir
+ */
+conjord *conjord_subtrai(conjord *a, conjord *b)
+{
+    conjord *cj_c = conjord_cria("C");
+    cj_c->pr = &rb_s;
+    conjord_une_helper(cj_c, a->pr);
+    conjord_subtrai_helper(cj_c, b->pr);
+    return cj_c;
+}
+
+
 
diff --git a/src/testa_item_3.c b/src/testa_item_3.c
index b6dc39b..178608e 100644
--- a/src/testa_item_3.c
+++ b/src/testa_item_3.c
@@ -63,16 +63,17 @@ void testa_item_3(const char *m)
     conjord *cj_a = conjord_cria("A");
     conjord *cj_b = conjord_cria("B");
     int imp, pos0 = 0, pos1 = 1, pos2 = 2;
-    char elem0[] = "ABCDEFGHIJKLMNOP";
-    char elem1[] = "JKLMNOPQRSTUVXYZ";
+    char elem0[] = "ABCDEF";
+    char elem1[] = "DEFGHI";
 
     LTELA;
     adiciona_venn(cj_a, pos1, elem0);
     adiciona_venn(cj_b, pos2, elem1);
-    conjord_imprime_conjunto(cj_a);
-    CM;
-    // conjord_imprime_conjunto(cj_b);
     conjord_imprime_venn(cj_a, pos0);
+    printf("\n");
+    conjord_imprime_venn(cj_b, pos0);
+    printf("\n");
+    conjord_imprime_venn(conjord_une(cj_a, cj_b), pos0);
     INFO("* item 3.1 operacoes com conjuntos");
     CM;
 }
@@ -80,7 +81,7 @@ void testa_item_3(const char *m)
 void imprime_meu_tipo(void *n)
 {
     if(n)
-        printf("%c \n", ((meu_tipo3 *)n)->letra);
+        printf("%c", ((meu_tipo3 *)n)->letra);
 }
 
 

commit f44b022e519b3cc1c5345abb01cb2ebad6a54256
Author: Joilnen <joilnen@gmail.com>
Date:   Sat Jan 8 15:37:44 2022 -0300

    trocado a checagem de NULL por noh sentinela dentro do TAD, caso quebre tudo
    retornar voltar ao que era

diff --git a/src/conjunto_ordenado.c b/src/conjunto_ordenado.c
index 22e4a61..97ca104 100644
--- a/src/conjunto_ordenado.c
+++ b/src/conjunto_ordenado.c
@@ -12,7 +12,7 @@ static unsigned int r_counter = 0;
 conjord *conjord_cria(char *nome)
 {
     conjord *c = (conjord *) malloc (sizeof(conjord));
-    c->pr = NULL;
+    c->pr = &rb_s;
     c->idx = r_counter;
     c->nome = nome;
     c->cardinalidade = 0;
@@ -117,7 +117,7 @@ int conjord_esvazia(conjord *c)
         conjord_esvazia_helper(c->pr);
         c->cardinalidade = 0;
         free(c->pr);
-        c->pr = NULL;
+        c->pr = &rb_s;
     }
 }
 
@@ -189,7 +189,8 @@ conjord *conjord_interseciona(conjord *a, conjord *b)
     conjord *cj_c = conjord_cria("C");
     conjord *cj_d = conjord_cria("D");
     conjord *cj_e = conjord_cria("E");
-    conjord_une(conjord_une(cj_c, a), b);
+
+    // cj_c = conjord_subtrai(conjord_une(conjord_une(cj_c, a), b), ;
 }
 
 static void  conjord_une_helper(conjord *c, rb_n *n)

commit 2dd55415ef310e2951c011b0605d38cc05ad2729
Author: Joilnen <joilnen@gmail.com>
Date:   Sat Jan 8 15:51:20 2022 -0300

    intersecao funcionando

diff --git a/src/conjunto_ordenado.c b/src/conjunto_ordenado.c
index 97ca104..0dcc039 100644
--- a/src/conjunto_ordenado.c
+++ b/src/conjunto_ordenado.c
@@ -186,11 +186,12 @@ void conjord_imprime_venn(conjord *c, int pos)
  */
 conjord *conjord_interseciona(conjord *a, conjord *b)
 {
-    conjord *cj_c = conjord_cria("C");
-    conjord *cj_d = conjord_cria("D");
-    conjord *cj_e = conjord_cria("E");
-
-    // cj_c = conjord_subtrai(conjord_une(conjord_une(cj_c, a), b), ;
+    conjord *cj_a = conjord_cria("A");
+    conjord *aub = conjord_une(conjord_une(cj_a, a), b);
+    conjord *amb = conjord_subtrai(conjord_une(cj_a, a), b);
+    conjord *bma = conjord_subtrai(conjord_une(cj_a, b), a);
+    conjord *ambubma = conjord_une(amb, bma);
+    return conjord_subtrai(aub, ambubma);
 }
 
 static void  conjord_une_helper(conjord *c, rb_n *n)
@@ -234,7 +235,6 @@ static void  conjord_subtrai_helper(conjord *c, rb_n *n)
 conjord *conjord_subtrai(conjord *a, conjord *b)
 {
     conjord *cj_c = conjord_cria("C");
-    cj_c->pr = &rb_s;
     conjord_une_helper(cj_c, a->pr);
     conjord_subtrai_helper(cj_c, b->pr);
     return cj_c;
diff --git a/src/testa_item_3.c b/src/testa_item_3.c
index 178608e..87431ce 100644
--- a/src/testa_item_3.c
+++ b/src/testa_item_3.c
@@ -73,7 +73,7 @@ void testa_item_3(const char *m)
     printf("\n");
     conjord_imprime_venn(cj_b, pos0);
     printf("\n");
-    conjord_imprime_venn(conjord_une(cj_a, cj_b), pos0);
+    conjord_imprime_venn(conjord_interseciona(cj_a, cj_b), pos0);
     INFO("* item 3.1 operacoes com conjuntos");
     CM;
 }

commit 486d5a7efdd52f75117ce8a4de53fa00ec0929ec
Author: Joilnen <joilnen@gmail.com>
Date:   Sat Jan 8 15:59:18 2022 -0300

    todos os itens parecem estar satisfeitos

diff --git a/src/testa_item_3.c b/src/testa_item_3.c
index 87431ce..31e34fc 100644
--- a/src/testa_item_3.c
+++ b/src/testa_item_3.c
@@ -73,6 +73,24 @@ void testa_item_3(const char *m)
     printf("\n");
     conjord_imprime_venn(cj_b, pos0);
     printf("\n");
+    conjord_imprime_venn(conjord_une(cj_a, cj_b), pos0);
+    INFO("* item 3.1 operacoes com conjuntos");
+    CM;
+
+    LTELA;
+    conjord_imprime_venn(cj_a, pos0);
+    printf("\n");
+    conjord_imprime_venn(cj_b, pos0);
+    printf("\n");
+    conjord_imprime_venn(conjord_subtrai(cj_a, cj_b), pos0);
+    INFO("* item 3.1 operacoes com conjuntos");
+    CM;
+
+    LTELA;
+    conjord_imprime_venn(cj_a, pos0);
+    printf("\n");
+    conjord_imprime_venn(cj_b, pos0);
+    printf("\n");
     conjord_imprime_venn(conjord_interseciona(cj_a, cj_b), pos0);
     INFO("* item 3.1 operacoes com conjuntos");
     CM;

commit 22b55cf6650d3b4d7d16f1e755a4a936340d75fd
Author: Joilnen <joilnen@gmail.com>
Date:   Sat Jan 8 16:21:43 2022 -0300

    info no teste final na arvore

diff --git a/src/testa_item_3.c b/src/testa_item_3.c
index 31e34fc..7d50af4 100644
--- a/src/testa_item_3.c
+++ b/src/testa_item_3.c
@@ -74,7 +74,7 @@ void testa_item_3(const char *m)
     conjord_imprime_venn(cj_b, pos0);
     printf("\n");
     conjord_imprime_venn(conjord_une(cj_a, cj_b), pos0);
-    INFO("* item 3.1 operacoes com conjuntos");
+    INFO("* item 3.1 uniao de conjuntos");
     CM;
 
     LTELA;
@@ -83,7 +83,7 @@ void testa_item_3(const char *m)
     conjord_imprime_venn(cj_b, pos0);
     printf("\n");
     conjord_imprime_venn(conjord_subtrai(cj_a, cj_b), pos0);
-    INFO("* item 3.1 operacoes com conjuntos");
+    INFO("* item 3.1 subtracao de conjuntos");
     CM;
 
     LTELA;
@@ -92,7 +92,13 @@ void testa_item_3(const char *m)
     conjord_imprime_venn(cj_b, pos0);
     printf("\n");
     conjord_imprime_venn(conjord_interseciona(cj_a, cj_b), pos0);
-    INFO("* item 3.1 operacoes com conjuntos");
+    INFO("* item 3.1 interseccao com conjuntos");
+    CM;
+
+    LTELA;
+    tela_checklist(1 << I3_1);
+    tela_checklist(1 << I3_2);
+    tela_checklist(1 << I3_3);
     CM;
 }
 
diff --git a/src/testa_rb.c b/src/testa_rb.c
index d218910..c9bbae7 100644
--- a/src/testa_rb.c
+++ b/src/testa_rb.c
@@ -12,9 +12,20 @@
 
 void tela_testa_rb(const char *m)
 {
+    int l = 5, c = 24, f;
+    char mens[6][48] =
+    {
+        S_UNDERL"serah efetuado os testes:"S_NORM,
+        "insercao e remocao na arvore",
+        "nao foi pedido mas me ajudou a",
+        "checar a correcao da arvore"
+    };
     LTELA;
-    printf("Testa rb\n");
+    for (f = 0; f < 4; f++)
+        CKLSITEM(l++, c, 0, mens[f]);
+    INFO_FILE(__FILE__);
     CM;
+
 }
 
 /**

commit 6f6086039095bdf0b9edd3a663bc20017c5b8166
Author: Joilnen <joilnen@gmail.com>
Date:   Sat Jan 8 16:24:55 2022 -0300

    consertando uma mensagem errada

diff --git a/src/testa_rb.c b/src/testa_rb.c
index c9bbae7..dbe2a09 100644
--- a/src/testa_rb.c
+++ b/src/testa_rb.c
@@ -16,7 +16,7 @@ void tela_testa_rb(const char *m)
     char mens[6][48] =
     {
         S_UNDERL"serah efetuado os testes:"S_NORM,
-        "insercao e remocao na arvore",
+        "insersao e remocao na arvore",
         "nao foi pedido mas me ajudou a",
         "checar a correcao da arvore"
     };

commit 116562333b47be7503932a0e77e4193e850a9027
Author: Joilnen <joilnen@gmail.com>
Date:   Sat Jan 8 16:40:37 2022 -0300

    limpando codigo nao utilizado

diff --git a/src/testa_rb.c b/src/testa_rb.c
index dbe2a09..77edb91 100644
--- a/src/testa_rb.c
+++ b/src/testa_rb.c
@@ -111,263 +111,6 @@ void testa_arvore_rb(const char *m)
         CM;
     }
     LTELA;
-
-    /**
-     * cria noh raiz, utiliza a tecnica de macro pois simplifica e deixa
-     * uma interface mais intuitiva ao usuario da biblioteca
-     * @parametro 0 nome variavel do noh raiz
-     * @parametro 1 chave do noh raiz
-     * @parametro 2 dado criado neste noh, pode ser de qqr tipo
-     */
-//     rb_n *conjunto_a = rb_cr(10, &mt0);
-// 
-//     LTELA;
-//     rb_pr(conjunto_a, TCOLOR);
-//     printf("\n");
-//     printf("= arvore ===================\n");
-//     conjord_imprime_rb(conjunto_a, 1, TCOLOR);
-//     printf("= ==========================\n");
-//     printf("%s", m);
-//     getc(stdin);
-// 
-//     meu_tipo mt8;
-//     mt8.nome = (char *) malloc(sizeof("nome para teste") + 1);
-//     strncpy(mt8.nome, "nome para teste", sizeof("nome para teste") + 1);
-//     mt8.telefone = (char *) malloc(sizeof("999999999") + 1);
-//     strncpy(mt8.telefone, "999999999", sizeof("999999999") + 1);
-// 
-//     rb_n *novo_noh = (rb_n *) malloc (sizeof(rb_n));
-//     novo_noh->k = 9;
-//     novo_noh->d = &mt8;
-// 
-//     rb_insert(&conjunto_a, novo_noh);
-// 
-//     meu_tipo mt1;
-//     mt1.nome = (char *) malloc(sizeof("nome para teste") + 1);
-//     strncpy(mt1.nome, "nome para teste", sizeof("nome para teste") + 1);
-//     mt1.telefone = (char *) malloc(sizeof("999999999") + 1);
-//     strncpy(mt1.telefone, "999999999", sizeof("999999999") + 1);
-// 
-//     novo_noh = (rb_n *) malloc (sizeof(rb_n));
-//     novo_noh->k = 9;
-//     novo_noh->d = &mt1;
-// 
-//     rb_insert(&conjunto_a, novo_noh);
-// 
-//     LTELA;
-//     rb_pr(conjunto_a, TCOLOR);
-//     printf("\n");
-//     printf("= arvore ===================\n");
-//     conjord_imprime_rb(conjunto_a, 1, TCOLOR);
-//     printf("= ==========================\n");
-//     printf("%s", m);
-//     getc(stdin);
-// 
-//     meu_tipo mt2;
-//     mt2.nome = (char *) malloc(sizeof("nome para teste") + 1);
-//     strncpy(mt2.nome, "nome para teste", sizeof("nome para teste") + 1);
-//     mt2.telefone = (char *) malloc(sizeof("999999999") + 1);
-//     strncpy(mt2.telefone, "999999999", sizeof("999999999") + 1);
-// 
-//     novo_noh = (rb_n *) malloc (sizeof(rb_n));
-//     novo_noh->k = 11;
-//     novo_noh->d = &mt2;
-//     rb_insert(&conjunto_a, novo_noh);
-// 
-//     LTELA;
-//     rb_pr(conjunto_a, TCOLOR);
-//     printf("\n");
-//     printf("= arvore ===================\n");
-//     conjord_imprime_rb(conjunto_a, 1, TCOLOR);
-//     printf("= ==========================\n");
-//     printf("%s", m);
-//     getc(stdin);
-// 
-//     meu_tipo mt3;
-//     mt3.nome = (char *) malloc(sizeof("nome para teste") + 1);
-//     strncpy(mt3.nome, "nome para teste", sizeof("nome para teste") + 1);
-//     mt3.telefone = (char *) malloc(sizeof("999999999") + 1);
-//     strncpy(mt3.telefone, "999999999", sizeof("999999999") + 1);
-// 
-//     novo_noh = (rb_n *) malloc (sizeof(rb_n));
-//     novo_noh->k = 8;
-//     novo_noh->d = &mt3;
-//     rb_insert(&conjunto_a, novo_noh);
-// 
-//     LTELA;
-//     rb_pr(conjunto_a, TCOLOR);
-//     printf("\n");
-//     printf("= arvore ===================\n");
-//     conjord_imprime_rb(conjunto_a, 1, TCOLOR);
-//     printf("= ==========================\n");
-//     printf("%s", m);
-//     getc(stdin);
-// 
-//     meu_tipo mt4;
-//     mt4.nome = (char *) malloc(sizeof("nome para teste") + 1);
-//     strncpy(mt4.nome, "nome para teste", sizeof("nome para teste") + 1);
-//     mt4.telefone = (char *) malloc(sizeof("999999999") + 1);
-//     strncpy(mt4.telefone, "999999999", sizeof("999999999") + 1);
-// 
-//     novo_noh = (rb_n *) malloc (sizeof(rb_n));
-//     novo_noh->k = 6;
-//     novo_noh->d = &mt4;
-//     rb_insert(&conjunto_a, novo_noh);
-// 
-//     LTELA;
-//     rb_pr(conjunto_a, TCOLOR);
-//     printf("\n");
-//     printf("= arvore ===================\n");
-//     conjord_imprime_rb(conjunto_a, 1, TCOLOR);
-//     printf("= ==========================\n");
-//     printf("%s", m);
-//     getc(stdin);
-// 
-//     meu_tipo mt5;
-//     mt5.nome = (char *) malloc(sizeof("nome para teste") + 1);
-//     strncpy(mt5.nome, "nome para teste", sizeof("nome para teste") + 1);
-//     mt5.telefone = (char *) malloc(sizeof("999999999") + 1);
-//     strncpy(mt5.telefone, "999999999", sizeof("999999999") + 1);
-// 
-//     novo_noh = (rb_n *) malloc (sizeof(rb_n));
-//     novo_noh->k = 5;
-//     novo_noh->d = &mt5;
-//     rb_insert(&conjunto_a, novo_noh);
-// 
-//     LTELA;
-//     rb_pr(conjunto_a, TCOLOR);
-//     printf("\n");
-//     printf("= arvore ===================\n");
-//     conjord_imprime_rb(conjunto_a, 1, TCOLOR);
-//     printf("= ==========================\n");
-//     printf("%s", m);
-// 
-//     meu_tipo mt6;
-//     mt6.nome = (char *) malloc(sizeof("nome para teste") + 1);
-//     strncpy(mt6.nome, "nome para teste", sizeof("nome para teste") + 1);
-//     mt6.telefone = (char *) malloc(sizeof("999999999") + 1);
-//     strncpy(mt6.telefone, "999999999", sizeof("999999999") + 1);
-// 
-//     novo_noh = (rb_n *) malloc (sizeof(rb_n));
-//     novo_noh->k = 4;
-//     novo_noh->d = &mt6;
-//     rb_insert(&conjunto_a, novo_noh);
-// 
-//     LTELA;
-//     rb_pr(conjunto_a, TCOLOR);
-//     printf("\n");
-//     printf("= arvore ===================\n");
-//     conjord_imprime_rb(conjunto_a, 1, TCOLOR);
-//     printf("= ==========================\n");
-//     printf("%s", m);
-//     getc(stdin);
-// 
-//     meu_tipo mt7;
-//     mt7.nome = (char *) malloc(sizeof("nome para teste") + 1);
-//     strncpy(mt7.nome, "nome para teste", sizeof("nome para teste") + 1);
-//     mt7.telefone = (char *) malloc(sizeof("999999999") + 1);
-//     strncpy(mt7.telefone, "999999999", sizeof("999999999") + 1);
-// 
-//     novo_noh = (rb_n *) malloc (sizeof(rb_n));
-//     novo_noh->k = 3;
-//     novo_noh->d = &mt7;
-//     rb_insert(&conjunto_a, novo_noh);
-// 
-//     LTELA;
-//     rb_pr(conjunto_a, TCOLOR);
-//     printf("\n");
-//     printf("= arvore ===================\n");
-//     conjord_imprime_rb(conjunto_a, 1, TCOLOR);
-//     printf("= ==========================\n");
-//     printf("%s", m);
-//     getc(stdin);
-// 
-//     rb_delete(&conjunto_a, rb_search(conjunto_a, 3));
-//     printf("\n");
-//     LTELA;
-//     rb_pr(conjunto_a, TCOLOR);
-//     printf("\n");
-//     printf("= arvore ===================\n");
-//     conjord_imprime_rb(conjunto_a, 1, TCOLOR);
-//     printf("= ==========================\n");
-//     printf("%s", m);
-//     getc(stdin);
-// 
-//     rb_delete(&conjunto_a, rb_search(conjunto_a, 11));
-//     LTELA;
-//     rb_pr(conjunto_a, TCOLOR);
-//     printf("\n");
-//     printf("= arvore ===================\n");
-//     conjord_imprime_rb(conjunto_a, 1, TCOLOR);
-//     printf("= ==========================\n");
-//     printf("%s", m);
-//     getc(stdin);
-// 
-//     rb_delete(&conjunto_a, rb_search(conjunto_a, 4));
-//     LTELA;
-//     rb_pr(conjunto_a, TCOLOR);
-//     printf("\n");
-//     printf("= arvore ===================\n");
-//     conjord_imprime_rb(conjunto_a, 1, TCOLOR);
-//     printf("= ==========================\n");
-//     printf("%s", m);
-//     getc(stdin);
-// 
-//     rb_delete(&conjunto_a, rb_search(conjunto_a, 8));
-//     LTELA;
-//     rb_pr(conjunto_a, TCOLOR);
-//     printf("\n");
-//     printf("= arvore ===================\n");
-//     conjord_imprime_rb(conjunto_a, 1, TCOLOR);
-//     printf("= ==========================\n");
-//     printf("%s", m);
-//     getc(stdin);
-// 
-//     rb_delete(&conjunto_a, rb_search(conjunto_a, 9));
-//     LTELA;
-//     rb_pr(conjunto_a, TCOLOR);
-//     printf("\n");
-//     printf("= arvore ===================\n");
-//     conjord_imprime_rb(conjunto_a, 1, TCOLOR);
-//     printf("= ==========================\n");
-//     printf("%s", m);
-//     getc(stdin);
-//     rb_pr(conjunto_a, TCOLOR);
-//     printf("\n");
-// 
-//     rb_delete(&conjunto_a, rb_search(conjunto_a, 5));
-//     LTELA;
-//     rb_pr(conjunto_a, TCOLOR);
-//     printf("\n");
-//     printf("= arvore ===================\n");
-//     conjord_imprime_rb(conjunto_a, 1, TCOLOR);
-//     printf("= ==========================\n");
-//     printf("%s", m);
-//     getc(stdin);
-// 
-//     rb_delete(&conjunto_a, rb_search(conjunto_a, 10));
-//     LTELA;
-//     rb_pr(conjunto_a, TCOLOR);
-//     printf("\n");
-//     printf("= arvore ===================\n");
-//     conjord_imprime_rb(conjunto_a, 1, TCOLOR);
-//     printf("= ==========================\n");
-//     printf("%s", m);
-//     getc(stdin);
-// 
-//     rb_delete(&conjunto_a, rb_search(conjunto_a, 6));
-//     LTELA;
-//     printf("nada\n");
-//     printf("= arvore ===================\n");
-//     conjord_imprime_rb(conjunto_a, 1, TCOLOR);
-//     printf("= ==========================\n");
-//     rb_pr(conjunto_a, TCOLOR);
-//     printf("\n");
-    /**
-     * testando apenas rb no momento
-    conjord *conj_a = conjord_cria();
-    printf("eh vazio %d", conjord_eh_vazio(conj_a));
-    */
 }
 
 /**

commit 8ea985f270e97d3ab18d8035e9621883e8f5eff7
Author: Joilnen <joilnen@gmail.com>
Date:   Sun Jan 9 06:29:26 2022 -0300

    removendo parametro desnecessario

diff --git a/src/conjunto_ordenado.c b/src/conjunto_ordenado.c
index 0dcc039..6602160 100644
--- a/src/conjunto_ordenado.c
+++ b/src/conjunto_ordenado.c
@@ -168,7 +168,7 @@ static void conjord_imprime_venn_helper(rb_n *n)
     conjord_imprime_venn_helper(n->r);
 }
 
-void conjord_imprime_venn(conjord *c, int pos)
+void conjord_imprime_venn(conjord *c)
 {
     if (c && c->pr)
     {
diff --git a/src/conjunto_ordenado.h b/src/conjunto_ordenado.h
index e788918..ffa7160 100644
--- a/src/conjunto_ordenado.h
+++ b/src/conjunto_ordenado.h
@@ -127,7 +127,7 @@ int conjord_seta_imprime_elemento(void (*i)(void *n));
 
 void conjord_imprime_conjunto(conjord *c);
 
-void conjord_imprime_venn(conjord *c, int pos);
+void conjord_imprime_venn(conjord *c);
 
 
 /**
diff --git a/src/testa_item_3.c b/src/testa_item_3.c
index 7d50af4..aadf98d 100644
--- a/src/testa_item_3.c
+++ b/src/testa_item_3.c
@@ -69,29 +69,29 @@ void testa_item_3(const char *m)
     LTELA;
     adiciona_venn(cj_a, pos1, elem0);
     adiciona_venn(cj_b, pos2, elem1);
-    conjord_imprime_venn(cj_a, pos0);
+    conjord_imprime_venn(cj_a);
     printf("\n");
-    conjord_imprime_venn(cj_b, pos0);
+    conjord_imprime_venn(cj_b);
     printf("\n");
-    conjord_imprime_venn(conjord_une(cj_a, cj_b), pos0);
+    conjord_imprime_venn(conjord_une(cj_a, cj_b));
     INFO("* item 3.1 uniao de conjuntos");
     CM;
 
     LTELA;
-    conjord_imprime_venn(cj_a, pos0);
+    conjord_imprime_venn(cj_a);
     printf("\n");
-    conjord_imprime_venn(cj_b, pos0);
+    conjord_imprime_venn(cj_b);
     printf("\n");
-    conjord_imprime_venn(conjord_subtrai(cj_a, cj_b), pos0);
+    conjord_imprime_venn(conjord_subtrai(cj_a, cj_b));
     INFO("* item 3.1 subtracao de conjuntos");
     CM;
 
     LTELA;
-    conjord_imprime_venn(cj_a, pos0);
+    conjord_imprime_venn(cj_a);
     printf("\n");
-    conjord_imprime_venn(cj_b, pos0);
+    conjord_imprime_venn(cj_b);
     printf("\n");
-    conjord_imprime_venn(conjord_interseciona(cj_a, cj_b), pos0);
+    conjord_imprime_venn(conjord_interseciona(cj_a, cj_b));
     INFO("* item 3.1 interseccao com conjuntos");
     CM;
 

commit b81c6a1e2353669e3b891a47fe65f105428a034e
Author: Joilnen <joilnen@gmail.com>
Date:   Sun Jan 9 06:54:24 2022 -0300

    deleteando recursivamente os dados dos nohs da arvore

diff --git a/src/conjunto_ordenado.c b/src/conjunto_ordenado.c
index 6602160..40fb827 100644
--- a/src/conjunto_ordenado.c
+++ b/src/conjunto_ordenado.c
@@ -29,7 +29,8 @@ void conjord_destroi(conjord *c)
         return;
     if(!c->pr)
         return;
-    free(c->pr);
+    conjord_esvazia(c);
+    // free(c->pr);
     free(c);
 }
 

commit 68b80179418c9d2c3d7a131cdde64670c5419c05
Author: Joilnen <joilnen@gmail.com>
Date:   Mon Jan 10 11:40:42 2022 -0300

    apenas limpando o codigo

diff --git a/src/testa_item_1.c b/src/testa_item_1.c
index 925553b..815cfdb 100644
--- a/src/testa_item_1.c
+++ b/src/testa_item_1.c
@@ -62,12 +62,12 @@ void testa_item_1(const char *m)
     CM;
 
     LTELA;
-    conjord_imprime_arvore_rb(cj_a, 1);
+    conjord_imprime_arvore_rb(cj_a, 0);
     INFO("* item 4 mostra da arvore atual");
     CM;
 
     LTELA;
-    tela_checklist((1 << I4));
+    tela_checklist(1 << I4);
     CM;
 
     LTELA;
@@ -76,7 +76,7 @@ void testa_item_1(const char *m)
     CM;
 
     LTELA;
-    tela_checklist((1 << I1_1));
+    tela_checklist(1 << I1_1);
     CM;
 
     conjord_destroi(cj_a);

commit 656484f2f5dd5218eda052e794dbaaacc3b2d53a
Author: Joilnen <joilnen@gmail.com>
Date:   Mon Jan 10 11:58:22 2022 -0300

    implementado checagem se elemento existe no conjord

diff --git a/src/conjunto_ordenado.c b/src/conjunto_ordenado.c
index 40fb827..cb26a7b 100644
--- a/src/conjunto_ordenado.c
+++ b/src/conjunto_ordenado.c
@@ -241,5 +241,8 @@ conjord *conjord_subtrai(conjord *a, conjord *b)
     return cj_c;
 }
 
-
+int conjord_existe_elemento(conjord *a, int chave)
+{
+    return rb_search(a->pr, chave) ? 1: 0;
+}
 

commit 72803c65324b042f3f5c89821e3ffde945063bfb
Author: Joilnen <joilnen@gmail.com>
Date:   Mon Jan 10 12:03:18 2022 -0300

    adaptando checagem de vazio para usar sentinela

diff --git a/src/conjunto_ordenado.c b/src/conjunto_ordenado.c
index cb26a7b..5cc561d 100644
--- a/src/conjunto_ordenado.c
+++ b/src/conjunto_ordenado.c
@@ -80,21 +80,12 @@ int conjord_cardinalidade(conjord *c)
         return -1;
 }
 
-/**
- * imprime elementos do conjunto subitem 1 do item 2
- * "imprimir os elementos de um conjunto, em ordem crescente das chaves"
- */
-void conjord_imprime()
-{
-
-}
-
 /**
  * testa se o conjunto estah vazio
  */
 int conjord_eh_vazio(const conjord *a)
 {
-    return !a->pr;
+    return a->pr == &rb_s;
 }
 
 static void conjord_esvazia_helper(rb_n *r)
diff --git a/src/conjunto_ordenado.h b/src/conjunto_ordenado.h
index ffa7160..cdc8fe3 100644
--- a/src/conjunto_ordenado.h
+++ b/src/conjunto_ordenado.h
@@ -39,12 +39,6 @@ int conjord_insere_elemento(conjord *a, int chave, void *elemento);
  */
 void conjord_deleta_elemento(conjord *a, int chave);
 
-/**
- * imprime elementos do conjunto subitem 1 do item 2
- * "imprimir os elementos de um conjunto, em ordem crescente das chaves"
- */
-void conjord_imprime();
-
 /**
  * retorna a cardinalidade do conjunto
  */

commit 0853d6514a22918fc5a0b0e5b58c65f5ee82dec4
Author: Joilnen <joilnen@gmail.com>
Date:   Mon Jan 10 12:21:54 2022 -0300

    adequando ao estilo de escrita do codigo escolhido olhar na doc

diff --git a/src/conjunto_ordenado.c b/src/conjunto_ordenado.c
index 5cc561d..8317cdf 100644
--- a/src/conjunto_ordenado.c
+++ b/src/conjunto_ordenado.c
@@ -25,9 +25,9 @@ conjord *conjord_cria(char *nome)
  */
 void conjord_destroi(conjord *c)
 {
-    if(!c)
+    if (!c)
         return;
-    if(!c->pr)
+    if (!c->pr)
         return;
     conjord_esvazia(c);
     // free(c->pr);
@@ -39,12 +39,12 @@ void conjord_destroi(conjord *c)
  */
 int conjord_insere_elemento(conjord *a, int chave, void *elemento)
 {
-    if (a->pr)
+    if (a->pr != &rb_s)
     {
         rb_n *n = (rb_n *) malloc(sizeof(rb_n));
         n->k = chave;
         n->d = elemento;
-        if(!rb_insert(&a->pr, n))
+        if (!rb_insert(&a->pr, n))
             a->cardinalidade++;
         else
             return -1;
@@ -63,7 +63,7 @@ void conjord_deleta_elemento(conjord *a, int chave)
 {
     rb_n *t = rb_search(a->pr, chave);
 
-    if(t)
+    if (t)
     {
         rb_delete(&a->pr, t);
         a->cardinalidade--;
diff --git a/src/red_black.c b/src/red_black.c
index 447027f..6349dc7 100644
--- a/src/red_black.c
+++ b/src/red_black.c
@@ -155,7 +155,7 @@ static int rb_transplant(rb_n **t, rb_n *u, rb_n *v)
         u->p->l = v;
     else
         u->p->r = v;
-    if(v)
+    if (v)
         v->p = u->p;
 
     return 0;
@@ -378,9 +378,9 @@ void rb_pr(rb_n *t, int s, int e)
     rb_pr(t->r, s, e);  
 
     printf("%*c", s - dist, ' ');
-    if(t->c == BLACK)
+    if (t->c == BLACK)
     {
-        if(e == TCOLOR)
+        if (e == TCOLOR)
             printf("\033[44m\033[37m%d\033[0m\n", t->k);
         else
             printf("%d\n", t->k);
@@ -388,7 +388,7 @@ void rb_pr(rb_n *t, int s, int e)
     }
     else
     {
-        if(e == TCOLOR)
+        if (e == TCOLOR)
             printf("\033[41m\033[37m%d\033[0m\n", t->k);
         else
             printf("\033[7m%d\033[0m\n", t->k, t->c);
@@ -411,7 +411,7 @@ void rb_pr2(rb_n *t, int s, int e)
     //     printf(" ");  
     // printf("%*s", s, "");
     printf("%*c", s - dist, ' ');
-    if(t->c == BLACK)
+    if (t->c == BLACK)
     {
         if(e == TCOLOR)
             printf("\033[44m\033[37mk:%dc:%d\033[0m\n", t->k, t->c);
diff --git a/src/testa.h b/src/testa.h
index 302e359..dcff849 100644
--- a/src/testa.h
+++ b/src/testa.h
@@ -10,6 +10,7 @@
 #include "testa_item_2.h"
 #include "testa_item_3.h"
 #include "testa_rb.h"
+#include "checklist.h"
 
 #endif
 
diff --git a/src/testa_item_1.c b/src/testa_item_1.c
index 815cfdb..ac7e322 100644
--- a/src/testa_item_1.c
+++ b/src/testa_item_1.c
@@ -2,8 +2,7 @@
 #include <string.h>
 #include <time.h>
 #include "conjunto_ordenado.h"
-#include "testa_item_1.h"
-#include "checklist.h"
+#include "testa.h"
 
 static void imprime_meu_tipo(void *);
 
diff --git a/src/testa_item_2.c b/src/testa_item_2.c
index c5c36d7..1de9e99 100644
--- a/src/testa_item_2.c
+++ b/src/testa_item_2.c
@@ -3,7 +3,6 @@
 #include <time.h>
 #include "conjunto_ordenado.h"
 #include "testa.h"
-#include "checklist.h"
 
 /*
  * aluno: joilnen leite
diff --git a/src/testa_item_3.c b/src/testa_item_3.c
index aadf98d..4eab32f 100644
--- a/src/testa_item_3.c
+++ b/src/testa_item_3.c
@@ -3,7 +3,6 @@
 #include <time.h>
 #include "conjunto_ordenado.h"
 #include "testa.h"
-#include "checklist.h"
 /*
  * aluno: joilnen leite
  */
@@ -104,7 +103,7 @@ void testa_item_3(const char *m)
 
 void imprime_meu_tipo(void *n)
 {
-    if(n)
+    if (n)
         printf("%c", ((meu_tipo3 *)n)->letra);
 }
 
diff --git a/src/testa_rb.c b/src/testa_rb.c
index 77edb91..98b0574 100644
--- a/src/testa_rb.c
+++ b/src/testa_rb.c
@@ -28,12 +28,6 @@ void tela_testa_rb(const char *m)
 
 }
 
-/**
- * funcao  de impressao do dipo especifico criado pelo o usuario da biblioteca
- * @noh rb
- */
-static void imprime_meu_tipo(void *);
-
 /**
  * funcao main de teste separada do codigo da biblioteca como especificado
  */
@@ -47,44 +41,13 @@ void testa_arvore_rb(const char *m)
         char *telefone;
     } meu_tipo;
 
-    /**
-     * criacao do dado para o tipo do usuario
-     */
-    meu_tipo mt0;
-    mt0.nome = (char *) malloc(sizeof("nome para teste") + 1);
-    strncpy(mt0.nome, "nome para teste", sizeof("nome para teste") + 1);
-    mt0.telefone = (char *) malloc(sizeof("999999999") + 1);
-    strncpy(mt0.telefone, "999999999", sizeof("999999999") + 1);
-
-    /**
-     * seta a funcao para impressao utiliza aqui a tecnica de ponteiro para funcao
-     */
-    conjord_seta_imprime_elemento(imprime_meu_tipo);
-
-    conjord *cj_a = conjord_cria("A");
-    conjord_insere_elemento(cj_a, 10, &mt0);
-    // LTELA;
-    // conjord_imprime_arvore_rb(cj_a, 1);
-    // CM;
-
-    meu_tipo mt1;
-    mt1.nome = (char *) malloc(sizeof("nome para teste") + 1);
-    strncpy(mt1.nome, "nome para teste", sizeof("nome para teste") + 1);
-    mt1.telefone = (char *) malloc(sizeof("999999999") + 1);
-    strncpy(mt1.telefone, "999999999", sizeof("999999999") + 1);
-
-    conjord_insere_elemento(cj_a, 11, &mt1);
-    // LTELA;
-    // conjord_imprime_arvore_rb(cj_a, 1);
-    // CM;
-
     int ctest;
     conjord *cj_b = conjord_cria("B");
     const int size_n = 21;
     int test_n[size_n];
     for (ctest = 0; ctest < size_n; ++ctest)
     {
-        if(ctest < 10) test_n[ctest] = ctest + 11;
+        if (ctest < 10) test_n[ctest] = ctest + 11;
         else  test_n[ctest] = ctest - 10;
     }
 
@@ -113,13 +76,4 @@ void testa_arvore_rb(const char *m)
     LTELA;
 }
 
-/**
- * definicao da funcao de impressao estipulado pelo cliente, aqui apenas um
- * exemplo
- */
-void imprime_meu_tipo(void *n)
-{
-
-}
-
 

commit 600b1df008af9c670179151f861b7d0f07370b52
Author: Joilnen <joilnen@gmail.com>
Date:   Mon Jan 10 12:30:40 2022 -0300

    corrigindo uma palavra

diff --git a/src/testa_rb.c b/src/testa_rb.c
index 98b0574..470e325 100644
--- a/src/testa_rb.c
+++ b/src/testa_rb.c
@@ -16,7 +16,7 @@ void tela_testa_rb(const char *m)
     char mens[6][48] =
     {
         S_UNDERL"serah efetuado os testes:"S_NORM,
-        "insersao e remocao na arvore",
+        "insercao e remocao na arvore",
         "nao foi pedido mas me ajudou a",
         "checar a correcao da arvore"
     };

commit 9793c61f0a2ff9873af542d37c4dfe166e80340b
Author: Joilnen <joilnen@gmail.com>
Date:   Mon Jan 10 13:00:35 2022 -0300

    removendo funcoes desnecessarias

diff --git a/src/red_black.c b/src/red_black.c
index 6349dc7..8aee293 100644
--- a/src/red_black.c
+++ b/src/red_black.c
@@ -309,21 +309,6 @@ int rb_delete(rb_n **t, rb_n *z)
     return 0;
 }
 
-rb_n* rb_intersec(rb_n *a, rb_n *b)
-{
-    return NULL;
-}
-
-rb_n* rb_une(rb_n *a, rb_n *b)
-{
-    return NULL;
-}
-
-rb_n* rb_subtrai(rb_n *a, rb_n *b)
-{
-    return NULL;
-}
-
 int rb_destroi(rb_n **a)
 {
     return 0;
diff --git a/src/red_black.h b/src/red_black.h
index 98705dc..a4a3331 100644
--- a/src/red_black.h
+++ b/src/red_black.h
@@ -94,30 +94,6 @@ int rb_delete(rb_n **t, rb_n *z);
  */
 int rb_exite_elem(rb_n *a, int k);
 
-/**
- * @param a noh raiz da arvore
- * @param b noh raiz da arvore a ser operada
- * @return retorna ponteiro para uma nova arvore fruto da interseccao
- * das duas arvores @param a  e @param b
- */
-rb_n* rb_intersec(rb_n *a, rb_n *b);
-
-/**
- * @param a noh raiz da arvore
- * @param b noh raiz da arvore a ser operada
- * retorna ponteir para uma nova arvore fruto da uniao
- * das duas arvores @param a  e @param b
- */
-rb_n* rb_une(rb_n *a, rb_n *b);
-
-/**
- * @param a noh raiz da arvore
- * @param b noh raiz da arvore a ser operada
- * retorna ponteir para uma nova arvore fruto da subtracao
- * das duas arvores @param a  e @param b
- */
-rb_n* rb_subtrai(rb_n *a, rb_n *b);
-
 /**
  * deleta, e desaloca recursos de memoria
  * para a arvore apontada por @param a 

commit df48de679915aea4349b67c31376e75939fa77cf
Author: Joilnen <joilnen@gmail.com>
Date:   Tue Jan 11 01:36:43 2022 -0300

    testa arvore com numeros randomicos unicos, podendo ser testado em loop

diff --git a/src/conjunto_ordenado.c b/src/conjunto_ordenado.c
index 8317cdf..9914c53 100644
--- a/src/conjunto_ordenado.c
+++ b/src/conjunto_ordenado.c
@@ -118,11 +118,11 @@ void conjord_imprime_arvore_rb(conjord *c, int s)
     rb_pr(c->pr, s, TCOLOR);  
 }
 
-void conjord_imprime_lista(int *l, int s)
+void conjord_imprime_lista(int *l, int b, int e)
 {
     int i;
-    for (i = 0; i < s; i++)
-        printf(S_LIST, l[i] + 1, l[i]);
+    for (i = b; i < e; i++)
+        printf(S_LIST, i + 1, l[i]);
 }
 
 void (*conjord_imprime_elemento)(void *n);
diff --git a/src/conjunto_ordenado.h b/src/conjunto_ordenado.h
index cdc8fe3..ec09580 100644
--- a/src/conjunto_ordenado.h
+++ b/src/conjunto_ordenado.h
@@ -110,7 +110,7 @@ void conjord_imprime_rb(rb_n *t, int s, int e);
  */
 void conjord_imprime_arvore_rb(conjord *c, int s);
 
-void conjord_imprime_lista(int *l, int s);
+void conjord_imprime_lista(int *l, int s, int e);
 
 extern void (*conjord_imprime_elemento)(void *n);
 extern void* (*conjord_retorna_elemento)(void *n);
@@ -139,6 +139,7 @@ void conjord_imprime_venn(conjord *c);
 #define INFO2(x) printf("%s%s%s", S_INFO2, x, S_NORM)
 #define INFO_ST(x) printf("%s%s%s%s", S_INV, S_INFO_ST, x, S_NORM)
 #define CM printf("%s", m); fflush(stdout); getc(stdin)
+#define CMR(x) printf("%s", S_CMR"q + * tecle enter *"); fflush(stdout); x = getc(stdin)
 #define CKLSITEM(l,c,b,x) \
     if (b) printf(S_CHKLST_DONE, l, c, x); \
     else printf(S_CHKLST, l, c, x)
diff --git a/src/jcurses.h b/src/jcurses.h
index 98b5ec3..f18d7ef 100644
--- a/src/jcurses.h
+++ b/src/jcurses.h
@@ -16,6 +16,7 @@
 
 #define LIMPA_TELA "\033[H\033[J"
 #define S_CM "\033[24;62H"
+#define S_CMR "\033[24;58H"
 #define S_UNDERL "\033[21m"
 #define S_AZUL "\033[44m\033[37m"
 #define S_VERM "\033[41m\033[37m"
diff --git a/src/testa_rb.c b/src/testa_rb.c
index 470e325..c6a0645 100644
--- a/src/testa_rb.c
+++ b/src/testa_rb.c
@@ -8,6 +8,7 @@
 #include "conjunto_ordenado.h"
 #include <stdio.h>
 #include <string.h>
+#include <time.h>
 #include "testa_rb.h"
 
 void tela_testa_rb(const char *m)
@@ -28,6 +29,21 @@ void tela_testa_rb(const char *m)
 
 }
 
+static int pega_unico(int *l, int s)
+{
+    srand(time(NULL));
+    int i = rand() % 99 + 1;
+    int t;
+    for (t = 0; t < s; ++t)
+    {
+        if (i == l[t])
+            t = 0;
+        i = rand() % 99 + 1;
+    }
+
+    return i;
+}
+
 /**
  * funcao main de teste separada do codigo da biblioteca como especificado
  */
@@ -45,35 +61,38 @@ void testa_arvore_rb(const char *m)
     conjord *cj_b = conjord_cria("B");
     const int size_n = 21;
     int test_n[size_n];
-    for (ctest = 0; ctest < size_n; ++ctest)
+    char sai = 10;
+    while (sai == 10)
     {
-        if (ctest < 10) test_n[ctest] = ctest + 11;
-        else  test_n[ctest] = ctest - 10;
-    }
+        for (ctest = 0; ctest < size_n; ++ctest)
+            test_n[ctest] = pega_unico(test_n, ctest);
 
-    LTELA;
-    conjord_imprime_lista(test_n, size_n);
-    CM;
-    for (ctest = 0; ctest < size_n; ++ctest)
-    {
-        conjord_insere_elemento(cj_b, test_n[ctest], NULL);
         LTELA;
-        conjord_imprime_lista(&test_n[ctest + 1], size_n - ctest - 1);
-        printf("\033[H");
-        conjord_imprime_arvore_rb(cj_b, 1);
+        conjord_imprime_lista(test_n, 0, size_n);
         CM;
-    }
+        for (ctest = 0; ctest < size_n; ++ctest)
+        {
+            conjord_insere_elemento(cj_b, test_n[ctest], NULL);
+            LTELA;
+            conjord_imprime_lista(test_n, ctest + 1, size_n);
+            printf("\033[H");
+            conjord_imprime_arvore_rb(cj_b, 1);
+            CM;
+        }
 
-    for (ctest = 0; ctest < size_n; ++ctest)
-    {
+        // conjord_imprime_arvore_rb(cj_b, 1);
+        for (ctest = 0; ctest < size_n; ++ctest)
+        {
+            LTELA;
+            conjord_deleta_elemento(cj_b, test_n[ctest]);
+            conjord_imprime_lista(test_n, 0, ctest + 1);
+            printf("\033[H");
+            conjord_imprime_arvore_rb(cj_b, 1);
+            CM;
+        }
         LTELA;
-        conjord_imprime_lista(test_n, ctest + 1);
-        conjord_deleta_elemento(cj_b, test_n[ctest]);
-        printf("\033[H");
-        conjord_imprime_arvore_rb(cj_b, 1);
-        CM;
+        CMR(sai);
     }
-    LTELA;
 }
 
 

commit 01f945bfa612db99b834c3c5646fd4a80761775b
Author: Joilnen <joilnen@gmail.com>
Date:   Tue Jan 11 02:58:54 2022 -0300

    consertando geracao randomico unico

diff --git a/src/testa_rb.c b/src/testa_rb.c
index c6a0645..5617e8a 100644
--- a/src/testa_rb.c
+++ b/src/testa_rb.c
@@ -37,8 +37,10 @@ static int pega_unico(int *l, int s)
     for (t = 0; t < s; ++t)
     {
         if (i == l[t])
+        {
             t = 0;
-        i = rand() % 99 + 1;
+            i = rand() % 99 + 1;
+        }
     }
 
     return i;

commit 9e7db2fa741433532b3337a8c50132493cc46fec
Author: Joilnen <joilnen@gmail.com>
Date:   Tue Jan 11 11:34:18 2022 -0300

    consertando a impressao quando nao ha intesercao

diff --git a/src/conjunto_ordenado.c b/src/conjunto_ordenado.c
index 9914c53..ef4d273 100644
--- a/src/conjunto_ordenado.c
+++ b/src/conjunto_ordenado.c
@@ -166,7 +166,8 @@ void conjord_imprime_venn(conjord *c)
     {
         printf("%s = {", c->nome);
         conjord_imprime_venn_helper(c->pr);
-        printf("\033[D\033[D");
+        if (c->cardinalidade)
+            printf("\033[D\033[D");
         printf("}");
     }
 }
diff --git a/src/conjunto_ordenado.h b/src/conjunto_ordenado.h
index ec09580..3917c96 100644
--- a/src/conjunto_ordenado.h
+++ b/src/conjunto_ordenado.h
@@ -133,7 +133,7 @@ void conjord_imprime_venn(conjord *c);
  * foi primeiro implementado com um loop
  * mas pensando melhor dessa forma eh mais rapido
  */
-#define LTELA printf(LIMPA_TELA)
+#define LTELA printf(S_LTELA)
 #define TIPO_DE_TERMINAL TCOLOR
 #define INFO(x) printf("%s%s%s", S_INFO, x, S_NORM)
 #define INFO2(x) printf("%s%s%s", S_INFO2, x, S_NORM)
diff --git a/src/jcurses.h b/src/jcurses.h
index f18d7ef..724ae59 100644
--- a/src/jcurses.h
+++ b/src/jcurses.h
@@ -14,7 +14,7 @@
  * primaria que atende as necessidades apenas dessa avaliacao
  */
 
-#define LIMPA_TELA "\033[H\033[J"
+#define S_LTELA "\033[H\033[J"
 #define S_CM "\033[24;62H"
 #define S_CMR "\033[24;58H"
 #define S_UNDERL "\033[21m"
diff --git a/src/testa_item_3.c b/src/testa_item_3.c
index 4eab32f..ba9966d 100644
--- a/src/testa_item_3.c
+++ b/src/testa_item_3.c
@@ -63,7 +63,7 @@ void testa_item_3(const char *m)
     conjord *cj_b = conjord_cria("B");
     int imp, pos0 = 0, pos1 = 1, pos2 = 2;
     char elem0[] = "ABCDEF";
-    char elem1[] = "DEFGHI";
+    char elem1[] = "GHIJKL";
 
     LTELA;
     adiciona_venn(cj_a, pos1, elem0);
diff --git a/src/testa_rb.c b/src/testa_rb.c
index 5617e8a..149abad 100644
--- a/src/testa_rb.c
+++ b/src/testa_rb.c
@@ -71,6 +71,7 @@ void testa_arvore_rb(const char *m)
 
         LTELA;
         conjord_imprime_lista(test_n, 0, size_n);
+        INFO("* insere/remove 20 elem. chave unica entre 1 a 99");
         CM;
         for (ctest = 0; ctest < size_n; ++ctest)
         {
@@ -79,6 +80,7 @@ void testa_arvore_rb(const char *m)
             conjord_imprime_lista(test_n, ctest + 1, size_n);
             printf("\033[H");
             conjord_imprime_arvore_rb(cj_b, 1);
+            INFO("* insere/remove 20 elem. chave unica entre 1 a 99");
             CM;
         }
 
@@ -90,11 +92,13 @@ void testa_arvore_rb(const char *m)
             conjord_imprime_lista(test_n, 0, ctest + 1);
             printf("\033[H");
             conjord_imprime_arvore_rb(cj_b, 1);
+            INFO("* insere/remove 20 elem. chave unica entre 1 a 99");
             CM;
         }
         LTELA;
         CMR(sai);
     }
+    LTELA;
 }
 
 

commit 502d78db93582a2d9faf75c213ca8bbd27d6680f
Author: Joilnen <joilnen@gmail.com>
Date:   Wed Jan 12 04:43:35 2022 -0300

    atualizando documentacao

diff --git a/doc/tex/code/inc.c b/doc/tex/code/inc.c
index 96c00d1..31411fd 100644
--- a/doc/tex/code/inc.c
+++ b/doc/tex/code/inc.c
@@ -11,7 +11,7 @@ int rb_insert(rb_n **t, rb_n *z)
      * ser alterada nesta função e desejamos que estas alterações
      * persistam
      */
-    rb_n *y = &rb_s;
+    rb_n *y = &rb_s; 
     rb_n *x = *t;
 
     /**
diff --git a/doc/tex/red-black-tree.pdf b/doc/tex/red-black-tree.pdf
new file mode 100644
index 0000000..9966f82
Binary files /dev/null and b/doc/tex/red-black-tree.pdf differ
diff --git a/doc/tex/red-black-tree.tex b/doc/tex/red-black-tree.tex
new file mode 100644
index 0000000..cd8afac
--- /dev/null
+++ b/doc/tex/red-black-tree.tex
@@ -0,0 +1,61 @@
+% Red-black tree
+% Author: Madit
+\documentclass{article}
+\usepackage{tikz}
+%%%<
+\usepackage{verbatim}
+\usepackage[active,tightpage]{preview}
+\PreviewEnvironment{tikzpicture}
+\setlength{\PreviewBorder}{10pt}%
+%%%>
+\begin{comment}
+:Title: Red-black tree
+:Tags: Trees;Graphs
+:Author: Madit
+:Slug: red-black-tree
+
+A red-black tree is a special type of binary tree, used in computer science
+to organize pieces of comparable data, such as text fragments or numbers.
+(Wikipedia)
+\end{comment}
+\usetikzlibrary{arrows}
+
+\tikzset{
+  treenode/.style = {align=center, inner sep=0pt, text centered,
+    font=\sffamily},
+  arn_n/.style = {treenode, circle, white, font=\sffamily\bfseries, draw=black,
+    fill=black, text width=1.5em},% arbre rouge noir, noeud noir
+  arn_r/.style = {treenode, circle, red, draw=red, 
+    text width=1.5em, very thick},% arbre rouge noir, noeud rouge
+  arn_x/.style = {treenode, rectangle, draw=black,
+    minimum width=0.5em, minimum height=0.5em}% arbre rouge noir, nil
+}
+
+\begin{document}
+\begin{tikzpicture}[->,>=stealth',level/.style={sibling distance = 5cm/#1,
+  level distance = 1.5cm}] 
+\node [arn_n] {33}
+    child{ node [arn_r] {15} 
+            child{ node [arn_n] {10} 
+            	child{ node [arn_r] {5} edge from parent node[above left]
+                         {$x$}} %for a named pointer
+							child{ node [arn_x] {}}
+            }
+            child{ node [arn_n] {20}
+							child{ node [arn_r] {18}}
+							child{ node [arn_x] {}}
+            }                            
+    }
+    child{ node [arn_r] {47}
+            child{ node [arn_n] {38} 
+							child{ node [arn_r] {36}}
+							child{ node [arn_r] {39}}
+            }
+            child{ node [arn_n] {51}
+							child{ node [arn_r] {49}}
+							child{ node [arn_x] {}}
+            }
+		}
+; 
+\end{tikzpicture}
+\end{document}
diff --git a/doc/tex/relatorio.pdf b/doc/tex/relatorio.pdf
index fa90c6d..5053a33 100644
Binary files a/doc/tex/relatorio.pdf and b/doc/tex/relatorio.pdf differ
diff --git a/doc/tex/relatorio.tex b/doc/tex/relatorio.tex
index fe33786..e8d8ae5 100644
--- a/doc/tex/relatorio.tex
+++ b/doc/tex/relatorio.tex
@@ -36,11 +36,34 @@
     tabsize=2
 }
 
+% \tikzset{
+%   treenode/.style = {align=center, inner sep=0pt, text centered,
+%     font=\sffamily},
+%   arn_n/.style = {treenode, circle, white, font=\sffamily\bfseries, draw=black,
+%     fill=black, text width=1.5em},% arbre rouge noir, noeud noir
+%   arn_r/.style = {treenode, circle, red, draw=red, 
+%     text width=1.5em, very thick},% arbre rouge noir, noeud rouge
+%   arn_x/.style = {treenode, rectangle, draw=black,
+%     minimum width=0.5em, minimum height=0.5em}% arbre rouge noir, nil
+% }
+
+\tikzset{
+  treenode/.style = {align=center, inner sep=0pt, text centered,
+    font=\sffamily},
+  arn_n/.style = {treenode, circle, white, font=\sffamily\bfseries, draw=black,
+    fill=black, text width=1.5em},% arbre rouge noir, noeud noir
+  arn_r/.style = {treenode, circle, white, font=\sffamily\bfseries, draw=red, fill=red,
+    text width=1.5em},% arbre rouge noir, noeud rouge
+  arn_x/.style = {treenode, rectangle, draw=black, fill=black,
+    minimum width=0.5em, minimum height=0.5em}% arbre rouge noir, nil
+}
+
 \lstset{
     style=mystyle,
-    language=C,
-    inputencoding=utf8,
-    texcl=true
+    language=C
+%    inputencoding=utf8,
+%    texcl=true,
+%    escapeinside={(!}{!)}
 }
 
 % \renewcommand{\headrulewidth}{0pt} \renewcommand{\footrulewidth}{0pt} 
@@ -56,7 +79,7 @@
 % ]{DejaVu Sans}
 
 \title {
-    \Large{\textbf{RELATÓRIO SOBRE O CÓDIGO FONTE DESTE PROJETO, CONJUNTO ORDENADO}} \\
+    \Large{\textbf{RELATÓRIO SOBRE O CÓDIGO FONTE DO PROJETO, CONJUNTO ORDENADO}} \\
     \large{\textbf{projeto este que faz uso da estrutura de dados Red Black}} \\
     \large {UFES Centro Universitário Norte do Espírito Santo}
     \author{JOILNEN LEITE \\ \href{mailto:joilnen.leite@edu.ufes.br}
@@ -90,16 +113,250 @@ da atividade conjunto ordenado \\
 \indent \textbf{Palavras-chave: } fontes, C, Red Black, Conjunto\\
 \small
 \section {Introdução}
-\noindent Esta biblioteca é composta por quatro arquivos, \\
-\enf{conjunto\_ordenado.h}\\
-\enf{conjunto\_ordenado.c} \\
-\enf{red\_black.h} \\
-\enf{red\_black.c}\\
+\noindent Esta biblioteca é composta pelo os seguintes arquivos, \\
+\begin{itemize}
+    \item conjunto\_ordenado.h
+    \item conjunto\_ordenado.c
+    \item red\_black.h
+    \item red\_black.c
+    \item jcurses.h 
+\end{itemize}
+
+Completamente separado do código da biblioteca temos alguns arquivos que implementam 
+testes, estes são:
+\begin{itemize}
+    \item main.c
+    \item testa_item_1.c
+    \item testa_item_2.c
+    \item testa_item_3.c
+    \item testa_rb.c
+\end{itemize}
+
+Todos os arquivos estão listados nos anexos na sua íntegra.
+
+Como foi implementado um número grande de testes, estes foram separados em quatro
+arquivos,  \enf{testa_item_1.c, testa_item_2.c, testa_item_3.c, testa_rb.c}
+e tem suas funções chamadas sequencialmente dentro da função \enf{main}, no arquivo \enf{main.c}
+
+Seguiremos neste relatório uma abordagem \enf{top-down} onde partiremos das estruturas 
+e funções manipuladas pelo o código cliente em direção as estruturas e funções que implementam
+e operam na estrutura de dados, \enf{árvore red-black}, que é totalmente ocultada do cliente
+ou seja poderíamos reimplementar as funcionalidade com outras esturas de dados e manter 
+a interface compatível com a existente.
+
+O estilo do código fonte neste trabalho é o mais tradicional, chaves abrem e fecham do mesmo lado
+nas funções e instruções escritas em mais de uma linha,
+entre cada instrução e seus operandos há sempre espaços, com exceção das funções e seus parênteses, 
+os epaços dividem visialmente os tokens, como em arrays, em equações, símbolo 
+de ponteiro alinhado à variável, todos os comentários seguem ANSI C, /* */.
+
+Na leitura da documentação nos comentários vale a pena ressaltar que todos estam em ASCII,
+por isso não tem acentuação e a descrição dos parâmetros são antecedidas com \enf{@param}
+que é tag utilizada pelo o sistema que gera documentação apartir do código fonte,
+documentação esta constante nos anexos.
+
+\section {Primeiras Estruturas}
+\subsection {conjord}
+A primeira estrutura que veremos aqui é a \enf{conjord} ela representa um conjunto ordenando
+é o nosso envólucro sobre a estrutura da árvore, 
+
+\lstinputlisting [linerange={11-31}, firstnumber=11, caption = {Fragmento do conjunto_ordenado.h}]{../../src/conjunto_ordenado.h}
+
+Aqui temos a função que cria um conjunto ordenando, um tipo conjord
+
+\lstinputlisting [firstnumber=9, linerange={9-23}, caption = {Fragmento do conjunto_ordenado.c}]{../../src/conjunto_ordenado.c}
+
+Apesar do código ser bem simples, temos aqui detalhadamente, a criação do tipo cojord 
+, o ponteiro pr aponta para raiz da árvore, interna a este conjunto, como 
+o conjunto tá vazio ele aponta para o nó sentinela(rb_s - red black sentinela),
+idx é um indice para um array de raizes que é usado apenas pra controle e acesso
+rápido a todas as árvores criadas, nome é uma identificação opcional e cardinalidade
+zero por que o conjunto está vazio.
+
+Aqui o exemplo do seu uso  num caso de teste
+
+\lstinputlisting [firstnumber=54, linerange={54-56}, caption = {Fragmento do testa_item_1.c}]{../../src/testa_item_1.c}
+
+Sigamos para a função de teste a seguir \enf{adiciona_lista_de_elelementos} ela vai exemplificar
+como essa criação se dá até a árvore
+
+\lstinputlisting [firstnumber=9, linerange={9-42}, caption = {Fragmento do testa_item_1.c}]{../../src/testa_item_1.c}
+
+Nesse fragmento vemos o tipo definido pelo o usuário será o tipo  genério 
+onde apontaremos o ponteiro \enf{void *} pra ele, 
+apartir da linha 28, temos a criação de um tipo composto do tipo do cliente, aqui como 
+uma estrutura com dois ponteiros para char, sequencia finalizada como '\textbackslash0', que é como 
+representamos strings em C, são criados 20 elementos neste loop, com chave randômica
+de 1 a 99, a função \enf{conjord_insere_elemento} na linha 33, tendo como parâmetros
+o cojunto criado, a chave e o objeto do cliente, criará um novo elemento neste conjunto,
+esta função retorna código de erro, zero para elemento inserido, e não zero caso, 
+o elemento já exista na árvore, então neste \enf{if}, nos certificamos que apenas
+teremos elementos com chaves diferentes nos 20 elementos ou nesta árvore, analizaremos
+esta função a seguir,
+
+\lstinputlisting [firstnumber=39, linerange={39-65}, caption = {Fragmento do conjunto_ordenado.c}]{../../src/conjunto_ordenado.c}
+o \enf{if}, na linha 47, adiciona um elemento na árvore já existente, pois note que \enf{pr} diferente de \enf{rb_s}, o que significa que já existe árvore criada para este \enf{conjord},
+caso contrário é criada a raiz da arvore e apontado o \enf{pr} para ela, \enf{rb_cr},
+cria uma árvore nova retorna o nó raíz tendo uma chave e um tipo qualquer(\enf{void *}),
+cadinalidade é incrementado, e no caso da inserção em árvore pre-existente, 
+ele só é incrementado caso a função \enf{rb_insert}, retorne código de inserido, zero,
+temos como retorno dessa função de inserção no conjunto, zero para inserido, e -1,
+caso o contrário, é assim que nos certificamos de ter inserido um elemento realmente
+como no código de teste visto anterioremente, note que usamos ponteiro duplo na raíz,
+por que em algumas operações teremos que modificar esse ponteiro dentro de funções chamadas,
+como em rotações e deleções.
+
+\subsection {Estruturas da Red Black}
+A função \enf{conjord_insere_elemento} chama no seu interior  \enf{rb_insert}, que insere
+o dado genérico apontado por \enf{elemento} e sua \enf{chave}, na árvore apontada por \enf{pr}
+do conjord \enf{a}, o nó \enf{rb_n *n} é alocado, populado com chave e elemento e passado
+por referência para \enf{rb_insert} caso esta retorne zero a inserção foi executada corretamente,
+então incrementamos o contador de cardinalidade, caso contrário a função retorna código de erro -1.
+
+Analisaremos agora \enf{rb_cr} e \enf{rb_insert}, respectivamente as funções que cria uma árvore
+red black e insere um novo nó.
+\lstinputlisting [firstnumber=25, linerange={25-41}, caption = {Fragmento do red_black.c}]{../../src/red_black.c}
+A mesma ideia que vimos na função \enf{conjord_insere_elemento}, alocamos aqui um novo nó,
+populamos com chave e o dado genérico, também setamos a cor preta, pois é raíz, apontamos 
+ponteiros, pai, e filhos para nó sentinela \enf{rb_s}
+
+Antes de passarmos para o \enf{rb_insert}, vamos dar uma olha na estrutura nó \enf{rb_n}
+\lstinputlisting [firstnumber=33, linerange={33-50}, caption = {Fragmento do red_black.h}]{../../src/red_black.h}, a documentação de comentário é explicita.
+
+Então agora a função \enf{rb_insert} que insere um novo nó na árvore, detalharemos agora 
+o funcionanmento desta função
+\lstinputlisting [firstnumber=43, linerange={43-145}, caption = {Fragmento do red_black.c}]{../../src/red_black.c}
+
+A variável \enf{x} é uma variável que itera sobre os nós da árvore ela começa sendo igual 
+ao nó raiz, \enf{y} é uma variável que aponta para pai, pois a lógica dessa rotina é ir rastrando
+nó e seu pai, como a condição incial é o nó raiz, a \enf{x} aponta para raiz e a \enf{y} aponta
+para o nó sentinela, consideremos os casos possíveis, caso um,  o nó raiz não existe ou seja é 
+igual a sentinela e estamos incluíndo o primeiro nó que se tornará o raiz, neste caso 
+o primeiro \enf{while} não é executado pois a \enf{x} apontará para \enf{rb_s} (sentinela),
+como \enf{y} rastrea o pai, ela aponta também para sentinela, e fazemos o nó incluído apontar
+o ponteiro pai para o sentinela através \enf{z->p = y}, caso neste ponto a \enf{y} continua
+apontando para sentinela significa que temos apenas um nó sendo tradado, logo fazemos este nó
+raiz na linha \enf{*t = z}, posteriormente fazemos ponteiros pai e filhos apontarem para sentinela
+e colorimos de vermelho, neste ponto você pode perguntar, mas se ele é o raiz não deveria ser 
+preto, verdade, é que essa linha é feita com vistas aos casos mais comuns que são a inserção 
+de nós não raiz, que é tratado no \enf{while} seguinte, a cor será alterado para preto, no 
+final da função pelo o ponteiro \enf{t} na linha \enf{(*t)->c = BLACK}, ou seja ao final 
+da função ela sempre pinta o nó raíz de preto.
+
+Caso dois, neste o nó inserido não é o primeiro, o primeiro \enf{while} itera pelo nó raiz,
+através dos ponteiros para o(s) filho(s) a direita ou a esqueda de acordo com a comparação
+das chaves, dos nós visitados e do nó sendo incluído, note que neste ponto, é feito 
+a crítca se as chaves são iguais, como a especificação proíbe chaves iguais, ele retorna 
+código de erro após o \enf{else} ou finaliza quando a \enf{x} apontar para o sentinela
+que neste caso representa um nó folha, a \enf{y} apontará para o pai deste nó, estnó 
+fora é o ponto que será incluído o novo nó, na linha \enf{z->p = y}, enquando o primeiro 
+\enf{if} setou as variáveis \enf{x} e \enf{y}, o segundo \enf{if}, inclui o novo nó
+\enf{z} no lado esquerdo ou direito de \enf{y}, aponta os filhos desde nó para sentinela
+e colore com vermelho, que é a ação mais comum.
+
+Todas as inclusões entrão numa etapa, o segndo \enf{while}, que chamei de \enf{ajuste}
+na bibliografia é referiad como \enf{fixup}, esta parte do código raz o ajuste de coloração 
+e rotaciona nós para manter as propriedades da árvore red-black obedecidas.
+O primeiro \enf{if} dentro deste segundo \enf{while}.
+
+Aqui temos a parte mais importante da inclusão, se o nó pai do nó incluído \enf{z}
+é nó a esquerda, ou seja filho a esquerda do avô, fazemos \enf{y} apontar para o nó
+tio a direita. O diagrama abaixo representa esta 
+
+\begin{tikzpicture}[->,>=stealth',level/.style={sibling distance = 2.5cm/#1,
+  level distance = 1cm}] 
+\node [arn_n] {}
+    child{ node [arn_r] {} 
+            child{ node [arn_r] {z} 
+            	child{ node [arn_x] {}}
+				child{ node [arn_x] {}}
+            }
+            child{ node [arn_x] {}}                            
+    }
+    child{ node [arn_r] {}
+        child { node [arn_x] {} }
+        child { node [arn_x] {} }
+    }
+; 
+\end{tikzpicture}
+\colorbox{BurntOrange}{após o \enf{if} nas linhas, 100-106 }
+\begin{tikzpicture}[->,>=stealth',level/.style={sibling distance = 2.5cm/#1,
+  level distance = 1cm}] 
+\node [arn_n] {}
+    child{ node [arn_n] {} 
+            child{ node [arn_r] {z} 
+            	child{ node [arn_x] {}}
+				child{ node [arn_x] {}}
+            }
+            child{ node [arn_x] {}}                            
+    }
+    child{ node [arn_n] {}
+        child { node [arn_x] {} }
+        child { node [arn_x] {} }
+    }
+; 
+\end{tikzpicture}
+\\
+%
+%
+%
+\begin{tikzpicture}[->,>=stealth',level/.style={sibling distance = 2.5cm/#1,
+  level distance = 1cm}] 
+\node [arn_r] {}
+    child{ node [arn_n] {} 
+            child{ node [arn_r] {z} 
+            	child{ node [arn_x] {}}
+				child{ node [arn_x] {}}
+            }
+            child{ node [arn_x] {}}                            
+    }
+    child{ node [arn_n] {}
+        child { node [arn_x] {} }
+        child { node [arn_x] {} }
+    }
+; 
+\end{tikzpicture}
+\colorbox{BurntOrange}{após o \enf{else} nas linhas, 107-117 }
+\begin{tikzpicture}[->,>=stealth',level/.style={sibling distance = 2.5cm/#1,
+  level distance = 1cm}] 
+\node [arn_n] {}
+    child{ node [arn_n] {} 
+            child{ node [arn_r] {z} 
+            	child{ node [arn_x] {}}
+				child{ node [arn_x] {}}
+            }
+            child{ node [arn_x] {}}                            
+    }
+    child{ node [arn_n] {}
+        child { node [arn_x] {} }
+        child { node [arn_x] {} }
+    }
+; 
+\end{tikzpicture}
+\\
+\\
+\\
+\\
+\\
+\\
+%%
+%%
+%%  daqui pra frente eh antigo 
+%%
+%%
+\enf{conjunto_ordenado.h} é o arquivo cabeçalho que deverá ser incluído no código 
+fonte do cliente, \enf{conjunto_ordenado.c} onde estão implementados as funções,
+\enf{red_black.h} e \enf{red_black.c}, cabeçalho e implementações da estrutura
+de dados, árvore red-black e \enf{jcurses.h} um arquivo com macros auxiliares 
+de impressao e formatação de saida na tela.
+
 sendo necessário apenas para seu uso a inclusão via, \\
+O TAD \enf{conjord} é a abstração mais alta, representando conjunto, a qual o código 
+cliente tem acesso e suas respectivas funções.
 \enf{\#include "conjunto\_ordenado.h"} onde se encontra declarado, sendo definido em \\
 \enf{"conjunto\_ordenado.c"}, o TAD \footnote{Tipo Abstrato de Dados} 
 \enf{conjord} que oculta do código cliente e manipula internamente a estrutura de dados
-red black \enf{"struct rb\_n *"} aqui neste trabalho, declarada em \enf{red\_black.h} e definida em 
+red black \enf{"struct rb\_n"} aqui neste trabalho, declarada em \enf{red\_black.h} e definida em 
 \enf{red\_black.c} 
 
 Além da convencional inclusão e compilação, o usuário da biblioteca, pessoa
@@ -109,7 +366,7 @@ que escreve o programa cliente, aqui neste trabalho exemplificado pelo os arquiv
 deverá escolher definir seu tipo dado, através de uma struct ou utilizar um tipo de dado nativo da 
 linguagem.
 \renewcommand{\lstlistingname}{Fonte}
-\begin{lstlisting}[language=c, caption={Exemplo do uso da biblioteca conjunto_ordenado}]
+\begin{lstlisting}[caption={Exemplo do uso da biblioteca conjunto_ordenado}]
 #include "conjunto_ordenado.h"
 
 int main()
@@ -147,7 +404,7 @@ com \enf{insere_elemento}
 \ \\
 
 \noindent Estrutura principal
-\begin{lstlisting}[language=c, caption={Nó Red Black}]
+\begin{lstlisting}[caption={Nó Red Black}]
 /**
  * composicao do noh da RB
  * @rb_n noh red black
@@ -209,9 +466,10 @@ int seta_imprime_elemento(void (*i)(rb_n *n));
 
 \end{lstlisting}
 
-\lstinputlisting [language=c] {code/inc.c}
-\lstinputlisting [language=c] {code/del.c}
-\lstinputlisting [language=c] {code/utils.c}
+\lstinputlisting [linerange={10-15}, firstnumber=10]{../../src/testa_item_1.c}
+Variavel rb\_n com nome y \ref{14}
+% \lstinputlisting {code/del.c}
+% \lstinputlisting {code/utils.c}
 
 \section {TAD}
 \begin{figure}[H]
diff --git a/src/checklist.c b/src/checklist.c
index 189eb62..399bf26 100644
--- a/src/checklist.c
+++ b/src/checklist.c
@@ -3,6 +3,9 @@
 #include "conjunto_ordenado.h"
 #include "checklist.h"
 
+/** mostra itens da avaliacao 
+ * @param i especifica que itens estao selecionados 
+ */
 void tela_checklist(int i)
 {
     int l = 5, c = 24, bo = 1UL;
diff --git a/src/checklist.h b/src/checklist.h
index 730b616..aaf3a24 100644
--- a/src/checklist.h
+++ b/src/checklist.h
@@ -5,8 +5,12 @@
  * aluno: joilnen leite
  */
 
+/** mostra itens da avaliacao 
+ * @param i especifica que itens estao selecionados 
+ */
 void tela_checklist(int i);
 
+/** itens da avalicao mostrados na tela */
 #define ITEM1_1 "1.1 listar ordenado por chave"
 #define ITEM1_2 "1.2 cardinalidade do conjunto"
 #define ITEM1_3 "1.3 verificar se conj. vazio"
@@ -22,6 +26,7 @@ void tela_checklist(int i);
 
 #define ITEM4 "4 imprimir arvore rubro negra"
 
+/** usado na operacao de bits na mostra de itens da avalicao */
 enum {I1_1, I1_2, I1_3, I1_4, I2_1, I2_2, I2_3, \
       I3_1, I3_2, I3_3, I4};
 
diff --git a/src/conjunto_ordenado.c b/src/conjunto_ordenado.c
index ef4d273..79e54c4 100644
--- a/src/conjunto_ordenado.c
+++ b/src/conjunto_ordenado.c
@@ -8,6 +8,8 @@ static unsigned int r_counter = 0;
 
 /**
  * cria conjunto ordenado e retorna o ponteiro para ele
+ * @param nome string que nomeia conjunto, caso sem nome,
+ * NULL
  */
 conjord *conjord_cria(char *nome)
 {
@@ -36,6 +38,9 @@ void conjord_destroi(conjord *c)
 
 /**
  * insere elemento no conjunto ordenado
+ * @param a conjunto ordenando
+ * @param chave
+ * @param ponteiro para tipo do cliente
  */
 int conjord_insere_elemento(conjord *a, int chave, void *elemento)
 {
diff --git a/src/conjunto_ordenado.h b/src/conjunto_ordenado.h
index 3917c96..52406e9 100644
--- a/src/conjunto_ordenado.h
+++ b/src/conjunto_ordenado.h
@@ -9,15 +9,21 @@
 #include "red_black.h"
 
 /**
- * estrutura da TAD explicitamente
+ * estrutura do tipo abstrado de dados
  * esta estrutura oculta o uso da red black
  * suas funcoes e funcionamento interno do cliente
  * expondo apenas funcoes e operacoes com semantica
- * relativa ao uso do cliente aqui nesta avaliacao
- * conjunto ordenado as operacoes e funcoes
- * exigidas no documento da avaliacao para este TAD
- */
-typedef struct conjord {
+ * relativa ao uso do cliente 
+ * @param pr ponteiro para para raiz da arvore embarcada
+ * @param idx indice para um array de ponteiros para as raizes,
+ * eh utilizado internamente para se ter acessor rapido a todas
+ * as raizes criadas
+ * (controle do numero de conjuntos)
+ * @param nome opcional para o conjunto
+ * @param cardinalidade do conjunto 
+ */
+typedef struct conjord
+{
     rb_n *pr;
     unsigned int idx;
     char *nome;
@@ -26,6 +32,8 @@ typedef struct conjord {
 
 /**
  * cria conjunto ordenado e retorna o ponteiro para ele
+ * @param nome string que nomeia conjunto, caso sem nome,
+ * NULL
  */
 conjord *conjord_cria(char *nome);
 
diff --git a/src/red_black.c b/src/red_black.c
index 8aee293..8386a31 100644
--- a/src/red_black.c
+++ b/src/red_black.c
@@ -41,7 +41,9 @@ rb_n* rb_cr(int key, void *dado)
 }
 
 /**
- * inclusao baseado no livro do cormen
+ * inclusao de um novo noh na arvore rb 
+ * @param t eh a noh raiz
+ * @param z eh o noh a ser incluido
  */
 int rb_insert(rb_n **t, rb_n *z)
 {
diff --git a/src/red_black.h b/src/red_black.h
index a4a3331..11f2828 100644
--- a/src/red_black.h
+++ b/src/red_black.h
@@ -36,7 +36,6 @@ typedef enum tipo_screen {TMONO, TCOLOR} tipo_screen;
  * @param k chave (k de key)
  * @param c cor (c de color ou cor, 0-black, 1-red)
  * @param d dado (d de data ou dados)
- * @param np numero de nohs pretos ateh a folha 
  * @param l left, ponteiro para filho a esquerda
  * @param r right, ponteiro para filho a direta
  * @param p parent, ponteiro para noh pai
@@ -45,7 +44,6 @@ typedef struct rb_n {
     int k;
     unsigned char c:1;
     void *d;
-    unsigned int np;
     struct rb_n *l, *r, *p;
 } rb_n;
 
diff --git a/src/testa_item_1.c b/src/testa_item_1.c
index ac7e322..ba28c67 100644
--- a/src/testa_item_1.c
+++ b/src/testa_item_1.c
@@ -6,6 +6,11 @@
 
 static void imprime_meu_tipo(void *);
 
+/**
+ * tipo definido pelo usuario
+ * @param nome string em c
+ * @param telefone string  em c
+ */
 typedef struct {
     char *nome;
     char *telefone;
@@ -17,10 +22,6 @@ static void adiciona_lista_de_elementos(conjord *c)
     srand(time(NULL));
     for (i = 0; i < 20;)
     {
-        /**
-         * definicao de um tipo exemplo pelo o usuario
-         */
-
         /**
          * criacao do dado para o tipo do usuario
          */
diff --git a/src/testa_item_3.c b/src/testa_item_3.c
index ba9966d..4eab32f 100644
--- a/src/testa_item_3.c
+++ b/src/testa_item_3.c
@@ -63,7 +63,7 @@ void testa_item_3(const char *m)
     conjord *cj_b = conjord_cria("B");
     int imp, pos0 = 0, pos1 = 1, pos2 = 2;
     char elem0[] = "ABCDEF";
-    char elem1[] = "GHIJKL";
+    char elem1[] = "DEFGHI";
 
     LTELA;
     adiciona_venn(cj_a, pos1, elem0);

commit d7fe00babe1044669953bb1bc15c63e7f90ffe77
Author: Joilnen <joilnen@gmail.com>
Date:   Wed Jan 12 04:45:45 2022 -0300

    deleta arquivos n utilizado

diff --git a/doc/tex/red-black-tree.pdf b/doc/tex/red-black-tree.pdf
deleted file mode 100644
index 9966f82..0000000
Binary files a/doc/tex/red-black-tree.pdf and /dev/null differ
diff --git a/doc/tex/red-black-tree.tex b/doc/tex/red-black-tree.tex
deleted file mode 100644
index cd8afac..0000000
--- a/doc/tex/red-black-tree.tex
+++ /dev/null
@@ -1,61 +0,0 @@
-% Red-black tree
-% Author: Madit
-\documentclass{article}
-\usepackage{tikz}
-%%%<
-\usepackage{verbatim}
-\usepackage[active,tightpage]{preview}
-\PreviewEnvironment{tikzpicture}
-\setlength{\PreviewBorder}{10pt}%
-%%%>
-\begin{comment}
-:Title: Red-black tree
-:Tags: Trees;Graphs
-:Author: Madit
-:Slug: red-black-tree
-
-A red-black tree is a special type of binary tree, used in computer science
-to organize pieces of comparable data, such as text fragments or numbers.
-(Wikipedia)
-\end{comment}
-\usetikzlibrary{arrows}
-
-\tikzset{
-  treenode/.style = {align=center, inner sep=0pt, text centered,
-    font=\sffamily},
-  arn_n/.style = {treenode, circle, white, font=\sffamily\bfseries, draw=black,
-    fill=black, text width=1.5em},% arbre rouge noir, noeud noir
-  arn_r/.style = {treenode, circle, red, draw=red, 
-    text width=1.5em, very thick},% arbre rouge noir, noeud rouge
-  arn_x/.style = {treenode, rectangle, draw=black,
-    minimum width=0.5em, minimum height=0.5em}% arbre rouge noir, nil
-}
-
-\begin{document}
-\begin{tikzpicture}[->,>=stealth',level/.style={sibling distance = 5cm/#1,
-  level distance = 1.5cm}] 
-\node [arn_n] {33}
-    child{ node [arn_r] {15} 
-            child{ node [arn_n] {10} 
-            	child{ node [arn_r] {5} edge from parent node[above left]
-                         {$x$}} %for a named pointer
-							child{ node [arn_x] {}}
-            }
-            child{ node [arn_n] {20}
-							child{ node [arn_r] {18}}
-							child{ node [arn_x] {}}
-            }                            
-    }
-    child{ node [arn_r] {47}
-            child{ node [arn_n] {38} 
-							child{ node [arn_r] {36}}
-							child{ node [arn_r] {39}}
-            }
-            child{ node [arn_n] {51}
-							child{ node [arn_r] {49}}
-							child{ node [arn_x] {}}
-            }
-		}
-; 
-\end{tikzpicture}
-\end{document}

commit 9bc43552baa8951043b0c272fb2edae2403d8d50
Author: Joilnen <joilnen@gmail.com>
Date:   Wed Jan 12 15:19:59 2022 -0300

    atualizando documentacao

diff --git a/doc/tex/relatorio.pdf b/doc/tex/relatorio.pdf
index 5053a33..f744110 100644
Binary files a/doc/tex/relatorio.pdf and b/doc/tex/relatorio.pdf differ
diff --git a/doc/tex/relatorio.tex b/doc/tex/relatorio.tex
index e8d8ae5..cccf14a 100644
--- a/doc/tex/relatorio.tex
+++ b/doc/tex/relatorio.tex
@@ -49,13 +49,13 @@
 
 \tikzset{
   treenode/.style = {align=center, inner sep=0pt, text centered,
-    font=\sffamily},
-  arn_n/.style = {treenode, circle, white, font=\sffamily\bfseries, draw=black,
-    fill=black, text width=1.5em},% arbre rouge noir, noeud noir
-  arn_r/.style = {treenode, circle, white, font=\sffamily\bfseries, draw=red, fill=red,
-    text width=1.5em},% arbre rouge noir, noeud rouge
+    font=\tiny},
+  arn_n/.style = {treenode, circle, white, draw=black,
+    text centered, fill=black, minimum size=3mm},% arbre rouge noir, noeud noir
+  arn_r/.style = {treenode, circle, white, draw=red, fill=red,
+    text centered, minimum size=3mm},% arbre rouge noir, noeud rouge
   arn_x/.style = {treenode, rectangle, draw=black, fill=black,
-    minimum width=0.5em, minimum height=0.5em}% arbre rouge noir, nil
+    minimum width=0.25em, minimum height=0.25em}% arbre rouge noir, nil
 }
 
 \lstset{
@@ -195,7 +195,8 @@ teremos elementos com chaves diferentes nos 20 elementos ou nesta árvore, anali
 esta função a seguir,
 
 \lstinputlisting [firstnumber=39, linerange={39-65}, caption = {Fragmento do conjunto_ordenado.c}]{../../src/conjunto_ordenado.c}
-o \enf{if}, na linha 47, adiciona um elemento na árvore já existente, pois note que \enf{pr} diferente de \enf{rb_s}, o que significa que já existe árvore criada para este \enf{conjord},
+o \enf{if}, na linha 47, adiciona um elemento na árvore já existente, pois note que \enf{pr}
+diferente de \enf{rb_s}, o que significa que já existe árvore criada para este \enf{conjord},
 caso contrário é criada a raiz da arvore e apontado o \enf{pr} para ela, \enf{rb_cr},
 cria uma árvore nova retorna o nó raíz tendo uma chave e um tipo qualquer(\enf{void *}),
 cadinalidade é incrementado, e no caso da inserção em árvore pre-existente, 
@@ -227,7 +228,108 @@ Então agora a função \enf{rb_insert} que insere um novo nó na árvore, detal
 o funcionanmento desta função
 \lstinputlisting [firstnumber=43, linerange={43-145}, caption = {Fragmento do red_black.c}]{../../src/red_black.c}
 
-A variável \enf{x} é uma variável que itera sobre os nós da árvore ela começa sendo igual 
+Tendo apenas um único nó esta rotina apenas atualiza o ponteiro raiz para este nó,
+na linha 76, faz o nó incluído apontar seu ponteiro pai para o sentinela, através de \enf{y}
+(inicializado com sentinela em 55) e atualiza o nó raiz em 86 colorindo em seguida com preto em 142.
+
+A primeira parte desta rotina, que inclui o primeiro \enf{while} até o
+primeiro \enf{if}, apenas faz a inclusão do novo nó da mesma forma que na árvore binária de 
+busca comum, o while itera até a folha comparando as chaves, neste caso aqui, foi 
+modificado para aceitar apenas chaves diferentes, retornando código de erro caso contrário,
+e uma vêz que temos a \enf{y} apontando para este nó folha, anexamos \enf{z} a este nó
+fazendo o apontamento do ponteiro filho neste nó folha pra \enf{z}, a única grande 
+diferença é que no final desta parte colorimos com vermelho, o novo nó incluído.
+
+Todas as inclusões entram numa etapa, o segndo \enf{while}, que chamei de \enf{ajuste}
+na bibliografia é referida como \enf{fixup}, esta parte do código raz o ajuste de coloração 
+e rotaciona nós para manter as propriedades da árvore red-black obedecidas.
+
+Vejamos como esta parte da rotina trata os três casos em que podem ser quebradas
+as propriedades da árvore na inclusão e como esta parte do código resolve as inconcistências.
+
+Considerando a priori apenas as inclusões que ocorrerão a esquerda, nós anexados ao ponteiro
+que aponta para o filho esquerdo.
+
+O primeiro caso é tratado no segnodo \enf{if} do segundo \enf{while}, o primeiro \enf{if}
+decide se está sendo incluído pelo o lado esquerdo e da linha 99-106, temos o tratamento 
+do \enf{caso 1}, nó pai vermerlho, e nó tio vermelho, segue um diagrama deste caso em
+nome da clereza.
+
+\begin{tikzpicture}[->,>=stealth',level/.style={sibling distance = 2.5cm/#1,
+  level distance = .5cm}] 
+\node [arn_n] {}
+    child{ node [arn_r] {}
+        child{ node [arn_n] {} 
+            child { node [arn_x] {} }
+            child { node [arn_x] {} }
+        }
+        child{ node [arn_n] {} 
+            child{ node [arn_r] {} 
+                child{ node [arn_r] {z} 
+                    child { node [arn_x] {} }
+                    child { node [arn_x] {} }
+                }
+                child { node [arn_x] {} }
+            }
+            child{ node [arn_r] {y} 
+                child { node [arn_x] {} }
+                child { node [arn_x] {} }
+            }
+        }
+    }
+    child{ node [arn_n] {}
+        child { node [arn_x] {} }
+        child{ node [arn_r] {}
+            child { node [arn_x] {} }
+            child { node [arn_x] {} }
+        }
+    }
+; 
+\end{tikzpicture}
+\colorbox{BurntOrange}{\scriptsize após o \enf{if} nas linhas, 99-106 }
+\begin{tikzpicture}[->,>=stealth',level/.style={sibling distance = 2.5cm/#1,
+  level distance = .5cm}] 
+\node [arn_n] {}
+    child{ node [arn_r] {}
+        child{ node [arn_n] {} 
+            child { node [arn_x] {} }
+            child { node [arn_x] {} }
+        }
+        child{ node [arn_r] {z} 
+            child{ node [arn_n] {} 
+                child{ node [arn_r] {} 
+                    child { node [arn_x] {} }
+                    child { node [arn_x] {} }
+                }
+                child { node [arn_x] {} }
+            }
+            child{ node [arn_n] {} 
+                child { node [arn_x] {} }
+                child { node [arn_x] {} }
+            }
+        }
+    }
+    child{ node [arn_n] {y}
+        child { node [arn_x] {} }
+        child{ node [arn_r] {}
+            child { node [arn_x] {} }
+            child { node [arn_x] {} }
+        }
+    }
+; 
+\end{tikzpicture} \\
+Note que saímos do \enf{caso 1} e caímos no \enf{caso 2}, nó pai do nó agora 
+apontado por \enf{z}, vermelho e nó tio preto \enf{y}, lembre-se que estamos dentro de um
+\enf{while} em loop enquanto a cor do pai de \enf{z} for vermelha, este segundo caso
+é tratado no \enf{if} 109-113, onde há uma rotação a esquerda, vamos aproveitar para
+analizarmos o que faz esta função.
+\lstinputlisting [firstnumber=319, linerange={319-342}, caption = {Fragmento do red_black.c}]{../../src/red_black.c}
+Esta função \enf{rb_rot_esq}, basicamente diminui a altura do lado direito e aumenta
+do lado esquerdo reagrupando os nós, vejamos detalhadamente como.
+Aqui temos a parte mais importante da inclusão, se o nó pai do nó incluído \enf{z}
+é nó a esquerda, ou seja filho a esquerda do avô, fazemos \enf{y} apontar para o nó
+tio a direita. O diagrama abaixo representa esta 
+Detalhando, variável \enf{x} é uma variável que itera sobre os nós da árvore ela começa sendo igual 
 ao nó raiz, \enf{y} é uma variável que aponta para pai, pois a lógica dessa rotina é ir rastrando
 nó e seu pai, como a condição incial é o nó raiz, a \enf{x} aponta para raiz e a \enf{y} aponta
 para o nó sentinela, consideremos os casos possíveis, caso um,  o nó raiz não existe ou seja é 
@@ -254,7 +356,7 @@ fora é o ponto que será incluído o novo nó, na linha \enf{z->p = y}, enquand
 \enf{z} no lado esquerdo ou direito de \enf{y}, aponta os filhos desde nó para sentinela
 e colore com vermelho, que é a ação mais comum.
 
-Todas as inclusões entrão numa etapa, o segndo \enf{while}, que chamei de \enf{ajuste}
+Todas as inclusões entram numa etapa, o segndo \enf{while}, que chamei de \enf{ajuste}
 na bibliografia é referiad como \enf{fixup}, esta parte do código raz o ajuste de coloração 
 e rotaciona nós para manter as propriedades da árvore red-black obedecidas.
 O primeiro \enf{if} dentro deste segundo \enf{while}.
@@ -263,40 +365,6 @@ Aqui temos a parte mais importante da inclusão, se o nó pai do nó incluído \
 é nó a esquerda, ou seja filho a esquerda do avô, fazemos \enf{y} apontar para o nó
 tio a direita. O diagrama abaixo representa esta 
 
-\begin{tikzpicture}[->,>=stealth',level/.style={sibling distance = 2.5cm/#1,
-  level distance = 1cm}] 
-\node [arn_n] {}
-    child{ node [arn_r] {} 
-            child{ node [arn_r] {z} 
-            	child{ node [arn_x] {}}
-				child{ node [arn_x] {}}
-            }
-            child{ node [arn_x] {}}                            
-    }
-    child{ node [arn_r] {}
-        child { node [arn_x] {} }
-        child { node [arn_x] {} }
-    }
-; 
-\end{tikzpicture}
-\colorbox{BurntOrange}{após o \enf{if} nas linhas, 100-106 }
-\begin{tikzpicture}[->,>=stealth',level/.style={sibling distance = 2.5cm/#1,
-  level distance = 1cm}] 
-\node [arn_n] {}
-    child{ node [arn_n] {} 
-            child{ node [arn_r] {z} 
-            	child{ node [arn_x] {}}
-				child{ node [arn_x] {}}
-            }
-            child{ node [arn_x] {}}                            
-    }
-    child{ node [arn_n] {}
-        child { node [arn_x] {} }
-        child { node [arn_x] {} }
-    }
-; 
-\end{tikzpicture}
-\\
 %
 %
 %
diff --git a/src/red_black.c b/src/red_black.c
index 8386a31..981d8a0 100644
--- a/src/red_black.c
+++ b/src/red_black.c
@@ -316,6 +316,12 @@ int rb_destroi(rb_n **a)
     return 0;
 }
 
+/**
+ * rotaciona a esquerda trocando as referências
+ * entre nós
+ * @param t nó raiz (ou da subarvore)
+ * @param x nó que serah rotacionado
+ */
 int rb_rot_esq(rb_n **t, rb_n *x)
 {
     rb_n *y = x->r;

commit 2cabd6ac2adad32d7174b1f3fb69fafc456ead66
Author: Joilnen <joilnen@gmail.com>
Date:   Thu Jan 13 06:15:49 2022 -0300

    documentacao

diff --git a/doc/tex/relatorio.pdf b/doc/tex/relatorio.pdf
index f744110..fbede5f 100644
Binary files a/doc/tex/relatorio.pdf and b/doc/tex/relatorio.pdf differ
diff --git a/doc/tex/relatorio.tex b/doc/tex/relatorio.tex
index cccf14a..ab2d3b6 100644
--- a/doc/tex/relatorio.tex
+++ b/doc/tex/relatorio.tex
@@ -9,6 +9,9 @@
 % \fancyfoot{}
 \usepackage{listingsutf8}
 \usepackage{xcolor}
+\usepackage{lmodern}
+\usepackage[T1]{fontenc}
+\usepackage{aesupp}
 
 % \definecolor{codegreen}{rgb}{0,0.6,0}
 \definecolor{codegreen}{rgb}{.6,.3,0}
@@ -16,6 +19,8 @@
 \definecolor{codepurple}{rgb}{0.58,0,0.82}
 \definecolor{backcolour}{rgb}{0.95,0.95,0.92}
 
+\DeclareEmphSequence{\bfseries, \mdseries}
+
 \lstdefinestyle{mystyle}{
     backgroundcolor=\color{backcolour},   
     commentstyle=\color{codegreen},
@@ -175,7 +180,7 @@ zero por que o conjunto está vazio.
 
 Aqui o exemplo do seu uso  num caso de teste
 
-\lstinputlisting [firstnumber=54, linerange={54-56}, caption = {Fragmento do testa_item_1.c}]{../../src/testa_item_1.c}
+\lstinputlisting [firstnumber=55, linerange={55-56}, caption = {Fragmento do testa_item_1.c}]{../../src/testa_item_1.c}
 
 Sigamos para a função de teste a seguir \enf{adiciona_lista_de_elelementos} ela vai exemplificar
 como essa criação se dá até a árvore
@@ -250,7 +255,7 @@ as propriedades da árvore na inclusão e como esta parte do código resolve as
 Considerando a priori apenas as inclusões que ocorrerão a esquerda, nós anexados ao ponteiro
 que aponta para o filho esquerdo.
 
-O primeiro caso é tratado no segnodo \enf{if} do segundo \enf{while}, o primeiro \enf{if}
+O primeiro caso é tratado no segundo \enf{if} do segundo \enf{while}, o primeiro \enf{if}
 decide se está sendo incluído pelo o lado esquerdo e da linha 99-106, temos o tratamento 
 do \enf{caso 1}, nó pai vermerlho, e nó tio vermelho, segue um diagrama deste caso em
 nome da clereza.
@@ -325,7 +330,86 @@ apontado por \enf{z}, vermelho e nó tio preto \enf{y}, lembre-se que estamos de
 analizarmos o que faz esta função.
 \lstinputlisting [firstnumber=319, linerange={319-342}, caption = {Fragmento do red_black.c}]{../../src/red_black.c}
 Esta função \enf{rb_rot_esq}, basicamente diminui a altura do lado direito e aumenta
-do lado esquerdo reagrupando os nós, vejamos detalhadamente como.
+do lado esquerdo reagrupando os nós, vejamos detalhadamente como.\\
+\begin{table}[!ht]
+    \scriptsize
+\begin{tabular}{|l|l|}
+    \hline 
+    327 & guarda referência do filho a direita \\
+    \hline 
+    328 & faz filho a direita igual a neto a esquerda (dimininuíndo a altura direita) \\
+    \hline 
+    329 & se filho a direita (antigo neto a esquerda) não é sentinela \\
+    \hline 
+    330 & atualiza pai de filho a direita (antigo neto a esquerda)\\
+    \hline 
+    331 & atualiza pai do nó movido\\
+    \hline 
+    332 & testa se nó anterior era raiz \\
+    \hline 
+    333 & atualiza nó raiz \\
+    \hline 
+    334 & se não é raiz testa se é nó a esquerda\\
+    \hline 
+    335 & atualiza como nó a esquerda\\
+    \hline 
+    336 & se nenhuma das opções anteriores\\
+    \hline 
+    337 & atualiza como nó a direita\\
+    \hline 
+    338 & atualiza filho a esquerda de y igual x, note que o nó x que era pai passa a ser filho\\
+    \hline 
+    339 & atualiza pai de x igual de y \\
+    \hline 
+    341 & retorna inteiro para uso em testes (não utilizado neste trabalho, mas a função tem esta inferface)\\
+    \hline
+\end{tabular}
+\end{table}
+
+Um diagrama em nome da clareza \\
+\begin{tikzpicture}[->,>=stealth',level/.style={sibling distance = 2.5cm/#1,
+  level distance = .5cm}] 
+\node [arn_n] {x}
+    child{ node [arn_r] {1}
+        child { node [arn_x] {} }
+        child { node [arn_x] {} }
+    }
+    child{ node [arn_n] {y}
+        child{ node [arn_r] {5}
+            child { node [arn_x] {} }
+            child { node [arn_x] {} }
+        }
+        child{ node [arn_r] {8}
+            child { node [arn_x] {} }
+            child { node [arn_x] {} }
+        }
+    }
+; 
+\end{tikzpicture} 
+\colorbox{BurntOrange}{\scriptsize após \enf{rb_rot_esq} }
+\begin{tikzpicture}[->,>=stealth',level/.style={sibling distance = 2.5cm/#1,
+  level distance = .5cm}] 
+\node [arn_n] {y}
+    child{ node [arn_n] {x}
+        child{ node [arn_r] {1}
+            child { node [arn_x] {} }
+            child { node [arn_x] {} }
+        }
+        child{ node [arn_r] {5}
+            child { node [arn_x] {} }
+            child { node [arn_x] {} }
+        }
+    }
+    child{ node [arn_r] {8}
+        child { node [arn_x] {} }
+        child { node [arn_x] {} }
+    }
+; 
+\end{tikzpicture} \\
+\\
+\\
+\\
+\\
 Aqui temos a parte mais importante da inclusão, se o nó pai do nó incluído \enf{z}
 é nó a esquerda, ou seja filho a esquerda do avô, fazemos \enf{y} apontar para o nó
 tio a direita. O diagrama abaixo representa esta 

commit d0bac1f2bb0af97adbfff86a1dc98de537db953e
Author: Joilnen <joilnen@gmail.com>
Date:   Thu Jan 13 06:22:40 2022 -0300

    documentacao

diff --git a/doc/tex/relatorio.pdf b/doc/tex/relatorio.pdf
index fbede5f..1b84da1 100644
Binary files a/doc/tex/relatorio.pdf and b/doc/tex/relatorio.pdf differ
diff --git a/doc/tex/relatorio.tex b/doc/tex/relatorio.tex
index ab2d3b6..c1002df 100644
--- a/doc/tex/relatorio.tex
+++ b/doc/tex/relatorio.tex
@@ -370,7 +370,7 @@ Um diagrama em nome da clareza \\
 \begin{tikzpicture}[->,>=stealth',level/.style={sibling distance = 2.5cm/#1,
   level distance = .5cm}] 
 \node [arn_n] {x}
-    child{ node [arn_r] {1}
+    child{ node [arn_n] {1}
         child { node [arn_x] {} }
         child { node [arn_x] {} }
     }
@@ -400,7 +400,7 @@ Um diagrama em nome da clareza \\
             child { node [arn_x] {} }
         }
     }
-    child{ node [arn_r] {8}
+    child{ node [arn_n] {8}
         child { node [arn_x] {} }
         child { node [arn_x] {} }
     }

commit ee355fee21e11c6de623bcb7a546e8e21f69c944
Author: Joilnen <joilnen@gmail.com>
Date:   Thu Jan 13 06:50:00 2022 -0300

    documentacao

diff --git a/doc/tex/relatorio.pdf b/doc/tex/relatorio.pdf
index 1b84da1..9326675 100644
Binary files a/doc/tex/relatorio.pdf and b/doc/tex/relatorio.pdf differ
diff --git a/doc/tex/relatorio.tex b/doc/tex/relatorio.tex
index c1002df..6aeee3f 100644
--- a/doc/tex/relatorio.tex
+++ b/doc/tex/relatorio.tex
@@ -227,7 +227,7 @@ populamos com chave e o dado genérico, também setamos a cor preta, pois é ra
 ponteiros, pai, e filhos para nó sentinela \enf{rb_s}
 
 Antes de passarmos para o \enf{rb_insert}, vamos dar uma olha na estrutura nó \enf{rb_n}
-\lstinputlisting [firstnumber=33, linerange={33-50}, caption = {Fragmento do red_black.h}]{../../src/red_black.h}, a documentação de comentário é explicita.
+\lstinputlisting [firstnumber=33, linerange={33-48}, caption = {Fragmento do red_black.h}]{../../src/red_black.h}, a documentação de comentário é explicita.
 
 Então agora a função \enf{rb_insert} que insere um novo nó na árvore, detalharemos agora 
 o funcionanmento desta função
@@ -366,7 +366,7 @@ do lado esquerdo reagrupando os nós, vejamos detalhadamente como.\\
 \end{tabular}
 \end{table}
 
-Um diagrama em nome da clareza \\
+\noindent Um diagrama em nome da clareza \\
 \begin{tikzpicture}[->,>=stealth',level/.style={sibling distance = 2.5cm/#1,
   level distance = .5cm}] 
 \node [arn_n] {x}

commit 0f7051f5cb4ecd4c43fc83cd710fb71644cadbe1
Author: Joilnen <joilnen@gmail.com>
Date:   Thu Jan 13 17:53:26 2022 -0300

    formatando melhor saida no caso de teste 3

diff --git a/src/testa_item_3.c b/src/testa_item_3.c
index 4eab32f..088ba21 100644
--- a/src/testa_item_3.c
+++ b/src/testa_item_3.c
@@ -68,28 +68,37 @@ void testa_item_3(const char *m)
     LTELA;
     adiciona_venn(cj_a, pos1, elem0);
     adiciona_venn(cj_b, pos2, elem1);
+    printf("\033[8;30H");
     conjord_imprime_venn(cj_a);
     printf("\n");
+    printf("\033[9;30H");
     conjord_imprime_venn(cj_b);
     printf("\n");
+    printf("\033[10;30H");
     conjord_imprime_venn(conjord_une(cj_a, cj_b));
     INFO("* item 3.1 uniao de conjuntos");
     CM;
 
     LTELA;
+    printf("\033[8;30H");
     conjord_imprime_venn(cj_a);
     printf("\n");
+    printf("\033[9;30H");
     conjord_imprime_venn(cj_b);
     printf("\n");
+    printf("\033[10;30H");
     conjord_imprime_venn(conjord_subtrai(cj_a, cj_b));
     INFO("* item 3.1 subtracao de conjuntos");
     CM;
 
     LTELA;
+    printf("\033[8;30H");
     conjord_imprime_venn(cj_a);
     printf("\n");
+    printf("\033[9;30H");
     conjord_imprime_venn(cj_b);
     printf("\n");
+    printf("\033[10;30H");
     conjord_imprime_venn(conjord_interseciona(cj_a, cj_b));
     INFO("* item 3.1 interseccao com conjuntos");
     CM;

commit 749107752ff4d5e566a0a69c9cf559647bd81cd8
Author: Joilnen <joilnen@gmail.com>
Date:   Fri Jan 14 01:05:47 2022 -0300

    melhorando a documentacao

diff --git a/doc/tex/packages.tex b/doc/tex/packages.tex
index 5e4756a..54ac1c3 100644
--- a/doc/tex/packages.tex
+++ b/doc/tex/packages.tex
@@ -1,13 +1,15 @@
 \usepackage{syntax}
 \usepackage[brazilian]{babel}
 \usepackage[utf8]{inputenc}
+\usepackage[light,condensed,math]{iwona}
+\usepackage[T1]{fontenc}
 % \usepackage[usenames, dvipsnames]{xcolor}
 \usepackage[usenames, dvipsnames]{color}
 % \usepackage{tgtermes} times homan font similar
 \usepackage{hyperref}
 \usepackage{indentfirst}
 \usepackage{bbding}
-\usepackage{pifont}
+% \usepackage{pifont}
 \usepackage{makeidx}
 \makeindex
 \hypersetup{
diff --git a/doc/tex/relatorio.pdf b/doc/tex/relatorio.pdf
index 9326675..46ee4e7 100644
Binary files a/doc/tex/relatorio.pdf and b/doc/tex/relatorio.pdf differ
diff --git a/doc/tex/relatorio.tex b/doc/tex/relatorio.tex
index 6aeee3f..c84b32c 100644
--- a/doc/tex/relatorio.tex
+++ b/doc/tex/relatorio.tex
@@ -9,9 +9,6 @@
 % \fancyfoot{}
 \usepackage{listingsutf8}
 \usepackage{xcolor}
-\usepackage{lmodern}
-\usepackage[T1]{fontenc}
-\usepackage{aesupp}
 
 % \definecolor{codegreen}{rgb}{0,0.6,0}
 \definecolor{codegreen}{rgb}{.6,.3,0}
@@ -20,6 +17,7 @@
 \definecolor{backcolour}{rgb}{0.95,0.95,0.92}
 
 \DeclareEmphSequence{\bfseries, \mdseries}
+% \renewcommand{\baselinestretch}{0.5}
 
 \lstdefinestyle{mystyle}{
     backgroundcolor=\color{backcolour},   
@@ -38,7 +36,7 @@
     showstringspaces=false,
     showtabs=false,                  
     frame=single,
-    tabsize=2
+    tabsize=2,
 }
 
 % \tikzset{
@@ -78,16 +76,18 @@
 \graphicspath{{fig/}}
 
 \begin {document}
+\normalfont
 % \setmainfont[
 %     Ligatures=TeX,
 %     Numbers={OldStyle, Proportional}
 % ]{DejaVu Sans}
 
 \title {
-    \Large{\textbf{RELATÓRIO SOBRE O CÓDIGO FONTE DO PROJETO, CONJUNTO ORDENADO}} \\
-    \large{\textbf{projeto este que faz uso da estrutura de dados Red Black}} \\
+    \Large{\textbf{Relatório sobre o Código Fonte}} \\
+    \Large{\textbf{do Projeto, Conjunto Ordenado}} \\
+    \large{\textbf{Uso da estrutura de dados, Árvore Red Black}} \\
     \large {UFES Centro Universitário Norte do Espírito Santo}
-    \author{JOILNEN LEITE \\ \href{mailto:joilnen.leite@edu.ufes.br}
+    \author{Joilnen Leite \\ \href{mailto:joilnen.leite@edu.ufes.br}
     {\color{blue}joilnen.leite@edu.ufes.br}}
 %      \footnotesize{Joilnen Leite} 
 %      \footnotesize{UFES Centro Universitário Norte do Espírito Santo} 
@@ -120,21 +120,21 @@ da atividade conjunto ordenado \\
 \section {Introdução}
 \noindent Esta biblioteca é composta pelo os seguintes arquivos, \\
 \begin{itemize}
-    \item conjunto\_ordenado.h
-    \item conjunto\_ordenado.c
-    \item red\_black.h
-    \item red\_black.c
-    \item jcurses.h 
+    \item [$\blacksquare$] conjunto\_ordenado.h
+    \item [$\blacksquare$] conjunto\_ordenado.c
+    \item [$\blacksquare$] red\_black.h
+    \item [$\blacksquare$] red\_black.c
+    \item [$\blacksquare$] jcurses.h 
 \end{itemize}
 
 Completamente separado do código da biblioteca temos alguns arquivos que implementam 
 testes, estes são:
 \begin{itemize}
-    \item main.c
-    \item testa_item_1.c
-    \item testa_item_2.c
-    \item testa_item_3.c
-    \item testa_rb.c
+    \item [$\blacksquare$] main.c
+    \item [$\blacksquare$] testa_item_1.c
+    \item [$\blacksquare$] testa_item_2.c
+    \item [$\blacksquare$] testa_item_3.c
+    \item [$\blacksquare$] testa_rb.c
 \end{itemize}
 
 Todos os arquivos estão listados nos anexos na sua íntegra.
@@ -167,7 +167,7 @@ A primeira estrutura que veremos aqui é a \enf{conjord} ela representa um conju
 
 \lstinputlisting [linerange={11-31}, firstnumber=11, caption = {Fragmento do conjunto_ordenado.h}]{../../src/conjunto_ordenado.h}
 
-Aqui temos a função que cria um conjunto ordenando, um tipo conjord
+\noindent Aqui temos a função que cria um conjunto ordenando, um tipo conjord
 
 \lstinputlisting [firstnumber=9, linerange={9-23}, caption = {Fragmento do conjunto_ordenado.c}]{../../src/conjunto_ordenado.c}
 
@@ -178,11 +178,11 @@ idx é um indice para um array de raizes que é usado apenas pra controle e aces
 rápido a todas as árvores criadas, nome é uma identificação opcional e cardinalidade
 zero por que o conjunto está vazio.
 
-Aqui o exemplo do seu uso  num caso de teste
+\noindent Aqui o exemplo do seu uso  num caso de teste
 
 \lstinputlisting [firstnumber=55, linerange={55-56}, caption = {Fragmento do testa_item_1.c}]{../../src/testa_item_1.c}
 
-Sigamos para a função de teste a seguir \enf{adiciona_lista_de_elelementos} ela vai exemplificar
+\noindent Sigamos para a função de teste a seguir \enf{adiciona_lista_de_elelementos} ela vai exemplificar
 como essa criação se dá até a árvore
 
 \lstinputlisting [firstnumber=9, linerange={9-42}, caption = {Fragmento do testa_item_1.c}]{../../src/testa_item_1.c}
@@ -366,7 +366,66 @@ do lado esquerdo reagrupando os nós, vejamos detalhadamente como.\\
 \end{tabular}
 \end{table}
 
-\noindent Um diagrama em nome da clareza \\
+\noindent Um diagrama em nome da clareza, clro que aqui está reprensentado apenas os nós
+que são representativos de uma rotação a esquerda e não árvores completas.\\
+\begin{tikzpicture}[->,>=stealth',level/.style={sibling distance = 2.5cm/#1,
+  level distance = .5cm}] 
+\node [arn_n] {x}
+    child{ node [arn_n] {1}
+        child { node [arn_x] {} }
+        child { node [arn_x] {} }
+    }
+    child{ node [arn_n] {y}
+        child{ node [arn_r] {5}
+            child { node [arn_x] {} }
+            child { node [arn_x] {} }
+        }
+        child{ node [arn_r] {8}
+            child { node [arn_x] {} }
+            child { node [arn_x] {} }
+        }
+    }
+; 
+\end{tikzpicture} 
+\colorbox{BurntOrange}{\scriptsize após \enf{rb_rot_esq} }
+\begin{tikzpicture}[->,>=stealth',level/.style={sibling distance = 2.5cm/#1,
+  level distance = .5cm}] 
+\node [arn_n] {y}
+    child{ node [arn_n] {x}
+        child{ node [arn_r] {1}
+            child { node [arn_x] {} }
+            child { node [arn_x] {} }
+        }
+        child{ node [arn_r] {5}
+            child { node [arn_x] {} }
+            child { node [arn_x] {} }
+        }
+    }
+    child{ node [arn_n] {8}
+        child { node [arn_x] {} }
+        child { node [arn_x] {} }
+    }
+; 
+\end{tikzpicture} \\
+Continuando a análise da função \enf{rb_insert}, do ponto que interrompemos para entendermos o \enf{rb_rot_esq},
+após estar rotação a esquerda a árvore neste ponto passa para o \enf{caso 3} e a será feito uma rotação a direita
+\enf{z} tem o pai e o avô colorido com preto e vermelho respectivamente e o avô rotacionado a direta.
+Repetindo aqui o fragmento do código anterior \enf{rb_insert}, trata o \enf{caso 3} linhas 114-116.
+\lstinputlisting [firstnumber=97, linerange={97-118}, caption = {Fragmento do red_black.c}]{../../src/red_black.c}
+\begin{table}[!ht]
+    \scriptsize
+\begin{tabular}{|l|l|}
+    \hline 
+    114 & colore pai de \enf{z} com preto \\
+    \hline 
+    115 & colore avô de \enf{z} com vermelho \\
+    \hline 
+    116 & rotaciona avô a direita \\
+    \hline 
+\end{tabular}
+\end{table}
+\ \\
+Um diagrama em nome da clareza\\
 \begin{tikzpicture}[->,>=stealth',level/.style={sibling distance = 2.5cm/#1,
   level distance = .5cm}] 
 \node [arn_n] {x}
@@ -406,10 +465,6 @@ do lado esquerdo reagrupando os nós, vejamos detalhadamente como.\\
     }
 ; 
 \end{tikzpicture} \\
-\\
-\\
-\\
-\\
 Aqui temos a parte mais importante da inclusão, se o nó pai do nó incluído \enf{z}
 é nó a esquerda, ou seja filho a esquerda do avô, fazemos \enf{y} apontar para o nó
 tio a direita. O diagrama abaixo representa esta 

commit dd5fcbf3498c6e0ea845cb10d729ff937993a35a
Author: Joilnen <joilnen@gmail.com>
Date:   Fri Jan 14 01:15:44 2022 -0300

    atualizacao de repertorio

diff --git a/doc/tex/relatorio.pdf b/doc/tex/relatorio.pdf
index 46ee4e7..620617c 100644
Binary files a/doc/tex/relatorio.pdf and b/doc/tex/relatorio.pdf differ
diff --git a/doc/tex/relatorio.tex b/doc/tex/relatorio.tex
index c84b32c..1ee70a9 100644
--- a/doc/tex/relatorio.tex
+++ b/doc/tex/relatorio.tex
@@ -174,7 +174,7 @@ A primeira estrutura que veremos aqui é a \enf{conjord} ela representa um conju
 Apesar do código ser bem simples, temos aqui detalhadamente, a criação do tipo cojord 
 , o ponteiro pr aponta para raiz da árvore, interna a este conjunto, como 
 o conjunto tá vazio ele aponta para o nó sentinela(rb_s - red black sentinela),
-idx é um indice para um array de raizes que é usado apenas pra controle e acesso
+idx é um indice para um array de raizes que é usado apenas para controle e acesso
 rápido a todas as árvores criadas, nome é uma identificação opcional e cardinalidade
 zero por que o conjunto está vazio.
 
@@ -188,7 +188,7 @@ como essa criação se dá até a árvore
 \lstinputlisting [firstnumber=9, linerange={9-42}, caption = {Fragmento do testa_item_1.c}]{../../src/testa_item_1.c}
 
 Nesse fragmento vemos o tipo definido pelo o usuário será o tipo  genério 
-onde apontaremos o ponteiro \enf{void *} pra ele, 
+onde apontaremos o ponteiro \enf{void *} para ele, 
 apartir da linha 28, temos a criação de um tipo composto do tipo do cliente, aqui como 
 uma estrutura com dois ponteiros para char, sequencia finalizada como '\textbackslash0', que é como 
 representamos strings em C, são criados 20 elementos neste loop, com chave randômica
@@ -242,7 +242,7 @@ primeiro \enf{if}, apenas faz a inclusão do novo nó da mesma forma que na árv
 busca comum, o while itera até a folha comparando as chaves, neste caso aqui, foi 
 modificado para aceitar apenas chaves diferentes, retornando código de erro caso contrário,
 e uma vêz que temos a \enf{y} apontando para este nó folha, anexamos \enf{z} a este nó
-fazendo o apontamento do ponteiro filho neste nó folha pra \enf{z}, a única grande 
+fazendo o apontamento do ponteiro filho neste nó folha para \enf{z}, a única grande 
 diferença é que no final desta parte colorimos com vermelho, o novo nó incluído.
 
 Todas as inclusões entram numa etapa, o segndo \enf{while}, que chamei de \enf{ajuste}

commit 5901d2b83393fb16607bbbdaae3f9a8c24836245
Author: Joilnen <joilnen@gmail.com>
Date:   Fri Jan 14 13:10:25 2022 -0300

    documentacao

diff --git a/doc/tex/relatorio.pdf b/doc/tex/relatorio.pdf
index 620617c..5d71172 100644
Binary files a/doc/tex/relatorio.pdf and b/doc/tex/relatorio.pdf differ
diff --git a/doc/tex/relatorio.tex b/doc/tex/relatorio.tex
index 1ee70a9..59a8375 100644
--- a/doc/tex/relatorio.tex
+++ b/doc/tex/relatorio.tex
@@ -9,6 +9,25 @@
 % \fancyfoot{}
 \usepackage{listingsutf8}
 \usepackage{xcolor}
+\usepackage{booktabs}
+\usepackage[most]{tcolorbox}
+
+\newtcolorbox[blend into=tables]{mytable}[2][]{%
+    enhanced,
+    float, 
+    every float=\centering,
+    capture=hbox, 
+    title = #2, 
+    attach boxed title to top left={%
+        xshift=5mm, 
+        yshift=-\tcboxedtitleheight/2, 
+        yshifttext=-1mm},
+    boxed title style={colback=blue!50, sharp corners},
+    colframe = blue!50,
+    colback = blue!20,  
+    % overlay = {\node[text=white, fill=red] at (frame.east) 
+    %     {$\clubsuit$};},
+    #1}
 
 % \definecolor{codegreen}{rgb}{0,0.6,0}
 \definecolor{codegreen}{rgb}{.6,.3,0}
@@ -53,9 +72,9 @@
 \tikzset{
   treenode/.style = {align=center, inner sep=0pt, text centered,
     font=\tiny},
-  arn_n/.style = {treenode, circle, white, draw=black,
+  arn_n/.style = {treenode, circle, yellow, draw=black, font=\scriptsize,
     text centered, fill=black, minimum size=3mm},% arbre rouge noir, noeud noir
-  arn_r/.style = {treenode, circle, white, draw=red, fill=red,
+  arn_r/.style = {treenode, circle, black, draw=red, fill=red, font=\scriptsize,
     text centered, minimum size=3mm},% arbre rouge noir, noeud rouge
   arn_x/.style = {treenode, rectangle, draw=black, fill=black,
     minimum width=0.25em, minimum height=0.25em}% arbre rouge noir, nil
@@ -258,8 +277,8 @@ que aponta para o filho esquerdo.
 O primeiro caso é tratado no segundo \enf{if} do segundo \enf{while}, o primeiro \enf{if}
 decide se está sendo incluído pelo o lado esquerdo e da linha 99-106, temos o tratamento 
 do \enf{caso 1}, nó pai vermerlho, e nó tio vermelho, segue um diagrama deste caso em
-nome da clereza.
-
+nome da clereza.\\
+\begin{minipage}{20cm}
 \begin{tikzpicture}[->,>=stealth',level/.style={sibling distance = 2.5cm/#1,
   level distance = .5cm}] 
 \node [arn_n] {}
@@ -322,7 +341,8 @@ nome da clereza.
         }
     }
 ; 
-\end{tikzpicture} \\
+\end{tikzpicture}
+\end{minipage}
 Note que saímos do \enf{caso 1} e caímos no \enf{caso 2}, nó pai do nó agora 
 apontado por \enf{z}, vermelho e nó tio preto \enf{y}, lembre-se que estamos dentro de um
 \enf{while} em loop enquanto a cor do pai de \enf{z} for vermelha, este segundo caso
@@ -331,7 +351,8 @@ analizarmos o que faz esta função.
 \lstinputlisting [firstnumber=319, linerange={319-342}, caption = {Fragmento do red_black.c}]{../../src/red_black.c}
 Esta função \enf{rb_rot_esq}, basicamente diminui a altura do lado direito e aumenta
 do lado esquerdo reagrupando os nós, vejamos detalhadamente como.\\
-\begin{table}[!ht]
+
+\begin{mytable}[colback=black!5]{rotação à esquerda}
     \scriptsize
 \begin{tabular}{|l|l|}
     \hline 
@@ -364,7 +385,42 @@ do lado esquerdo reagrupando os nós, vejamos detalhadamente como.\\
     341 & retorna inteiro para uso em testes (não utilizado neste trabalho, mas a função tem esta inferface)\\
     \hline
 \end{tabular}
-\end{table}
+\end{mytable}
+
+% \begin{table}[!ht]
+%     \scriptsize
+% \begin{tabular}{|l|l|}
+%     \hline 
+%     327 & guarda referência do filho a direita \\
+%     \hline 
+%     328 & faz filho a direita igual a neto a esquerda (dimininuíndo a altura direita) \\
+%     \hline 
+%     329 & se filho a direita (antigo neto a esquerda) não é sentinela \\
+%     \hline 
+%     330 & atualiza pai de filho a direita (antigo neto a esquerda)\\
+%     \hline 
+%     331 & atualiza pai do nó movido\\
+%     \hline 
+%     332 & testa se nó anterior era raiz \\
+%     \hline 
+%     333 & atualiza nó raiz \\
+%     \hline 
+%     334 & se não é raiz testa se é nó a esquerda\\
+%     \hline 
+%     335 & atualiza como nó a esquerda\\
+%     \hline 
+%     336 & se nenhuma das opções anteriores\\
+%     \hline 
+%     337 & atualiza como nó a direita\\
+%     \hline 
+%     338 & atualiza filho a esquerda de y igual x, note que o nó x que era pai passa a ser filho\\
+%     \hline 
+%     339 & atualiza pai de x igual de y \\
+%     \hline 
+%     341 & retorna inteiro para uso em testes (não utilizado neste trabalho, mas a função tem esta inferface)\\
+%     \hline
+% \end{tabular}
+% \end{table}
 
 \noindent Um diagrama em nome da clareza, clro que aqui está reprensentado apenas os nós
 que são representativos de uma rotação a esquerda e não árvores completas.\\
diff --git a/doc/tex/table.lot b/doc/tex/table.lot
new file mode 100644
index 0000000..6a84ce8
--- /dev/null
+++ b/doc/tex/table.lot
@@ -0,0 +1,3 @@
+\contentsline {table}{\numberline {1}{\ignorespaces First table}}{1}{}%
+\contentsline {tcolorbox}{\numberline {2}{\ignorespaces Second table}}{1}{}%
+\contentsline {tcolorbox}{\numberline {3}{\ignorespaces Trird table}}{1}{}%
diff --git a/doc/tex/table.pdf b/doc/tex/table.pdf
new file mode 100644
index 0000000..f7e3592
Binary files /dev/null and b/doc/tex/table.pdf differ
diff --git a/doc/tex/table.tex b/doc/tex/table.tex
new file mode 100644
index 0000000..4a270ee
--- /dev/null
+++ b/doc/tex/table.tex
@@ -0,0 +1,60 @@
+\documentclass{article}
+\usepackage{booktabs}
+\usepackage[most]{tcolorbox}
+
+\newtcolorbox[blend into=tables]{mytable}[2][]{%
+    enhanced,
+    float, 
+    every float=\centering,
+    capture=hbox, 
+    title = #2, 
+    attach boxed title to top left={%
+        xshift=5mm, 
+        yshift=-\tcboxedtitleheight/2, 
+        yshifttext=-1mm},
+    boxed title style={colback=blue!50, sharp corners},
+    colframe = blue!50,
+    colback = blue!20,  
+    % overlay = {\node[text=white, fill=red] at (frame.east) 
+    %     {$\clubsuit$};},
+    #1}
+
+\begin{document}
+\listoftables
+
+\begin{table}
+\centering
+\begin{tabular}{|r|l|}
+  \hline
+  7C0 & hexadecimal \\
+  3700 & octal \\ \cline{2-2}
+  11111000000 & binary \\
+  \hline \hline
+  1984 & decimal \\
+  \hline
+\end{tabular}
+\caption{First table}
+\end{table}
+
+\begin{mytable}{Second table}
+\begin{tabular}{rl}
+  7C0 & hexadecimal \\
+  3700 & octal \\ 
+  11111000000 & binary \\
+  \midrule
+  1984 & decimal \\
+\end{tabular}
+\end{mytable}
+
+\begin{mytable}[colback=red!5]{Trird table}
+\begin{tabular}{l*{6}{c}r}
+Team              & P & W & D & L & F  & A & Pts \\
+\midrule
+Manchester United & 6 & 4 & 0 & 2 & 10 & 5 & 12  \\
+Celtic            & 6 & 3 & 0 & 3 &  8 & 9 &  9  \\
+Benfica           & 6 & 2 & 1 & 3 &  7 & 8 &  7  \\
+FC Copenhagen     & 6 & 2 & 1 & 3 &  5 & 8 &  7  \\
+\end{tabular}
+\end{mytable}
+
+\end{document}

commit 934bdf72c946071e5b7e1f05a296e6b37554e91b
Author: Joilnen <joilnen@gmail.com>
Date:   Fri Jan 14 14:42:24 2022 -0300

    melhorando a formatacao, mudando o sublinhado dos titulos por bold,
    pra funcionar eh compativel com vt100

diff --git a/src/checklist.c b/src/checklist.c
index 399bf26..c61a11b 100644
--- a/src/checklist.c
+++ b/src/checklist.c
@@ -12,7 +12,7 @@ void tela_checklist(int i)
     static unsigned int cklst_estado = 0;
     cklst_estado |= i ; 
 
-    CKLSITEM(l++, c + 11, 0, "avaliacao");
+    CKLSITEM(l++, c + 11, 0, S_UNDERL"avaliacao"S_NORM);
     CKLSITEM(l++, c, 0, " ");
     CKLSITEM(l++, c, cklst_estado & bo, ITEM1_1); bo <<= 1;
     CKLSITEM(l++, c, cklst_estado & bo, ITEM1_2); bo <<= 1;
diff --git a/src/jcurses.h b/src/jcurses.h
index 724ae59..aa58c52 100644
--- a/src/jcurses.h
+++ b/src/jcurses.h
@@ -17,7 +17,7 @@
 #define S_LTELA "\033[H\033[J"
 #define S_CM "\033[24;62H"
 #define S_CMR "\033[24;58H"
-#define S_UNDERL "\033[21m"
+#define S_UNDERL "\033[1m"
 #define S_AZUL "\033[44m\033[37m"
 #define S_VERM "\033[41m\033[37m"
 #define S_INV  "\033[7m"
diff --git a/src/testa_rb.c b/src/testa_rb.c
index 149abad..52bbd2c 100644
--- a/src/testa_rb.c
+++ b/src/testa_rb.c
@@ -14,15 +14,16 @@
 void tela_testa_rb(const char *m)
 {
     int l = 5, c = 24, f;
-    char mens[6][48] =
+    char mens[5][48] =
     {
         S_UNDERL"serah efetuado os testes:"S_NORM,
         "insercao e remocao na arvore",
         "nao foi pedido mas me ajudou a",
-        "checar a correcao da arvore"
+        "checar a correcao da arvore",
+        "chaves randomicas de 01 a 99"
     };
     LTELA;
-    for (f = 0; f < 4; f++)
+    for (f = 0; f < 5; f++)
         CKLSITEM(l++, c, 0, mens[f]);
     INFO_FILE(__FILE__);
     CM;

commit 8bd521ac056bc1b2d26793862c18a64cc051759f
Author: Joilnen <joilnen@gmail.com>
Date:   Fri Jan 14 15:07:27 2022 -0300

    melhorando a info sobre o codigo executado, nome do arquivo e funcao

diff --git a/src/conjunto_ordenado.h b/src/conjunto_ordenado.h
index 52406e9..ca7663e 100644
--- a/src/conjunto_ordenado.h
+++ b/src/conjunto_ordenado.h
@@ -151,7 +151,7 @@ void conjord_imprime_venn(conjord *c);
 #define CKLSITEM(l,c,b,x) \
     if (b) printf(S_CHKLST_DONE, l, c, x); \
     else printf(S_CHKLST, l, c, x)
-#define INFO_FILE(x) printf("%s%s%s", S_INFO_ST, x, S_NORM)
+#define INFO_FILE printf("%s%s%sf:%s%s", S_INFO_ST, __FILE__, S_INFO_ST_1, __FUNCTION__, S_NORM); fflush(stdout);
 #define INFO_CARD(x) printf("%scardinalidade: %d%s", S_CARD, x, S_NORM)
 
 #endif
diff --git a/src/jcurses.h b/src/jcurses.h
index aa58c52..5b2940c 100644
--- a/src/jcurses.h
+++ b/src/jcurses.h
@@ -23,7 +23,8 @@
 #define S_INV  "\033[7m"
 #define S_NORM "\033[0m"
 #define S_INFO "\033[24;0H\033[7m"
-#define S_INFO_ST "\033[0;65H"
+#define S_INFO_ST "\033[1;65H"
+#define S_INFO_ST_1 "\033[2;65H"
 #define S_CARD "\033[0;60H"
 #define S_CHKLST "\033[%d;%dH%s\033[0m"
 #define S_CHKLST_DONE "\033[46m\033[30m\033[%d;%dH%s\033[0m"
diff --git a/src/testa_item_1.c b/src/testa_item_1.c
index ba28c67..d28ca84 100644
--- a/src/testa_item_1.c
+++ b/src/testa_item_1.c
@@ -93,7 +93,7 @@ void tela_item_1(const char *m)
     CKLSITEM(l++, c, 0, "e ordenacao dos elementos do conjunto");
     CKLSITEM(l++, c, 0, "o tipo de dado do usuario aqui eh uma");
     CKLSITEM(l++, c, 0, "estrutura com duas strings, nome e telefone");
-    INFO_FILE(__FILE__);
+    INFO_FILE;
     CM;
 }
 
diff --git a/src/testa_item_2.c b/src/testa_item_2.c
index 1de9e99..af21392 100644
--- a/src/testa_item_2.c
+++ b/src/testa_item_2.c
@@ -97,7 +97,7 @@ void tela_item_2(const char *m)
     };
     for (f = 0; f < 8; f++)
         CKLSITEM(l++, c, 0, mens[f]);
-    INFO_FILE(__FILE__);
+    INFO_FILE;
     CM;
 }
 
diff --git a/src/testa_item_3.c b/src/testa_item_3.c
index 088ba21..5bd780b 100644
--- a/src/testa_item_3.c
+++ b/src/testa_item_3.c
@@ -77,6 +77,7 @@ void testa_item_3(const char *m)
     printf("\033[10;30H");
     conjord_imprime_venn(conjord_une(cj_a, cj_b));
     INFO("* item 3.1 uniao de conjuntos");
+    INFO_FILE;
     CM;
 
     LTELA;
@@ -89,6 +90,7 @@ void testa_item_3(const char *m)
     printf("\033[10;30H");
     conjord_imprime_venn(conjord_subtrai(cj_a, cj_b));
     INFO("* item 3.1 subtracao de conjuntos");
+    INFO_FILE;
     CM;
 
     LTELA;
@@ -101,6 +103,7 @@ void testa_item_3(const char *m)
     printf("\033[10;30H");
     conjord_imprime_venn(conjord_interseciona(cj_a, cj_b));
     INFO("* item 3.1 interseccao com conjuntos");
+    INFO_FILE;
     CM;
 
     LTELA;

commit e844e278d872ead6fbbb2536c048d46429841f7f
Author: Joilnen <joilnen@gmail.com>
Date:   Fri Jan 14 15:17:34 2022 -0300

    dicionando autoria na primeira tela

diff --git a/src/testa_item_1.c b/src/testa_item_1.c
index d28ca84..8d49570 100644
--- a/src/testa_item_1.c
+++ b/src/testa_item_1.c
@@ -93,6 +93,8 @@ void tela_item_1(const char *m)
     CKLSITEM(l++, c, 0, "e ordenacao dos elementos do conjunto");
     CKLSITEM(l++, c, 0, "o tipo de dado do usuario aqui eh uma");
     CKLSITEM(l++, c, 0, "estrutura com duas strings, nome e telefone");
+    CKLSITEM(l++, c, 0, "");
+    CKLSITEM(l++, c, 0, "                       autor: joilnen leite");
     INFO_FILE;
     CM;
 }
diff --git a/src/testa_item_3.c b/src/testa_item_3.c
index 5bd780b..c6d0004 100644
--- a/src/testa_item_3.c
+++ b/src/testa_item_3.c
@@ -30,7 +30,6 @@ static void adiciona_venn(conjord *c, int pos, char *letras)
         if (!conjord_insere_elemento(c, *i, mt0))
             ++i;
     }
-
 }
 
 void tela_item_3(const char *m)

commit e8be6243a11ac1ae644fad11c0069c80e288c9e4
Author: Joilnen <joilnen@gmail.com>
Date:   Sun Jan 16 15:48:31 2022 -0300

    documentacao

diff --git a/doc/tex/relatorio.pdf b/doc/tex/relatorio.pdf
index 5d71172..cecdf1e 100644
Binary files a/doc/tex/relatorio.pdf and b/doc/tex/relatorio.pdf differ
diff --git a/doc/tex/relatorio.tex b/doc/tex/relatorio.tex
index 59a8375..d2361cd 100644
--- a/doc/tex/relatorio.tex
+++ b/doc/tex/relatorio.tex
@@ -93,6 +93,7 @@
 \newcommand{\enf}[1]{\emph{\textbf{#1}}}
 
 \graphicspath{{fig/}}
+\renewcommand{\baselinestretch}{.7}
 
 \begin {document}
 \normalfont
@@ -114,27 +115,11 @@
     \date{}
 } 
 \maketitle 
-% \thispagestyle{empty}
-% \begin{center}
-%     \Large{\textit{\textbf{Resenha Crítica do ensaio,\\ "}Ética e Pesquisa: Autonomia e Heteronomia na Prática Científica"}}}
-%     \footnote{Artigo escrito por Antonio Joaquim Severino}
-% \ \\
-% \end{center}
-% \hrule
-% \ \\
-% \ \\
-% \normalsize{\textit{\textbf{Autor: Joilnen Leite}}}\\
-% \normalsize{\textit{\textbf{Disciplina: Metodologia Científica}}}\\
-% \normalsize{\textit{\textbf{Curso: Ciência da Computação}}}\\
-% \normalsize{\textit{\textbf{Data: 24 de junho de 2020}}}
-% \ \\
-% \hrule
-% \tableofcontents
-% \vspace*{2cm}
-\textbf{Resumo: } Relatório básico sobre o conteúdo e processo de desenvolvimento 
+
+\noindent \textbf{Resumo: } Relatório básico sobre o conteúdo e processo de desenvolvimento 
 da atividade conjunto ordenado \\
 \ \\
-\indent \textbf{Palavras-chave: } fontes, C, Red Black, Conjunto\\
+\noindent \textbf{Palavras-chave: } fontes, C, Red Black, Conjunto\\
 \small
 \section {Introdução}
 \noindent Esta biblioteca é composta pelo os seguintes arquivos, \\
@@ -146,7 +131,7 @@ da atividade conjunto ordenado \\
     \item [$\blacksquare$] jcurses.h 
 \end{itemize}
 
-Completamente separado do código da biblioteca temos alguns arquivos que implementam 
+\noindent Completamente separado do código da biblioteca temos alguns arquivos que implementam 
 testes, estes são:
 \begin{itemize}
     \item [$\blacksquare$] main.c
@@ -165,7 +150,7 @@ e tem suas funções chamadas sequencialmente dentro da função \enf{main}, no
 Seguiremos neste relatório uma abordagem \enf{top-down} onde partiremos das estruturas 
 e funções manipuladas pelo o código cliente em direção as estruturas e funções que implementam
 e operam na estrutura de dados, \enf{árvore red-black}, que é totalmente ocultada do cliente
-ou seja poderíamos reimplementar as funcionalidade com outras esturas de dados e manter 
+ou seja poderíamos reimplementar as funcionalidades com outras esturas de dados e manter 
 a interface compatível com a existente.
 
 O estilo do código fonte neste trabalho é o mais tradicional, chaves abrem e fecham do mesmo lado
@@ -182,7 +167,7 @@ documentação esta constante nos anexos.
 \section {Primeiras Estruturas}
 \subsection {conjord}
 A primeira estrutura que veremos aqui é a \enf{conjord} ela representa um conjunto ordenando
-é o nosso envólucro sobre a estrutura da árvore, 
+é o nosso envólucro sobre a estrutura da \enf{árvore red-black}.
 
 \lstinputlisting [linerange={11-31}, firstnumber=11, caption = {Fragmento do conjunto_ordenado.h}]{../../src/conjunto_ordenado.h}
 
@@ -221,12 +206,12 @@ esta função a seguir,
 \lstinputlisting [firstnumber=39, linerange={39-65}, caption = {Fragmento do conjunto_ordenado.c}]{../../src/conjunto_ordenado.c}
 o \enf{if}, na linha 47, adiciona um elemento na árvore já existente, pois note que \enf{pr}
 diferente de \enf{rb_s}, o que significa que já existe árvore criada para este \enf{conjord},
-caso contrário é criada a raiz da arvore e apontado o \enf{pr} para ela, \enf{rb_cr},
+caso contrário é criada a raiz da arvore e apontado o \enf{pr} para ela, \enf{rb_cr} linha 60,
 cria uma árvore nova retorna o nó raíz tendo uma chave e um tipo qualquer(\enf{void *}),
 cadinalidade é incrementado, e no caso da inserção em árvore pre-existente, 
 ele só é incrementado caso a função \enf{rb_insert}, retorne código de inserido, zero,
 temos como retorno dessa função de inserção no conjunto, zero para inserido, e -1,
-caso o contrário, é assim que nos certificamos de ter inserido um elemento realmente
+caso o contrário, é assim que nos certificamos de ter inserido um elemento realmente de chave única
 como no código de teste visto anterioremente, note que usamos ponteiro duplo na raíz,
 por que em algumas operações teremos que modificar esse ponteiro dentro de funções chamadas,
 como em rotações e deleções.
@@ -243,18 +228,20 @@ red black e insere um novo nó.
 \lstinputlisting [firstnumber=25, linerange={25-41}, caption = {Fragmento do red_black.c}]{../../src/red_black.c}
 A mesma ideia que vimos na função \enf{conjord_insere_elemento}, alocamos aqui um novo nó,
 populamos com chave e o dado genérico, também setamos a cor preta, pois é raíz, apontamos 
-ponteiros, pai, e filhos para nó sentinela \enf{rb_s}
+ponteiros, pai, e filhos para nó sentinela \enf{rb_s}, por fim retornamos o nó raiz criado.
 
 Antes de passarmos para o \enf{rb_insert}, vamos dar uma olha na estrutura nó \enf{rb_n}
-\lstinputlisting [firstnumber=33, linerange={33-48}, caption = {Fragmento do red_black.h}]{../../src/red_black.h}, a documentação de comentário é explicita.
+\lstinputlisting [firstnumber=33, linerange={33-48}, caption = {Fragmento do red_black.h}]{../../src/red_black.h},
+trata-se da estrutura que abstrai um nó da árvore, comentário no código fonte descreve cada parâmentro.
 
-Então agora a função \enf{rb_insert} que insere um novo nó na árvore, detalharemos agora 
+Então a função \enf{rb_insert} que insere um novo nó na árvore, detalharemos agora 
 o funcionanmento desta função
 \lstinputlisting [firstnumber=43, linerange={43-145}, caption = {Fragmento do red_black.c}]{../../src/red_black.c}
 
 Tendo apenas um único nó esta rotina apenas atualiza o ponteiro raiz para este nó,
 na linha 76, faz o nó incluído apontar seu ponteiro pai para o sentinela, através de \enf{y}
-(inicializado com sentinela em 55) e atualiza o nó raiz em 86 colorindo em seguida com preto em 142.
+(inicializado com sentinela em 55) e atualiza o nó raiz em 86 colorindo em seguida colore em 142,
+pois toda raíz é preta na \enf{árvore red-black}.
 
 A primeira parte desta rotina, que inclui o primeiro \enf{while} até o
 primeiro \enf{if}, apenas faz a inclusão do novo nó da mesma forma que na árvore binária de 
@@ -264,19 +251,19 @@ e uma vêz que temos a \enf{y} apontando para este nó folha, anexamos \enf{z} a
 fazendo o apontamento do ponteiro filho neste nó folha para \enf{z}, a única grande 
 diferença é que no final desta parte colorimos com vermelho, o novo nó incluído.
 
-Todas as inclusões entram numa etapa, o segndo \enf{while}, que chamei de \enf{ajuste}
-na bibliografia é referida como \enf{fixup}, esta parte do código raz o ajuste de coloração 
-e rotaciona nós para manter as propriedades da árvore red-black obedecidas.
+Todas as inclusões entram numa etapa, o segundo \enf{while}, que chamei de \enf{ajuste}
+na bibliografia é referida como \enf{fixup}, esta parte do código faz o ajuste de coloração 
+e rotaciona nós, caso necessário, para manter as propriedades da árvore red-black obedecidas.
 
 Vejamos como esta parte da rotina trata os três casos em que podem ser quebradas
-as propriedades da árvore na inclusão e como esta parte do código resolve as inconcistências.
+as propriedades da árvore na inclusão e como esta parte do código resolve estas inconcistências.
 
 Considerando a priori apenas as inclusões que ocorrerão a esquerda, nós anexados ao ponteiro
 que aponta para o filho esquerdo.
 
 O primeiro caso é tratado no segundo \enf{if} do segundo \enf{while}, o primeiro \enf{if}
-decide se está sendo incluído pelo o lado esquerdo e da linha 99-106, temos o tratamento 
-do \enf{caso 1}, nó pai vermerlho, e nó tio vermelho, segue um diagrama deste caso em
+decide se está sendo incluído pelo o lado esquerdo, linhas 99-106, temos o tratamento 
+do \enf{caso 1}, nó pai vermelho, e nó tio vermelho, segue um diagrama deste caso em
 nome da clereza.\\
 \begin{minipage}{20cm}
 \begin{tikzpicture}[->,>=stealth',level/.style={sibling distance = 2.5cm/#1,
@@ -345,7 +332,7 @@ nome da clereza.\\
 \end{minipage}
 Note que saímos do \enf{caso 1} e caímos no \enf{caso 2}, nó pai do nó agora 
 apontado por \enf{z}, vermelho e nó tio preto \enf{y}, lembre-se que estamos dentro de um
-\enf{while} em loop enquanto a cor do pai de \enf{z} for vermelha, este segundo caso
+\enf{while} em loop enquanto a cor do pai de \enf{z} for vermelha. Este segundo caso
 é tratado no \enf{if} 109-113, onde há uma rotação a esquerda, vamos aproveitar para
 analizarmos o que faz esta função.
 \lstinputlisting [firstnumber=319, linerange={319-342}, caption = {Fragmento do red_black.c}]{../../src/red_black.c}
@@ -422,7 +409,7 @@ do lado esquerdo reagrupando os nós, vejamos detalhadamente como.\\
 % \end{tabular}
 % \end{table}
 
-\noindent Um diagrama em nome da clareza, clro que aqui está reprensentado apenas os nós
+\noindent Um diagrama em nome da clareza, claro que aqui está reprensentado apenas os nós
 que são representativos de uma rotação a esquerda e não árvores completas.\\
 \begin{tikzpicture}[->,>=stealth',level/.style={sibling distance = 2.5cm/#1,
   level distance = .5cm}] 
@@ -464,11 +451,11 @@ que são representativos de uma rotação a esquerda e não árvores completas.\
 ; 
 \end{tikzpicture} \\
 Continuando a análise da função \enf{rb_insert}, do ponto que interrompemos para entendermos o \enf{rb_rot_esq},
-após estar rotação a esquerda a árvore neste ponto passa para o \enf{caso 3} e a será feito uma rotação a direita
+após esta rotação a esquerda a árvore neste ponto passa para o \enf{caso 3} e a será feito uma rotação a direita
 \enf{z} tem o pai e o avô colorido com preto e vermelho respectivamente e o avô rotacionado a direta.
 Repetindo aqui o fragmento do código anterior \enf{rb_insert}, trata o \enf{caso 3} linhas 114-116.
 \lstinputlisting [firstnumber=97, linerange={97-118}, caption = {Fragmento do red_black.c}]{../../src/red_black.c}
-\begin{table}[!ht]
+\begin{mytable}[colback=black!5]{caso 3}
     \scriptsize
 \begin{tabular}{|l|l|}
     \hline 
@@ -476,51 +463,10 @@ Repetindo aqui o fragmento do código anterior \enf{rb_insert}, trata o \enf{cas
     \hline 
     115 & colore avô de \enf{z} com vermelho \\
     \hline 
-    116 & rotaciona avô a direita \\
+    116 & rotaciona avô à direita \\
     \hline 
 \end{tabular}
-\end{table}
-\ \\
-Um diagrama em nome da clareza\\
-\begin{tikzpicture}[->,>=stealth',level/.style={sibling distance = 2.5cm/#1,
-  level distance = .5cm}] 
-\node [arn_n] {x}
-    child{ node [arn_n] {1}
-        child { node [arn_x] {} }
-        child { node [arn_x] {} }
-    }
-    child{ node [arn_n] {y}
-        child{ node [arn_r] {5}
-            child { node [arn_x] {} }
-            child { node [arn_x] {} }
-        }
-        child{ node [arn_r] {8}
-            child { node [arn_x] {} }
-            child { node [arn_x] {} }
-        }
-    }
-; 
-\end{tikzpicture} 
-\colorbox{BurntOrange}{\scriptsize após \enf{rb_rot_esq} }
-\begin{tikzpicture}[->,>=stealth',level/.style={sibling distance = 2.5cm/#1,
-  level distance = .5cm}] 
-\node [arn_n] {y}
-    child{ node [arn_n] {x}
-        child{ node [arn_r] {1}
-            child { node [arn_x] {} }
-            child { node [arn_x] {} }
-        }
-        child{ node [arn_r] {5}
-            child { node [arn_x] {} }
-            child { node [arn_x] {} }
-        }
-    }
-    child{ node [arn_n] {8}
-        child { node [arn_x] {} }
-        child { node [arn_x] {} }
-    }
-; 
-\end{tikzpicture} \\
+\end{mytable}
 Aqui temos a parte mais importante da inclusão, se o nó pai do nó incluído \enf{z}
 é nó a esquerda, ou seja filho a esquerda do avô, fazemos \enf{y} apontar para o nó
 tio a direita. O diagrama abaixo representa esta 
@@ -602,6 +548,12 @@ tio a direita. O diagrama abaixo representa esta
 \\
 \\
 \\
+\begin{enumerate}
+    \item \enf{z} será root
+    \item tio de \enf{z} vermelho
+    \item tio de \enf{z} preto em forma de triangulo
+    \item tio de \enf{z} preto em forma de linha
+\end{enumerate}
 %%
 %%
 %%  daqui pra frente eh antigo 

commit 62f5f42841c1ce06dc91e4da71139d87b5317aa8
Author: Joilnen <joilnen@gmail.com>
Date:   Sun Jan 16 23:55:44 2022 -0300

    documentacao

diff --git a/doc/tex/relatorio.pdf b/doc/tex/relatorio.pdf
index cecdf1e..eaff269 100644
Binary files a/doc/tex/relatorio.pdf and b/doc/tex/relatorio.pdf differ
diff --git a/doc/tex/relatorio.tex b/doc/tex/relatorio.tex
index d2361cd..925b6ff 100644
--- a/doc/tex/relatorio.tex
+++ b/doc/tex/relatorio.tex
@@ -235,106 +235,125 @@ Antes de passarmos para o \enf{rb_insert}, vamos dar uma olha na estrutura nó \
 trata-se da estrutura que abstrai um nó da árvore, comentário no código fonte descreve cada parâmentro.
 
 Então a função \enf{rb_insert} que insere um novo nó na árvore, detalharemos agora 
-o funcionanmento desta função
+o funcionanmento desta função.
 \lstinputlisting [firstnumber=43, linerange={43-145}, caption = {Fragmento do red_black.c}]{../../src/red_black.c}
 
-Tendo apenas um único nó esta rotina apenas atualiza o ponteiro raiz para este nó,
+Consideremos estes 4 casos bases:
+\begin{center}
+    \begin{minipage}{0.4\textwidth}
+\begin{enumerate}
+    \setcounter{enumi}{-1}
+    \item \enf{z} será root
+    \item tio de \enf{z} vermelho
+    \item tio de \enf{z} preto em forma de triângulo
+    \item tio de \enf{z} preto em forma de linha
+\end{enumerate}
+    \end{minipage}
+\end{center}
+
+\enf{Caso 0}, tendo apenas um único nó esta rotina apenas atualiza o ponteiro raiz para este nó,
 na linha 76, faz o nó incluído apontar seu ponteiro pai para o sentinela, através de \enf{y}
-(inicializado com sentinela em 55) e atualiza o nó raiz em 86 colorindo em seguida colore em 142,
+(inicializado com sentinela em 55) e atualiza o nó raiz em 86 colorindo em seguida com a cor preta em 142,
 pois toda raíz é preta na \enf{árvore red-black}.
 
-A primeira parte desta rotina, que inclui o primeiro \enf{while} até o
+
+A primeira parte desta rotina, composta  do primeiro \enf{while} até o
 primeiro \enf{if}, apenas faz a inclusão do novo nó da mesma forma que na árvore binária de 
 busca comum, o while itera até a folha comparando as chaves, neste caso aqui, foi 
 modificado para aceitar apenas chaves diferentes, retornando código de erro caso contrário,
 e uma vêz que temos a \enf{y} apontando para este nó folha, anexamos \enf{z} a este nó
-fazendo o apontamento do ponteiro filho neste nó folha para \enf{z}, a única grande 
-diferença é que no final desta parte colorimos com vermelho, o novo nó incluído.
+fazendo o apontamento do ponteiro filho deste nó folha para \enf{z}, a única grande 
+diferença é que no final desta etapa colorimos com vermelho, linha 92, o novo nó incluído.
 
-Todas as inclusões entram numa etapa, o segundo \enf{while}, que chamei de \enf{ajuste}
+O segundo \enf{while}, que chamei de \enf{ajuste}
 na bibliografia é referida como \enf{fixup}, esta parte do código faz o ajuste de coloração 
 e rotaciona nós, caso necessário, para manter as propriedades da árvore red-black obedecidas.
 
-Vejamos como esta parte da rotina trata os três casos em que podem ser quebradas
+Note que o while permanece em loop enquanto nó pai de \enf{z}, nó a ser incluído, é também 
+vermelho, lembre que não podemos ter nó vermelho filho de outro nó vermelho.
+
+Vejamos como esta parte da rotina trata os três casos restantes, em que podem ser quebradas
 as propriedades da árvore na inclusão e como esta parte do código resolve estas inconcistências.
 
 Considerando a priori apenas as inclusões que ocorrerão a esquerda, nós anexados ao ponteiro
 que aponta para o filho esquerdo.
 
-O primeiro caso é tratado no segundo \enf{if} do segundo \enf{while}, o primeiro \enf{if}
-decide se está sendo incluído pelo o lado esquerdo, linhas 99-106, temos o tratamento 
-do \enf{caso 1}, nó pai vermelho, e nó tio vermelho, segue um diagrama deste caso em
-nome da clereza.\\
-\begin{minipage}{20cm}
-\begin{tikzpicture}[->,>=stealth',level/.style={sibling distance = 2.5cm/#1,
-  level distance = .5cm}] 
-\node [arn_n] {}
-    child{ node [arn_r] {}
-        child{ node [arn_n] {} 
-            child { node [arn_x] {} }
-            child { node [arn_x] {} }
-        }
-        child{ node [arn_n] {} 
-            child{ node [arn_r] {} 
-                child{ node [arn_r] {z} 
+\enf{Caso 1}, nó tio de \enf{z} é vermelho, é tratado no segundo \enf{if} do segundo
+\enf{while}, o primeiro \enf{if} decide se está sendo incluído pelo o lado esquerdo,
+linhas 99-106, temos o tratamento do \enf{caso 1}, nó pai vermelho, e nó tio vermelho,
+segue um diagrama deste caso em nome da clereza.\\
+\begin{center}
+    \begin{minipage}{.95\textwidth}
+        \begin{tikzpicture}[->,>=stealth',level/.style={sibling distance = 2.5cm/#1,
+          level distance = .5cm}] 
+        \node [arn_n] {}
+            child{ node [arn_r] {}
+                child{ node [arn_n] {} 
                     child { node [arn_x] {} }
                     child { node [arn_x] {} }
                 }
-                child { node [arn_x] {} }
+                child{ node [arn_n] {} 
+                    child{ node [arn_r] {} 
+                        child{ node [arn_r] {z} 
+                            child { node [arn_x] {} }
+                            child { node [arn_x] {} }
+                        }
+                        child { node [arn_x] {} }
+                    }
+                    child{ node [arn_r] {y} 
+                        child { node [arn_x] {} }
+                        child { node [arn_x] {} }
+                    }
+                }
             }
-            child{ node [arn_r] {y} 
-                child { node [arn_x] {} }
+            child{ node [arn_n] {}
                 child { node [arn_x] {} }
+                child{ node [arn_r] {}
+                    child { node [arn_x] {} }
+                    child { node [arn_x] {} }
+                }
             }
-        }
-    }
-    child{ node [arn_n] {}
-        child { node [arn_x] {} }
-        child{ node [arn_r] {}
-            child { node [arn_x] {} }
-            child { node [arn_x] {} }
-        }
-    }
-; 
-\end{tikzpicture}
-\colorbox{BurntOrange}{\scriptsize após o \enf{if} nas linhas, 99-106 }
-\begin{tikzpicture}[->,>=stealth',level/.style={sibling distance = 2.5cm/#1,
-  level distance = .5cm}] 
-\node [arn_n] {}
-    child{ node [arn_r] {}
-        child{ node [arn_n] {} 
-            child { node [arn_x] {} }
-            child { node [arn_x] {} }
-        }
-        child{ node [arn_r] {z} 
-            child{ node [arn_n] {} 
-                child{ node [arn_r] {} 
+        ; 
+        \end{tikzpicture}
+        \colorbox{BurntOrange}{\scriptsize após o \enf{if} nas linhas, 99-106 }
+        \begin{tikzpicture}[->,>=stealth',level/.style={sibling distance = 2.5cm/#1,
+          level distance = .5cm}] 
+        \node [arn_n] {}
+            child{ node [arn_r] {}
+                child{ node [arn_n] {} 
                     child { node [arn_x] {} }
                     child { node [arn_x] {} }
                 }
-                child { node [arn_x] {} }
+                child{ node [arn_r] {z} 
+                    child{ node [arn_n] {} 
+                        child{ node [arn_r] {} 
+                            child { node [arn_x] {} }
+                            child { node [arn_x] {} }
+                        }
+                        child { node [arn_x] {} }
+                    }
+                    child{ node [arn_n] {} 
+                        child { node [arn_x] {} }
+                        child { node [arn_x] {} }
+                    }
+                }
             }
-            child{ node [arn_n] {} 
-                child { node [arn_x] {} }
+            child{ node [arn_n] {y}
                 child { node [arn_x] {} }
+                child{ node [arn_r] {}
+                    child { node [arn_x] {} }
+                    child { node [arn_x] {} }
+                }
             }
-        }
-    }
-    child{ node [arn_n] {y}
-        child { node [arn_x] {} }
-        child{ node [arn_r] {}
-            child { node [arn_x] {} }
-            child { node [arn_x] {} }
-        }
-    }
-; 
-\end{tikzpicture}
-\end{minipage}
+        ; 
+        \end{tikzpicture}
+    \end{minipage}
+\end{center}
 Note que saímos do \enf{caso 1} e caímos no \enf{caso 2}, nó pai do nó agora 
-apontado por \enf{z}, vermelho e nó tio preto \enf{y}, lembre-se que estamos dentro de um
-\enf{while} em loop enquanto a cor do pai de \enf{z} for vermelha. Este segundo caso
-é tratado no \enf{if} 109-113, onde há uma rotação a esquerda, vamos aproveitar para
-analizarmos o que faz esta função.
+apontado por \enf{z}, vermelho e nó tio preto \enf{y}, em formato de triângulo,
+lembre-se que estamos dentro de um \enf{while} em loop enquanto a cor do pai de 
+\enf{z} for vermelha. Este segundo caso é tratado no \enf{if} 109-113, onde há 
+uma rotação a esquerda, vamos aproveitar para analizarmos o que faz esta função.
 \lstinputlisting [firstnumber=319, linerange={319-342}, caption = {Fragmento do red_black.c}]{../../src/red_black.c}
 Esta função \enf{rb_rot_esq}, basicamente diminui a altura do lado direito e aumenta
 do lado esquerdo reagrupando os nós, vejamos detalhadamente como.\\
@@ -374,82 +393,52 @@ do lado esquerdo reagrupando os nós, vejamos detalhadamente como.\\
 \end{tabular}
 \end{mytable}
 
-% \begin{table}[!ht]
-%     \scriptsize
-% \begin{tabular}{|l|l|}
-%     \hline 
-%     327 & guarda referência do filho a direita \\
-%     \hline 
-%     328 & faz filho a direita igual a neto a esquerda (dimininuíndo a altura direita) \\
-%     \hline 
-%     329 & se filho a direita (antigo neto a esquerda) não é sentinela \\
-%     \hline 
-%     330 & atualiza pai de filho a direita (antigo neto a esquerda)\\
-%     \hline 
-%     331 & atualiza pai do nó movido\\
-%     \hline 
-%     332 & testa se nó anterior era raiz \\
-%     \hline 
-%     333 & atualiza nó raiz \\
-%     \hline 
-%     334 & se não é raiz testa se é nó a esquerda\\
-%     \hline 
-%     335 & atualiza como nó a esquerda\\
-%     \hline 
-%     336 & se nenhuma das opções anteriores\\
-%     \hline 
-%     337 & atualiza como nó a direita\\
-%     \hline 
-%     338 & atualiza filho a esquerda de y igual x, note que o nó x que era pai passa a ser filho\\
-%     \hline 
-%     339 & atualiza pai de x igual de y \\
-%     \hline 
-%     341 & retorna inteiro para uso em testes (não utilizado neste trabalho, mas a função tem esta inferface)\\
-%     \hline
-% \end{tabular}
-% \end{table}
-
 \noindent Um diagrama em nome da clareza, claro que aqui está reprensentado apenas os nós
 que são representativos de uma rotação a esquerda e não árvores completas.\\
-\begin{tikzpicture}[->,>=stealth',level/.style={sibling distance = 2.5cm/#1,
-  level distance = .5cm}] 
-\node [arn_n] {x}
-    child{ node [arn_n] {1}
-        child { node [arn_x] {} }
-        child { node [arn_x] {} }
-    }
-    child{ node [arn_n] {y}
-        child{ node [arn_r] {5}
-            child { node [arn_x] {} }
-            child { node [arn_x] {} }
-        }
-        child{ node [arn_r] {8}
-            child { node [arn_x] {} }
-            child { node [arn_x] {} }
-        }
-    }
-; 
-\end{tikzpicture} 
-\colorbox{BurntOrange}{\scriptsize após \enf{rb_rot_esq} }
-\begin{tikzpicture}[->,>=stealth',level/.style={sibling distance = 2.5cm/#1,
-  level distance = .5cm}] 
-\node [arn_n] {y}
-    child{ node [arn_n] {x}
-        child{ node [arn_r] {1}
-            child { node [arn_x] {} }
-            child { node [arn_x] {} }
-        }
-        child{ node [arn_r] {5}
-            child { node [arn_x] {} }
-            child { node [arn_x] {} }
-        }
-    }
-    child{ node [arn_n] {8}
-        child { node [arn_x] {} }
-        child { node [arn_x] {} }
-    }
-; 
-\end{tikzpicture} \\
+
+\begin{center}
+    \begin{minipage}{.95\textwidth}
+        \begin{tikzpicture}[->,>=stealth',level/.style={sibling distance = 2.5cm/#1,
+          level distance = .5cm}] 
+        \node [arn_n] {x}
+            child{ node [arn_n] {1}
+                child { node [arn_x] {} }
+                child { node [arn_x] {} }
+            }
+            child{ node [arn_n] {y}
+                child{ node [arn_r] {5}
+                    child { node [arn_x] {} }
+                    child { node [arn_x] {} }
+                }
+                child{ node [arn_r] {8}
+                    child { node [arn_x] {} }
+                    child { node [arn_x] {} }
+                }
+            }
+        ; 
+        \end{tikzpicture} 
+        \colorbox{BurntOrange}{\scriptsize após \enf{rb_rot_esq} }
+        \begin{tikzpicture}[->,>=stealth',level/.style={sibling distance = 2.5cm/#1,
+          level distance = .5cm}] 
+        \node [arn_n] {y}
+            child{ node [arn_n] {x}
+                child{ node [arn_r] {1}
+                    child { node [arn_x] {} }
+                    child { node [arn_x] {} }
+                }
+                child{ node [arn_r] {5}
+                    child { node [arn_x] {} }
+                    child { node [arn_x] {} }
+                }
+            }
+            child{ node [arn_n] {8}
+                child { node [arn_x] {} }
+                child { node [arn_x] {} }
+            }
+        ; 
+        \end{tikzpicture} \\
+    \end{minipage}
+\end{center}
 Continuando a análise da função \enf{rb_insert}, do ponto que interrompemos para entendermos o \enf{rb_rot_esq},
 após esta rotação a esquerda a árvore neste ponto passa para o \enf{caso 3} e a será feito uma rotação a direita
 \enf{z} tem o pai e o avô colorido com preto e vermelho respectivamente e o avô rotacionado a direta.
@@ -548,12 +537,6 @@ tio a direita. O diagrama abaixo representa esta
 \\
 \\
 \\
-\begin{enumerate}
-    \item \enf{z} será root
-    \item tio de \enf{z} vermelho
-    \item tio de \enf{z} preto em forma de triangulo
-    \item tio de \enf{z} preto em forma de linha
-\end{enumerate}
 %%
 %%
 %%  daqui pra frente eh antigo 

commit 0253450d667065c4466451d776141bfeb5ea27c0
Author: Joilnen <joilnen@gmail.com>
Date:   Mon Jan 17 13:26:33 2022 -0300

    documentacao e modificacao do makefile nao precisamos de -lm

diff --git a/doc/tex/mybib.bib b/doc/tex/mybib.bib
index 124a6bf..3dce8ba 100644
--- a/doc/tex/mybib.bib
+++ b/doc/tex/mybib.bib
@@ -1,22 +1,21 @@
 @book{book1,
-   title =     {Computação Gráfica: Imagem},
-   author =    {Jonas Gomes, Luiz Velho},
-   publisher = {SBM},
-   isbn =      {85-244-0088-9},
-   year =      {1994},
+   title =     {Introduction to Algorithms},
+   author =    {Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest and Clifford Stein},
+   publisher = {MIT},
+   isbn =      {978-0-262-03384-8},
+   year =      {2009},
    series =    {},
    edition =   {},
    volume =    {},
    url =       {}}
-
 @book{book2,
-   title =     {A Computational Introduction to Digital Image Processing},
-   author =    {Alasdair McAndrew},
-   publisher = {Taylor and Francis},
-   isbn =      {978-1-4822-4735-0},
-   year =      {2016},
+   title =     {Notas de aula e Slides},
+   author =    {Prof. Luciana Lee},
+   publisher = {},
+   isbn =      {},
+   year =      {},
    series =    {},
-   edition =   {Second},
+   edition =   {},
    volume =    {},
    url =       {}}
 
diff --git a/doc/tex/relatorio.bbl b/doc/tex/relatorio.bbl
new file mode 100644
index 0000000..a5d28bf
--- /dev/null
+++ b/doc/tex/relatorio.bbl
@@ -0,0 +1,12 @@
+\begin{thebibliography}{1}
+
+\bibitem{book2}
+Prof.~Luciana Lee.
+\newblock {\em Notas de aula e Slides}.
+
+\bibitem{book1}
+Ronald L.~Rivest Thomas H.~Cormen, Charles E.~Leiserson and Clifford Stein.
+\newblock {\em Introduction to Algorithms}.
+\newblock MIT, 2009.
+
+\end{thebibliography}
diff --git a/doc/tex/relatorio.blg b/doc/tex/relatorio.blg
new file mode 100644
index 0000000..ffbec2b
--- /dev/null
+++ b/doc/tex/relatorio.blg
@@ -0,0 +1,49 @@
+This is BibTeX, Version 0.99d (TeX Live 2021/Arch Linux)
+Capacity: max_strings=200000, hash_size=200000, hash_prime=170003
+The top-level auxiliary file: relatorio.aux
+The style file: plain.bst
+Database file #1: mybib.bib
+Warning--empty publisher in book2
+Warning--empty year in book2
+You've used 2 entries,
+            2118 wiz_defined-function locations,
+            505 strings with 4157 characters,
+and the built_in function-call counts, 483 in all, are:
+= -- 38
+> -- 20
+< -- 0
++ -- 8
+- -- 6
+* -- 27
+:= -- 88
+add.period$ -- 5
+call.type$ -- 2
+change.case$ -- 7
+chr.to.int$ -- 0
+cite$ -- 4
+duplicate$ -- 24
+empty$ -- 45
+format.name$ -- 6
+if$ -- 97
+int.to.chr$ -- 0
+int.to.str$ -- 2
+missing$ -- 4
+newline$ -- 12
+num.names$ -- 4
+pop$ -- 20
+preamble$ -- 1
+purify$ -- 7
+quote$ -- 0
+skip$ -- 12
+stack$ -- 0
+substring$ -- 10
+swap$ -- 2
+text.length$ -- 0
+text.prefix$ -- 0
+top$ -- 0
+type$ -- 4
+warning$ -- 2
+while$ -- 4
+width$ -- 3
+write$ -- 19
+(There were 2 warnings)
diff --git a/doc/tex/relatorio.pdf b/doc/tex/relatorio.pdf
index eaff269..8f819fd 100644
Binary files a/doc/tex/relatorio.pdf and b/doc/tex/relatorio.pdf differ
diff --git a/doc/tex/relatorio.tex b/doc/tex/relatorio.tex
index 925b6ff..33b80d7 100644
--- a/doc/tex/relatorio.tex
+++ b/doc/tex/relatorio.tex
@@ -11,6 +11,66 @@
 \usepackage{xcolor}
 \usepackage{booktabs}
 \usepackage[most]{tcolorbox}
+\usepackage[edges]{forest}
+\definecolor{folderbg}{RGB}{124,166,198}
+\definecolor{folderborder}{RGB}{110,144,169}
+\newlength\Size
+\setlength\Size{4pt}
+\tikzset{%
+  folder/.pic={%
+    \filldraw [draw=folderborder, top color=folderbg!50, bottom color=folderbg] (-1.05*\Size,0.2\Size+5pt) rectangle ++(.75*\Size,-0.2\Size-5pt);
+    \filldraw [draw=folderborder, top color=folderbg!50, bottom color=folderbg] (-1.15*\Size,-\Size) rectangle (1.15*\Size,\Size);
+  },
+  file/.pic={%
+    \filldraw [draw=folderborder, top color=folderbg!5, bottom color=folderbg!10] (-\Size,.4*\Size+5pt) coordinate (a) |- (\Size,-1.2*\Size) coordinate (b) -- ++(0,1.6*\Size) coordinate (c) -- ++(-5pt,5pt) coordinate (d) -- cycle (d) |- (c) ;
+  },
+}
+\forestset{%
+  declare autowrapped toks={pic me}{},
+  declare boolean register={pic root},
+  pic root=0,
+  pic dir tree/.style={%
+    for tree={%
+      folder,
+      font=\ttfamily,
+      grow'=0,
+    },
+    before typesetting nodes={%
+      for tree={%
+        edge label+/.option={pic me},
+      },
+      if pic root={
+        tikz+={
+          \pic at ([xshift=\Size].west) {folder};
+        },
+        align={l}
+      }{},
+    },
+  },
+  pic me set/.code n args=2{%
+    \forestset{%
+      #1/.style={%
+        inner xsep=2\Size,
+        pic me={pic {#2}},
+      }
+    }
+  },
+  pic me set={directory}{folder},
+  pic me set={file}{file},
+}
+
+\def\Size{4pt}
+\tikzset{
+  folder/.pic={
+    \filldraw[draw=folderborder,top color=folderbg!50,bottom color=folderbg]
+      (-1.05*\Size,0.2\Size+5pt) rectangle ++(.75*\Size,-0.2\Size-5pt);  
+    \filldraw[draw=folderborder,top color=folderbg!50,bottom color=folderbg]
+      (-1.15*\Size,-\Size) rectangle (1.15*\Size,\Size);
+  },
+  file/.pic={%
+    \filldraw [draw=folderborder, top color=folderbg!5, bottom color=folderbg!10] (-\Size,.4*\Size+5pt) coordinate (a) |- (\Size,-1.2*\Size) coordinate (b) -- ++(0,1.6*\Size) coordinate (c) -- ++(-5pt,5pt) coordinate (d) -- cycle (d) |- (c) ;
+  },
+}
 
 \newtcolorbox[blend into=tables]{mytable}[2][]{%
     enhanced,
@@ -22,9 +82,9 @@
         xshift=5mm, 
         yshift=-\tcboxedtitleheight/2, 
         yshifttext=-1mm},
-    boxed title style={colback=blue!50, sharp corners},
-    colframe = blue!50,
-    colback = blue!20,  
+    boxed title style={colback=blue!30, sharp corners},
+    colframe = gray,
+    colback = blue!20, boxrule = 0.5pt,
     % overlay = {\node[text=white, fill=red] at (frame.east) 
     %     {$\clubsuit$};},
     #1}
@@ -123,6 +183,32 @@ da atividade conjunto ordenado \\
 \small
 \section {Introdução}
 \noindent Esta biblioteca é composta pelo os seguintes arquivos, \\
+\begin{tcolorbox}[boxrule = 0.5pt]
+\begin{center}
+    \scalebox{0.6}{
+\begin{forest}
+  pic dir tree,
+  pic root,
+  for tree={% folder icons by default; override using file for file icons
+    directory,
+  },
+  [conjunto_ordenado
+    [doc
+        [relatorio.pdf, file]
+        [spec.txt, file]
+    ]
+    [src
+    ]
+    [tests
+    ]
+    [LEIAME, file]
+    [makefile, file]
+  ]
+\end{forest}
+}
+\end{center}
+\end{tcolorbox}
+\noindent Em \enf{src} estão os arquivos específicos da biblioteca\\
 \begin{itemize}
     \item [$\blacksquare$] conjunto\_ordenado.h
     \item [$\blacksquare$] conjunto\_ordenado.c
@@ -131,7 +217,7 @@ da atividade conjunto ordenado \\
     \item [$\blacksquare$] jcurses.h 
 \end{itemize}
 
-\noindent Completamente separado do código da biblioteca temos alguns arquivos que implementam 
+\noindent Completamente separado do código da biblioteca, ainda em \enf{src} temos alguns arquivos que implementam 
 testes, estes são:
 \begin{itemize}
     \item [$\blacksquare$] main.c
@@ -141,6 +227,11 @@ testes, estes são:
     \item [$\blacksquare$] testa_rb.c
 \end{itemize}
 
+\noindent Arquivo de menu auxiliar nos testes:
+\begin{itemize}
+    \item [$\blacksquare$] checklist.c
+\end{itemize}
+
 Todos os arquivos estão listados nos anexos na sua íntegra.
 
 Como foi implementado um número grande de testes, estes foram separados em quatro
@@ -282,8 +373,9 @@ que aponta para o filho esquerdo.
 \enf{while}, o primeiro \enf{if} decide se está sendo incluído pelo o lado esquerdo,
 linhas 99-106, temos o tratamento do \enf{caso 1}, nó pai vermelho, e nó tio vermelho,
 segue um diagrama deste caso em nome da clereza.\\
-\begin{center}
+\begin{tcolorbox} [boxrule = 0.5pt]
     \begin{minipage}{.95\textwidth}
+        \centering
         \begin{tikzpicture}[->,>=stealth',level/.style={sibling distance = 2.5cm/#1,
           level distance = .5cm}] 
         \node [arn_n] {}
@@ -348,7 +440,8 @@ segue um diagrama deste caso em nome da clereza.\\
         ; 
         \end{tikzpicture}
     \end{minipage}
-\end{center}
+\end{tcolorbox}
+
 Note que saímos do \enf{caso 1} e caímos no \enf{caso 2}, nó pai do nó agora 
 apontado por \enf{z}, vermelho e nó tio preto \enf{y}, em formato de triângulo,
 lembre-se que estamos dentro de um \enf{while} em loop enquanto a cor do pai de 
@@ -396,8 +489,9 @@ do lado esquerdo reagrupando os nós, vejamos detalhadamente como.\\
 \noindent Um diagrama em nome da clareza, claro que aqui está reprensentado apenas os nós
 que são representativos de uma rotação a esquerda e não árvores completas.\\
 
-\begin{center}
+\begin{tcolorbox}[boxrule = 0.5pt, colframe = gray]
     \begin{minipage}{.95\textwidth}
+        \centering
         \begin{tikzpicture}[->,>=stealth',level/.style={sibling distance = 2.5cm/#1,
           level distance = .5cm}] 
         \node [arn_n] {x}
@@ -438,7 +532,7 @@ que são representativos de uma rotação a esquerda e não árvores completas.\
         ; 
         \end{tikzpicture} \\
     \end{minipage}
-\end{center}
+\end{tcolorbox}
 Continuando a análise da função \enf{rb_insert}, do ponto que interrompemos para entendermos o \enf{rb_rot_esq},
 após esta rotação a esquerda a árvore neste ponto passa para o \enf{caso 3} e a será feito uma rotação a direita
 \enf{z} tem o pai e o avô colorido com preto e vermelho respectivamente e o avô rotacionado a direta.
@@ -669,19 +763,34 @@ Variavel rb\_n com nome y \ref{14}
 % \lstinputlisting {code/del.c}
 % \lstinputlisting {code/utils.c}
 
-\section {TAD}
-\begin{figure}[H]
-    \begin{center}
-    \includegraphics [scale = .4] {figs/ADT}
-        \caption{Diagrama TAD}
-    \end{center}
-\end{figure}
-
-\section{Referências Bibliográficas}
+\section{}
 \nocite{*}
 \bibliography{mybib.bib}{}
 \bibliographystyle{plain}
-\href{https://www.geeksforgeeks.org/abstract-data-types/} {Diagrama TAD - \color{blue} https://www.geeksforgeeks.org/abstract-data-types/}
+
+\section {Apêndices}
+\appendix
+\section{builder}
+\lstinputlisting [caption = {makefile}] {../../src/makefile}
+\section{fontes}
+\setcounter{lstlisting}{0}
+\lstinputlisting [caption = {checklist.h}] {../../src/checklist.h} 
+\lstinputlisting [caption = {checklist.c}] {../../src/checklist.c} 
+\lstinputlisting [caption = {conjunto_ordenado.h}] {../../src/conjunto_ordenado.h} 
+\lstinputlisting [caption = {conjunto_ordenado.c}] {../../src/conjunto_ordenado.c} 
+\lstinputlisting [caption = {jcurses.h}] {../../src/jcurses.h} 
+\lstinputlisting [caption = {main.c}] {../../src/main.c} 
+\lstinputlisting [caption = {red_black.h}] {../../src/red_black.h} 
+\lstinputlisting [caption = {red_black.c}] {../../src/red_black.c} 
+\lstinputlisting [caption = {testa.h}] {../../src/testa.h} 
+\lstinputlisting [caption = {testa_item_1.h}] {../../src/testa_item_1.h} 
+\lstinputlisting [caption = {testa_item_1.c}] {../../src/testa_item_1.c} 
+\lstinputlisting [caption = {testa_item_2.h}] {../../src/testa_item_2.h} 
+\lstinputlisting [caption = {testa_item_2.c}] {../../src/testa_item_2.c} 
+\lstinputlisting [caption = {testa_item_3.h}] {../../src/testa_item_3.h} 
+\lstinputlisting [caption = {testa_item_3.c}] {../../src/testa_item_3.c} 
+\lstinputlisting [caption = {testa_rb.h}] {../../src/testa_rb.h} 
+\lstinputlisting [caption = {testa_rb.c}] {../../src/testa_rb.c} 
 
 \end {document}
 
diff --git a/doc/tex/t.pdf b/doc/tex/t.pdf
new file mode 100644
index 0000000..c3c8c30
Binary files /dev/null and b/doc/tex/t.pdf differ
diff --git a/doc/tex/t.tex b/doc/tex/t.tex
new file mode 100644
index 0000000..42126b2
--- /dev/null
+++ b/doc/tex/t.tex
@@ -0,0 +1,28 @@
+\documentclass[border=10pt,multi,tikz]{standalone}
+\begin{document}
+
+\begin{forest}
+  pic dir tree,
+  pic root,
+  for tree={% folder icons by default; override using file for file icons
+    directory,
+  },
+  [system
+    [config
+    ]
+    [lib
+      [Access
+      ]
+      [Plugin
+      ]
+      [file.txt, file
+      ]
+    ]
+    [templates
+    ]
+    [tests
+    ]
+  ]
+\end{forest}
+\end{document}
+
diff --git a/doc/tex/table.pdf b/doc/tex/table.pdf
index f7e3592..75557d4 100644
Binary files a/doc/tex/table.pdf and b/doc/tex/table.pdf differ
diff --git a/doc/tex/table.tex b/doc/tex/table.tex
index 4a270ee..eaaea13 100644
--- a/doc/tex/table.tex
+++ b/doc/tex/table.tex
@@ -22,6 +22,12 @@
 \begin{document}
 \listoftables
 
+\noindent\hrulefill\par
+\noindent\makebox[\textwidth][c]{%
+    \begin{minipage}{1.5\textwidth}
+        \hrulefill\par
+    \end{minipage}}
+
 \begin{table}
 \centering
 \begin{tabular}{|r|l|}
diff --git a/src/makefile b/src/makefile
index 064af43..2ddd9d1 100644
--- a/src/makefile
+++ b/src/makefile
@@ -13,7 +13,7 @@ D=-g
 .c.o:
 	$(C) -c $(D) $<
 all: $(O) 
-	$(C) -o $(E) $(O) -lm
+	$(C) -o $(E) $(O)
 clean:
 	rm -f *.o $(E)
 

commit 18975f4aa53f3ba697d915f9027294f268d43ce8
Author: Joilnen <joilnen@gmail.com>
Date:   Mon Jan 17 16:52:17 2022 -0300

    adequando o código ao estilo escolhido e melhorando a documentação
    adequando o codigo ao estilo escolhido e documentando

diff --git a/doc/tex/relatorio.pdf b/doc/tex/relatorio.pdf
index 8f819fd..7299cab 100644
Binary files a/doc/tex/relatorio.pdf and b/doc/tex/relatorio.pdf differ
diff --git a/doc/tex/relatorio.tex b/doc/tex/relatorio.tex
index 33b80d7..fad64d1 100644
--- a/doc/tex/relatorio.tex
+++ b/doc/tex/relatorio.tex
@@ -32,7 +32,7 @@
   pic dir tree/.style={%
     for tree={%
       folder,
-      font=\ttfamily,
+      font=\normalsize,
       grow'=0,
     },
     before typesetting nodes={%
@@ -322,14 +322,104 @@ populamos com chave e o dado genérico, também setamos a cor preta, pois é ra
 ponteiros, pai, e filhos para nó sentinela \enf{rb_s}, por fim retornamos o nó raiz criado.
 
 Antes de passarmos para o \enf{rb_insert}, vamos dar uma olha na estrutura nó \enf{rb_n}
-\lstinputlisting [firstnumber=33, linerange={33-48}, caption = {Fragmento do red_black.h}]{../../src/red_black.h},
+\lstinputlisting [firstnumber=33, linerange={33-49}, caption = {Fragmento do red_black.h}]{../../src/red_black.h},
 trata-se da estrutura que abstrai um nó da árvore, comentário no código fonte descreve cada parâmentro.
 
 Então a função \enf{rb_insert} que insere um novo nó na árvore, detalharemos agora 
-o funcionanmento desta função.
+o funcionanmento desta função, porém  antes vejamos a função de rotação que é chamada na inserção,
+uma rotação a esquerda, vamos aproveitar para analizarmos o que faz esta função.
+\lstinputlisting [firstnumber=319, linerange={319-342}, caption = {Fragmento do red_black.c}]{../../src/red_black.c}
+Esta função \enf{rb_rot_esq}, basicamente diminui a altura do lado direito e aumenta
+do lado esquerdo reagrupando os nós, vejamos detalhadamente como.\\
+
+\begin{mytable}[colback=black!5]{rotação à esquerda}
+    \scriptsize
+\begin{tabular}{|l|l|}
+    \hline 
+    327 & guarda referência do filho a direita \\
+    \hline 
+    328 & faz filho a direita igual a neto a esquerda (dimininuíndo a altura direita) \\
+    \hline 
+    329 & se filho a direita (antigo neto a esquerda) não é sentinela \\
+    \hline 
+    330 & atualiza pai de filho a direita (antigo neto a esquerda)\\
+    \hline 
+    331 & atualiza pai do nó movido\\
+    \hline 
+    332 & testa se nó anterior era raiz \\
+    \hline 
+    333 & atualiza nó raiz \\
+    \hline 
+    334 & se não é raiz testa se é nó a esquerda\\
+    \hline 
+    335 & atualiza como nó a esquerda\\
+    \hline 
+    336 & se nenhuma das opções anteriores\\
+    \hline 
+    337 & atualiza como nó a direita\\
+    \hline 
+    338 & atualiza filho a esquerda de y igual x, note que o nó x que era pai passa a ser filho\\
+    \hline 
+    339 & atualiza pai de x igual de y \\
+    \hline 
+    341 & retorna inteiro para uso em testes (não utilizado neste trabalho, mas a função tem esta inferface)\\
+    \hline
+\end{tabular}
+\end{mytable}
+
+\noindent Um diagrama em nome da clareza, claro que aqui está reprensentado apenas os nós
+que são representativos de uma rotação a esquerda e não árvores completas.\\
+
+\begin{tcolorbox}[boxrule = 0.5pt, colframe = gray]
+    \begin{minipage}{.95\textwidth}
+        \centering
+        \begin{tikzpicture}[->,>=stealth',level/.style={sibling distance = 2.5cm/#1,
+          level distance = .5cm}] 
+        \node [arn_n] {x}
+            child{ node [arn_n] {1}
+                child { node [arn_x] {} }
+                child { node [arn_x] {} }
+            }
+            child{ node [arn_n] {y}
+                child{ node [arn_r] {5}
+                    child { node [arn_x] {} }
+                    child { node [arn_x] {} }
+                }
+                child{ node [arn_r] {8}
+                    child { node [arn_x] {} }
+                    child { node [arn_x] {} }
+                }
+            }
+        ; 
+        \end{tikzpicture} 
+        \colorbox{BurntOrange}{\scriptsize após \enf{rb_rot_esq} }
+        \begin{tikzpicture}[->,>=stealth',level/.style={sibling distance = 2.5cm/#1,
+          level distance = .5cm}] 
+        \node [arn_n] {y}
+            child{ node [arn_n] {x}
+                child{ node [arn_r] {1}
+                    child { node [arn_x] {} }
+                    child { node [arn_x] {} }
+                }
+                child{ node [arn_r] {5}
+                    child { node [arn_x] {} }
+                    child { node [arn_x] {} }
+                }
+            }
+            child{ node [arn_n] {8}
+                child { node [arn_x] {} }
+                child { node [arn_x] {} }
+            }
+        ; 
+        \end{tikzpicture}
+    \end{minipage}
+\end{tcolorbox}
+\ \\
+\ \\
+\noindent Podemos agora entender melhor o funcionamento da função \enf{rb_insert}.
 \lstinputlisting [firstnumber=43, linerange={43-145}, caption = {Fragmento do red_black.c}]{../../src/red_black.c}
 
-Consideremos estes 4 casos bases:
+Consideremos estes 4 casos bases, sendo \enf{z} o nó a ser incluído e \enf{t}, o nó raíz:
 \begin{center}
     \begin{minipage}{0.4\textwidth}
 \begin{enumerate}
@@ -445,192 +535,126 @@ segue um diagrama deste caso em nome da clereza.\\
 Note que saímos do \enf{caso 1} e caímos no \enf{caso 2}, nó pai do nó agora 
 apontado por \enf{z}, vermelho e nó tio preto \enf{y}, em formato de triângulo,
 lembre-se que estamos dentro de um \enf{while} em loop enquanto a cor do pai de 
-\enf{z} for vermelha. Este segundo caso é tratado no \enf{if} 109-113, onde há 
-uma rotação a esquerda, vamos aproveitar para analizarmos o que faz esta função.
-\lstinputlisting [firstnumber=319, linerange={319-342}, caption = {Fragmento do red_black.c}]{../../src/red_black.c}
-Esta função \enf{rb_rot_esq}, basicamente diminui a altura do lado direito e aumenta
-do lado esquerdo reagrupando os nós, vejamos detalhadamente como.\\
-
-\begin{mytable}[colback=black!5]{rotação à esquerda}
-    \scriptsize
-\begin{tabular}{|l|l|}
-    \hline 
-    327 & guarda referência do filho a direita \\
-    \hline 
-    328 & faz filho a direita igual a neto a esquerda (dimininuíndo a altura direita) \\
-    \hline 
-    329 & se filho a direita (antigo neto a esquerda) não é sentinela \\
-    \hline 
-    330 & atualiza pai de filho a direita (antigo neto a esquerda)\\
-    \hline 
-    331 & atualiza pai do nó movido\\
-    \hline 
-    332 & testa se nó anterior era raiz \\
-    \hline 
-    333 & atualiza nó raiz \\
-    \hline 
-    334 & se não é raiz testa se é nó a esquerda\\
-    \hline 
-    335 & atualiza como nó a esquerda\\
-    \hline 
-    336 & se nenhuma das opções anteriores\\
-    \hline 
-    337 & atualiza como nó a direita\\
-    \hline 
-    338 & atualiza filho a esquerda de y igual x, note que o nó x que era pai passa a ser filho\\
-    \hline 
-    339 & atualiza pai de x igual de y \\
-    \hline 
-    341 & retorna inteiro para uso em testes (não utilizado neste trabalho, mas a função tem esta inferface)\\
-    \hline
-\end{tabular}
-\end{mytable}
-
-\noindent Um diagrama em nome da clareza, claro que aqui está reprensentado apenas os nós
-que são representativos de uma rotação a esquerda e não árvores completas.\\
-
-\begin{tcolorbox}[boxrule = 0.5pt, colframe = gray]
+\enf{z} for vermelha. Este segundo caso é tratado no \enf{if} 109-113, 
+\begin{tcolorbox} [boxrule = 0.5pt]
     \begin{minipage}{.95\textwidth}
         \centering
         \begin{tikzpicture}[->,>=stealth',level/.style={sibling distance = 2.5cm/#1,
           level distance = .5cm}] 
-        \node [arn_n] {x}
-            child{ node [arn_n] {1}
-                child { node [arn_x] {} }
-                child { node [arn_x] {} }
-            }
-            child{ node [arn_n] {y}
-                child{ node [arn_r] {5}
+        \node [arn_n] {}
+            child{ node [arn_r] {}
+                child{ node [arn_n] {} 
                     child { node [arn_x] {} }
                     child { node [arn_x] {} }
                 }
-                child{ node [arn_r] {8}
+                child{ node [arn_r] {z} 
+                    child{ node [arn_n] {} 
+                        child{ node [arn_r] {} 
+                            child { node [arn_x] {} }
+                            child { node [arn_x] {} }
+                        }
+                        child { node [arn_x] {} }
+                    }
+                    child{ node [arn_n] {} 
+                        child { node [arn_x] {} }
+                        child { node [arn_x] {} }
+                    }
+                }
+            }
+            child{ node [arn_n] {y}
+                child { node [arn_x] {} }
+                child{ node [arn_r] {}
                     child { node [arn_x] {} }
                     child { node [arn_x] {} }
                 }
             }
         ; 
-        \end{tikzpicture} 
-        \colorbox{BurntOrange}{\scriptsize após \enf{rb_rot_esq} }
+        \end{tikzpicture}
+        \colorbox{BurntOrange}{\scriptsize após o \enf{if} nas linhas, 99-106 }
         \begin{tikzpicture}[->,>=stealth',level/.style={sibling distance = 2.5cm/#1,
           level distance = .5cm}] 
-        \node [arn_n] {y}
-            child{ node [arn_n] {x}
-                child{ node [arn_r] {1}
+        \node [arn_n] {}
+            child{ node [arn_r] {}
+                child{ node [arn_n] {} 
                     child { node [arn_x] {} }
                     child { node [arn_x] {} }
                 }
-                child{ node [arn_r] {5}
-                    child { node [arn_x] {} }
-                    child { node [arn_x] {} }
+                child{ node [arn_r] {z} 
+                    child{ node [arn_n] {} 
+                        child{ node [arn_r] {} 
+                            child { node [arn_x] {} }
+                            child { node [arn_x] {} }
+                        }
+                        child { node [arn_x] {} }
+                    }
+                    child{ node [arn_n] {} 
+                        child { node [arn_x] {} }
+                        child { node [arn_x] {} }
+                    }
                 }
             }
-            child{ node [arn_n] {8}
-                child { node [arn_x] {} }
+            child{ node [arn_n] {y}
                 child { node [arn_x] {} }
+                child{ node [arn_r] {}
+                    child { node [arn_x] {} }
+                    child { node [arn_x] {} }
+                }
             }
         ; 
-        \end{tikzpicture} \\
+        \end{tikzpicture}
     \end{minipage}
 \end{tcolorbox}
-Continuando a análise da função \enf{rb_insert}, do ponto que interrompemos para entendermos o \enf{rb_rot_esq},
-após esta rotação a esquerda a árvore neste ponto passa para o \enf{caso 3} e a será feito uma rotação a direita
-\enf{z} tem o pai e o avô colorido com preto e vermelho respectivamente e o avô rotacionado a direta.
-Repetindo aqui o fragmento do código anterior \enf{rb_insert}, trata o \enf{caso 3} linhas 114-116.
-\lstinputlisting [firstnumber=97, linerange={97-118}, caption = {Fragmento do red_black.c}]{../../src/red_black.c}
-\begin{mytable}[colback=black!5]{caso 3}
+\begin{mytable}[colback=black!5]{caso 2}
     \scriptsize
 \begin{tabular}{|l|l|}
     \hline 
-    114 & colore pai de \enf{z} com preto \\
+    110 & checa se \enf{z} é nó a direita \\
     \hline 
-    115 & colore avô de \enf{z} com vermelho \\
+    111 & colore avô de \enf{z} com vermelho \\
     \hline 
     116 & rotaciona avô à direita \\
     \hline 
 \end{tabular}
 \end{mytable}
-Aqui temos a parte mais importante da inclusão, se o nó pai do nó incluído \enf{z}
-é nó a esquerda, ou seja filho a esquerda do avô, fazemos \enf{y} apontar para o nó
-tio a direita. O diagrama abaixo representa esta 
-Detalhando, variável \enf{x} é uma variável que itera sobre os nós da árvore ela começa sendo igual 
-ao nó raiz, \enf{y} é uma variável que aponta para pai, pois a lógica dessa rotina é ir rastrando
-nó e seu pai, como a condição incial é o nó raiz, a \enf{x} aponta para raiz e a \enf{y} aponta
-para o nó sentinela, consideremos os casos possíveis, caso um,  o nó raiz não existe ou seja é 
-igual a sentinela e estamos incluíndo o primeiro nó que se tornará o raiz, neste caso 
-o primeiro \enf{while} não é executado pois a \enf{x} apontará para \enf{rb_s} (sentinela),
-como \enf{y} rastrea o pai, ela aponta também para sentinela, e fazemos o nó incluído apontar
-o ponteiro pai para o sentinela através \enf{z->p = y}, caso neste ponto a \enf{y} continua
-apontando para sentinela significa que temos apenas um nó sendo tradado, logo fazemos este nó
-raiz na linha \enf{*t = z}, posteriormente fazemos ponteiros pai e filhos apontarem para sentinela
-e colorimos de vermelho, neste ponto você pode perguntar, mas se ele é o raiz não deveria ser 
-preto, verdade, é que essa linha é feita com vistas aos casos mais comuns que são a inserção 
-de nós não raiz, que é tratado no \enf{while} seguinte, a cor será alterado para preto, no 
-final da função pelo o ponteiro \enf{t} na linha \enf{(*t)->c = BLACK}, ou seja ao final 
-da função ela sempre pinta o nó raíz de preto.
-
-Caso dois, neste o nó inserido não é o primeiro, o primeiro \enf{while} itera pelo nó raiz,
-através dos ponteiros para o(s) filho(s) a direita ou a esqueda de acordo com a comparação
-das chaves, dos nós visitados e do nó sendo incluído, note que neste ponto, é feito 
-a crítca se as chaves são iguais, como a especificação proíbe chaves iguais, ele retorna 
-código de erro após o \enf{else} ou finaliza quando a \enf{x} apontar para o sentinela
-que neste caso representa um nó folha, a \enf{y} apontará para o pai deste nó, estnó 
-fora é o ponto que será incluído o novo nó, na linha \enf{z->p = y}, enquando o primeiro 
-\enf{if} setou as variáveis \enf{x} e \enf{y}, o segundo \enf{if}, inclui o novo nó
-\enf{z} no lado esquerdo ou direito de \enf{y}, aponta os filhos desde nó para sentinela
-e colore com vermelho, que é a ação mais comum.
-
-Todas as inclusões entram numa etapa, o segndo \enf{while}, que chamei de \enf{ajuste}
-na bibliografia é referiad como \enf{fixup}, esta parte do código raz o ajuste de coloração 
-e rotaciona nós para manter as propriedades da árvore red-black obedecidas.
-O primeiro \enf{if} dentro deste segundo \enf{while}.
-
-Aqui temos a parte mais importante da inclusão, se o nó pai do nó incluído \enf{z}
-é nó a esquerda, ou seja filho a esquerda do avô, fazemos \enf{y} apontar para o nó
-tio a direita. O diagrama abaixo representa esta 
-
-%
-%
-%
-\begin{tikzpicture}[->,>=stealth',level/.style={sibling distance = 2.5cm/#1,
-  level distance = 1cm}] 
-\node [arn_r] {}
-    child{ node [arn_n] {} 
-            child{ node [arn_r] {z} 
-            	child{ node [arn_x] {}}
-				child{ node [arn_x] {}}
-            }
-            child{ node [arn_x] {}}                            
-    }
-    child{ node [arn_n] {}
-        child { node [arn_x] {} }
-        child { node [arn_x] {} }
-    }
-; 
-\end{tikzpicture}
-\colorbox{BurntOrange}{após o \enf{else} nas linhas, 107-117 }
-\begin{tikzpicture}[->,>=stealth',level/.style={sibling distance = 2.5cm/#1,
-  level distance = 1cm}] 
-\node [arn_n] {}
-    child{ node [arn_n] {} 
-            child{ node [arn_r] {z} 
-            	child{ node [arn_x] {}}
-				child{ node [arn_x] {}}
-            }
-            child{ node [arn_x] {}}                            
-    }
-    child{ node [arn_n] {}
-        child { node [arn_x] {} }
-        child { node [arn_x] {} }
-    }
-; 
-\end{tikzpicture}
-\\
-\\
-\\
-\\
-\\
-\\
+% Aqui temos a parte mais importante da inclusão, se o nó pai do nó incluído \enf{z}
+% é nó a esquerda, ou seja filho a esquerda do avô, fazemos \enf{y} apontar para o nó
+% tio a direita. O diagrama abaixo representa esta 
+% Detalhando, variável \enf{x} é uma variável que itera sobre os nós da árvore ela começa sendo igual 
+% ao nó raiz, \enf{y} é uma variável que aponta para pai, pois a lógica dessa rotina é ir rastrando
+% nó e seu pai, como a condição incial é o nó raiz, a \enf{x} aponta para raiz e a \enf{y} aponta
+% para o nó sentinela, consideremos os casos possíveis, caso um,  o nó raiz não existe ou seja é 
+% igual a sentinela e estamos incluíndo o primeiro nó que se tornará o raiz, neste caso 
+% o primeiro \enf{while} não é executado pois a \enf{x} apontará para \enf{rb_s} (sentinela),
+% como \enf{y} rastrea o pai, ela aponta também para sentinela, e fazemos o nó incluído apontar
+% o ponteiro pai para o sentinela através \enf{z->p = y}, caso neste ponto a \enf{y} continua
+% apontando para sentinela significa que temos apenas um nó sendo tradado, logo fazemos este nó
+% raiz na linha \enf{*t = z}, posteriormente fazemos ponteiros pai e filhos apontarem para sentinela
+% e colorimos de vermelho, neste ponto você pode perguntar, mas se ele é o raiz não deveria ser 
+% preto, verdade, é que essa linha é feita com vistas aos casos mais comuns que são a inserção 
+% de nós não raiz, que é tratado no \enf{while} seguinte, a cor será alterado para preto, no 
+% final da função pelo o ponteiro \enf{t} na linha \enf{(*t)->c = BLACK}, ou seja ao final 
+% da função ela sempre pinta o nó raíz de preto.
+% 
+% Caso dois, neste o nó inserido não é o primeiro, o primeiro \enf{while} itera pelo nó raiz,
+% através dos ponteiros para o(s) filho(s) a direita ou a esqueda de acordo com a comparação
+% das chaves, dos nós visitados e do nó sendo incluído, note que neste ponto, é feito 
+% a crítca se as chaves são iguais, como a especificação proíbe chaves iguais, ele retorna 
+% código de erro após o \enf{else} ou finaliza quando a \enf{x} apontar para o sentinela
+% que neste caso representa um nó folha, a \enf{y} apontará para o pai deste nó, estnó 
+% fora é o ponto que será incluído o novo nó, na linha \enf{z->p = y}, enquando o primeiro 
+% \enf{if} setou as variáveis \enf{x} e \enf{y}, o segundo \enf{if}, inclui o novo nó
+% \enf{z} no lado esquerdo ou direito de \enf{y}, aponta os filhos desde nó para sentinela
+% e colore com vermelho, que é a ação mais comum.
+% 
+% Todas as inclusões entram numa etapa, o segndo \enf{while}, que chamei de \enf{ajuste}
+% na bibliografia é referiad como \enf{fixup}, esta parte do código raz o ajuste de coloração 
+% e rotaciona nós para manter as propriedades da árvore red-black obedecidas.
+% O primeiro \enf{if} dentro deste segundo \enf{while}.
+% 
+% Aqui temos a parte mais importante da inclusão, se o nó pai do nó incluído \enf{z}
+% é nó a esquerda, ou seja filho a esquerda do avô, fazemos \enf{y} apontar para o nó
+% tio a direita. O diagrama abaixo representa esta 
+% 
 %%
 %%
 %%  daqui pra frente eh antigo 
diff --git a/src/conjunto_ordenado.c b/src/conjunto_ordenado.c
index 79e54c4..703f958 100644
--- a/src/conjunto_ordenado.c
+++ b/src/conjunto_ordenado.c
@@ -24,6 +24,7 @@ conjord *conjord_cria(char *nome)
 
 /**
  * cria conjunto ordenado e retorna o ponteiro para ele
+ * @parm a conjunto ordenando
  */
 void conjord_destroi(conjord *c)
 {
diff --git a/src/red_black.h b/src/red_black.h
index 11f2828..a4143c7 100644
--- a/src/red_black.h
+++ b/src/red_black.h
@@ -40,7 +40,8 @@ typedef enum tipo_screen {TMONO, TCOLOR} tipo_screen;
  * @param r right, ponteiro para filho a direta
  * @param p parent, ponteiro para noh pai
  */
-typedef struct rb_n {
+typedef struct rb_n
+{
     int k;
     unsigned char c:1;
     void *d;
diff --git a/src/testa_item_1.c b/src/testa_item_1.c
index 8d49570..257f24c 100644
--- a/src/testa_item_1.c
+++ b/src/testa_item_1.c
@@ -11,7 +11,8 @@ static void imprime_meu_tipo(void *);
  * @param nome string em c
  * @param telefone string  em c
  */
-typedef struct {
+typedef struct
+{
     char *nome;
     char *telefone;
 } meu_tipo;
diff --git a/src/testa_item_2.c b/src/testa_item_2.c
index af21392..fdf73b4 100644
--- a/src/testa_item_2.c
+++ b/src/testa_item_2.c
@@ -10,7 +10,8 @@
 
 static void imprime_meu_tipo(void *);
 
-typedef struct {
+typedef struct
+{
     char *nome;
     int milhas;
 } meu_tipo2;
diff --git a/src/testa_item_3.c b/src/testa_item_3.c
index c6d0004..a648ccf 100644
--- a/src/testa_item_3.c
+++ b/src/testa_item_3.c
@@ -12,7 +12,8 @@
  */
 static void imprime_meu_tipo(void *);
 
-typedef struct {
+typedef struct
+{
     char letra;
 } meu_tipo3;
 

commit 1a7df6515af6cba566c83666842c4e30ff5c11c4
Author: Joilnen <joilnen@gmail.com>
Date:   Tue Jan 18 01:59:53 2022 -0300

    atualizando o nome do autor, e documentando

diff --git a/doc/tex/relatorio.pdf b/doc/tex/relatorio.pdf
index 7299cab..57c96a7 100644
Binary files a/doc/tex/relatorio.pdf and b/doc/tex/relatorio.pdf differ
diff --git a/doc/tex/relatorio.tex b/doc/tex/relatorio.tex
index fad64d1..88f5221 100644
--- a/doc/tex/relatorio.tex
+++ b/doc/tex/relatorio.tex
@@ -2,11 +2,6 @@
 
 \input{packages}
 \usepackage{fancyvrb}
-% \usepackage{fancyhdr}
-% \pagestyle{fancy}
-
-% \fancyhead{}
-% \fancyfoot{}
 \usepackage{listingsutf8}
 \usepackage{xcolor}
 \usepackage{booktabs}
@@ -90,7 +85,7 @@
     #1}
 
 % \definecolor{codegreen}{rgb}{0,0.6,0}
-\definecolor{codegreen}{rgb}{.6,.3,0}
+\definecolor{codebrown}{rgb}{.6,.3,0}
 \definecolor{codegray}{rgb}{0.5,0.5,0.5}
 \definecolor{codepurple}{rgb}{0.58,0,0.82}
 \definecolor{backcolour}{rgb}{0.95,0.95,0.92}
@@ -100,7 +95,7 @@
 
 \lstdefinestyle{mystyle}{
     backgroundcolor=\color{backcolour},   
-    commentstyle=\color{codegreen},
+    commentstyle=\color{codebrown},
     keywordstyle=\color{magenta},
     numberstyle=\tiny\color{codegray},
     stringstyle=\color{codepurple},
@@ -205,6 +200,27 @@ da atividade conjunto ordenado \\
     [makefile, file]
   ]
 \end{forest}
+\begin{forest}
+  pic dir tree,
+  pic root,
+  for tree={% folder icons by default; override using file for file icons
+    directory,
+  },
+  [src
+    [checklist.h, file]
+    [checklist.c, file]
+    [conjunto_ordenado.h, file]
+    [conjunto_ordenado.c, file]
+    [red_black.h, file]
+    [red_black.c, file]
+    [jcurses.h, file]
+    [main.c, file]
+    [testa_item_1.c, file]
+    [testa_item_2.c, file]
+    [testa_item_3.c, file]
+    [testa_rb.c, file]
+  ]
+\end{forest}
 }
 \end{center}
 \end{tcolorbox}
@@ -570,28 +586,28 @@ lembre-se que estamos dentro de um \enf{while} em loop enquanto a cor do pai de
             }
         ; 
         \end{tikzpicture}
-        \colorbox{BurntOrange}{\scriptsize após o \enf{if} nas linhas, 99-106 }
+        \colorbox{BurntOrange}{\scriptsize após o \enf{if} nas linhas, 110-113}
         \begin{tikzpicture}[->,>=stealth',level/.style={sibling distance = 2.5cm/#1,
           level distance = .5cm}] 
         \node [arn_n] {}
             child{ node [arn_r] {}
-                child{ node [arn_n] {} 
-                    child { node [arn_x] {} }
-                    child { node [arn_x] {} }
-                }
                 child{ node [arn_r] {z} 
                     child{ node [arn_n] {} 
-                        child{ node [arn_r] {} 
+                        child { node [arn_x] {} }
+                        child { node [arn_x] {} }
+                    }
+                    child{ node [arn_n] {} 
+                        child{ node [arn_r] {}
                             child { node [arn_x] {} }
                             child { node [arn_x] {} }
                         }
                         child { node [arn_x] {} }
                     }
-                    child{ node [arn_n] {} 
+                }
+                child{ node [arn_n] {} 
                         child { node [arn_x] {} }
                         child { node [arn_x] {} }
                     }
-                }
             }
             child{ node [arn_n] {y}
                 child { node [arn_x] {} }
@@ -610,56 +626,83 @@ lembre-se que estamos dentro de um \enf{while} em loop enquanto a cor do pai de
     \hline 
     110 & checa se \enf{z} é nó a direita \\
     \hline 
-    111 & colore avô de \enf{z} com vermelho \\
+    111 & faz \enf{z} aponar para nó pai \\
     \hline 
-    116 & rotaciona avô à direita \\
+    112 & rotaciona nó a esquerda troca de lugar com o nó raiz dessa subárvore \\
     \hline 
 \end{tabular}
 \end{mytable}
-% Aqui temos a parte mais importante da inclusão, se o nó pai do nó incluído \enf{z}
-% é nó a esquerda, ou seja filho a esquerda do avô, fazemos \enf{y} apontar para o nó
-% tio a direita. O diagrama abaixo representa esta 
-% Detalhando, variável \enf{x} é uma variável que itera sobre os nós da árvore ela começa sendo igual 
-% ao nó raiz, \enf{y} é uma variável que aponta para pai, pois a lógica dessa rotina é ir rastrando
-% nó e seu pai, como a condição incial é o nó raiz, a \enf{x} aponta para raiz e a \enf{y} aponta
-% para o nó sentinela, consideremos os casos possíveis, caso um,  o nó raiz não existe ou seja é 
-% igual a sentinela e estamos incluíndo o primeiro nó que se tornará o raiz, neste caso 
-% o primeiro \enf{while} não é executado pois a \enf{x} apontará para \enf{rb_s} (sentinela),
-% como \enf{y} rastrea o pai, ela aponta também para sentinela, e fazemos o nó incluído apontar
-% o ponteiro pai para o sentinela através \enf{z->p = y}, caso neste ponto a \enf{y} continua
-% apontando para sentinela significa que temos apenas um nó sendo tradado, logo fazemos este nó
-% raiz na linha \enf{*t = z}, posteriormente fazemos ponteiros pai e filhos apontarem para sentinela
-% e colorimos de vermelho, neste ponto você pode perguntar, mas se ele é o raiz não deveria ser 
-% preto, verdade, é que essa linha é feita com vistas aos casos mais comuns que são a inserção 
-% de nós não raiz, que é tratado no \enf{while} seguinte, a cor será alterado para preto, no 
-% final da função pelo o ponteiro \enf{t} na linha \enf{(*t)->c = BLACK}, ou seja ao final 
-% da função ela sempre pinta o nó raíz de preto.
-% 
-% Caso dois, neste o nó inserido não é o primeiro, o primeiro \enf{while} itera pelo nó raiz,
-% através dos ponteiros para o(s) filho(s) a direita ou a esqueda de acordo com a comparação
-% das chaves, dos nós visitados e do nó sendo incluído, note que neste ponto, é feito 
-% a crítca se as chaves são iguais, como a especificação proíbe chaves iguais, ele retorna 
-% código de erro após o \enf{else} ou finaliza quando a \enf{x} apontar para o sentinela
-% que neste caso representa um nó folha, a \enf{y} apontará para o pai deste nó, estnó 
-% fora é o ponto que será incluído o novo nó, na linha \enf{z->p = y}, enquando o primeiro 
-% \enf{if} setou as variáveis \enf{x} e \enf{y}, o segundo \enf{if}, inclui o novo nó
-% \enf{z} no lado esquerdo ou direito de \enf{y}, aponta os filhos desde nó para sentinela
-% e colore com vermelho, que é a ação mais comum.
-% 
-% Todas as inclusões entram numa etapa, o segndo \enf{while}, que chamei de \enf{ajuste}
-% na bibliografia é referiad como \enf{fixup}, esta parte do código raz o ajuste de coloração 
-% e rotaciona nós para manter as propriedades da árvore red-black obedecidas.
-% O primeiro \enf{if} dentro deste segundo \enf{while}.
-% 
-% Aqui temos a parte mais importante da inclusão, se o nó pai do nó incluído \enf{z}
-% é nó a esquerda, ou seja filho a esquerda do avô, fazemos \enf{y} apontar para o nó
-% tio a direita. O diagrama abaixo representa esta 
-% 
-%%
-%%
-%%  daqui pra frente eh antigo 
-%%
-%%
+\ \\
+\ \\
+Então chega-se ao \enf{caso 3}, \enf{z} em linha com o nó pai, ambos vermelhos e nó tio preto:
+\begin{tcolorbox} [boxrule = 0.5pt]
+    \begin{minipage}{.95\textwidth}
+        \centering
+        \begin{tikzpicture}[->,>=stealth',level/.style={sibling distance = 2.5cm/#1,
+          level distance = .5cm}] 
+        \node [arn_n] {}
+            child{ node [arn_r] {}
+                child{ node [arn_r] {z} 
+                    child{ node [arn_n] {} 
+                        child { node [arn_x] {} }
+                        child { node [arn_x] {} }
+                    }
+                    child{ node [arn_n] {} 
+                        child{ node [arn_r] {}
+                            child { node [arn_x] {} }
+                            child { node [arn_x] {} }
+                        }
+                        child { node [arn_x] {} }
+                    }
+                }
+                child{ node [arn_n] {} 
+                        child { node [arn_x] {} }
+                        child { node [arn_x] {} }
+                    }
+            }
+            child{ node [arn_n] {y}
+                child { node [arn_x] {} }
+                child{ node [arn_r] {}
+                    child { node [arn_x] {} }
+                    child { node [arn_x] {} }
+                }
+            }
+        ; 
+        \end{tikzpicture}
+        \colorbox{BurntOrange}{\scriptsize após as linhas 114-116}
+        \begin{tikzpicture}[->,>=stealth',level/.style={sibling distance = 2.5cm/#1,
+          level distance = .5cm}] 
+        \node [arn_n] {}
+            child{ node [arn_r] {z}
+                child{ node [arn_n] {} 
+                        child { node [arn_x] {} }
+                        child { node [arn_x] {} }
+                }
+                child{ node [arn_n] {} 
+                    child{ node [arn_r] {} 
+                            child { node [arn_x] {} }
+                            child { node [arn_x] {} }
+                    }
+                    child { node [arn_x] {} }
+                }
+            }
+            child{ node [arn_r] {} 
+                child{ node [arn_n] {} 
+                        child { node [arn_x] {} }
+                        child { node [arn_x] {} }
+                }
+                child{ node [arn_n] {y} 
+                   child { node [arn_x] {} }
+                    child{ node [arn_r] {} 
+                            child { node [arn_x] {} }
+                            child { node [arn_x] {} }
+                    }
+                }
+            }
+        ; 
+        \end{tikzpicture}
+    \end{minipage}
+\end{tcolorbox}
 \enf{conjunto_ordenado.h} é o arquivo cabeçalho que deverá ser incluído no código 
 fonte do cliente, \enf{conjunto_ordenado.c} onde estão implementados as funções,
 \enf{red_black.h} e \enf{red_black.c}, cabeçalho e implementações da estrutura
@@ -718,75 +761,6 @@ referenciada no ato da criação do nó raiz no código cliente, logo no exemplo
 temos uma árvore nomeada \enf{conjunto_a}, enquanto nós filhos nessa árvore é adicionado 
 com \enf{insere_elemento}
 \ \\
-
-\noindent Estrutura principal
-\begin{lstlisting}[caption={Nó Red Black}]
-/**
- * composicao do noh da RB
- * @rb_n noh red black
- * @k chave (k de key)
- * @c cor (c de color ou cor, 0-black, 1-red)
- * @d dado (de de data ou dados)
- * @l @r @p l-eft filho a esquerda, r-ight filho a direta e p-arent, noh pai
- */
-typedef struct rb_n {
-    int k;
-    char c:1;
-    void *d;
-    struct rb_n *l, *r, *p;
-} rb_n;
-\end{lstlisting}
-Significado dos componentes da estrutura \enf{rb_n}
-\begin{itemize}
-    \item \enf{k} - chave
-    \item \enf{c} - cor (0 - preto e 1 - vermelho, apenas o primeiro bit utilizado)
-    \item \enf{d} - dado generico
-    \item \enf{l, r, p} - ponteiro para filho a esquerda, filho a direita e nó pai
-\end{itemize}
-Funções que manipulam os nós na Árvore
-\begin{lstlisting}[language=c, caption={Funções da biblioteca}]
-/**
- * cria o primeiro noh, o raiz da arvore rb
- * serah o primeiro elemento criado na arvore
- * e o primeiro do conjunto ordenado
- */
-#define CRIA_CONJUNTO_ORDENDADO(a, key, dado) \
-    rb_n a; \
-    a.k = key; \
-    a.c = 0; \
-    a.d = &dado; \
-    a.p = a.l = a.r = NULL;
-int imprime_conjunto(rb_n *a);
-unsigned int cardinalidade(rb_n *a);
-int ta_vazio(rb_n *a);
-int limpa_conjunto(rb_n *a);
-
-int insere_elemento(rb_n *a, int k, void *e);
-int exclui_elemento(rb_n *a, int k);
-int verifica_pertencimento(rb_n *a, int k);
-int imprime_arvore(rb_n *a, short h);
-
-rb_n* intersecta_conjuntos(rb_n *a, rb_n *b);
-rb_n* une_conjuntos(rb_n *a, rb_n *b);
-rb_n* subtrai_conjuntos(rb_n *a, rb_n *b);
-
-int destroi_conjunto(rb_n *a);
-
-int troca_cor(rb_n *a);
-int rotaciona_esquerda(rb_n *r, rb_n *w);
-int rotaciona_direita(rb_n *r, rb_n *w);
-
-void (*imprime_elemento)(rb_n *);
-int seta_imprime_elemento(void (*i)(rb_n *n));
-
-
-\end{lstlisting}
-
-\lstinputlisting [linerange={10-15}, firstnumber=10]{../../src/testa_item_1.c}
-Variavel rb\_n com nome y \ref{14}
-% \lstinputlisting {code/del.c}
-% \lstinputlisting {code/utils.c}
-
 \section{}
 \nocite{*}
 \bibliography{mybib.bib}{}
diff --git a/src/checklist.c b/src/checklist.c
index c61a11b..bf32a6b 100644
--- a/src/checklist.c
+++ b/src/checklist.c
@@ -1,3 +1,6 @@
+/*
+ * aluno: joilnen leite
+ */
 #include <stdio.h>
 #include <string.h>
 #include "conjunto_ordenado.h"
diff --git a/src/checklist.h b/src/checklist.h
index aaf3a24..eff8fe0 100644
--- a/src/checklist.h
+++ b/src/checklist.h
@@ -1,3 +1,6 @@
+/*
+ * aluno: joilnen leite
+ */
 #ifndef CHECKLIST_H_
 #define CHECKLIST_H_
 
diff --git a/src/conjunto_ordenado.c b/src/conjunto_ordenado.c
index 703f958..df17495 100644
--- a/src/conjunto_ordenado.c
+++ b/src/conjunto_ordenado.c
@@ -1,3 +1,6 @@
+/*
+ * aluno: joilnen leite
+ */
 #include <stdio.h>
 #include <string.h>
 #include <math.h>
diff --git a/src/conjunto_ordenado.h b/src/conjunto_ordenado.h
index ca7663e..814d345 100644
--- a/src/conjunto_ordenado.h
+++ b/src/conjunto_ordenado.h
@@ -1,9 +1,8 @@
-#ifndef CONJUNTO_ORDENADO_H
-#define CONJUNTO_ORDENADO_H
-
 /*
  * aluno: joilnen leite
  */
+#ifndef CONJUNTO_ORDENADO_H
+#define CONJUNTO_ORDENADO_H
 
 #include "jcurses.h"
 #include "red_black.h"
diff --git a/src/red_black.h b/src/red_black.h
index a4143c7..2f44c53 100644
--- a/src/red_black.h
+++ b/src/red_black.h
@@ -1,9 +1,9 @@
-#ifndef REDBLACK_H
-#define REDBLACK_H
-
 /*
  * aluno: joilnen leite
  */
+#ifndef REDBLACK_H
+#define REDBLACK_H
+
 #include <stdlib.h>
 
 /**
diff --git a/src/testa.h b/src/testa.h
index dcff849..8c63171 100644
--- a/src/testa.h
+++ b/src/testa.h
@@ -1,9 +1,8 @@
-#ifndef TESTA_H_
-#define TESTA_H_
-
 /*
  * aluno: joilnen leite
  */
+#ifndef TESTA_H_
+#define TESTA_H_
 
 #include "jcurses.h"
 #include "testa_item_1.h"
diff --git a/src/testa_item_1.c b/src/testa_item_1.c
index 257f24c..90b33c2 100644
--- a/src/testa_item_1.c
+++ b/src/testa_item_1.c
@@ -1,3 +1,7 @@
+/*
+ * aluno: joilnen leite
+ */
+
 #include <stdio.h>
 #include <string.h>
 #include <time.h>
diff --git a/src/testa_item_1.h b/src/testa_item_1.h
index d22ff07..96af165 100644
--- a/src/testa_item_1.h
+++ b/src/testa_item_1.h
@@ -1,3 +1,7 @@
+/*
+ * aluno: joilnen leite
+ */
+
 #ifndef TESTA_ITEM_1_H_
 #define TESTA_ITEM_1_H_
 
diff --git a/src/testa_item_2.c b/src/testa_item_2.c
index fdf73b4..a100d92 100644
--- a/src/testa_item_2.c
+++ b/src/testa_item_2.c
@@ -1,3 +1,7 @@
+/*
+ * aluno: joilnen leite
+ */
+
 #include <stdio.h>
 #include <string.h>
 #include <time.h>
diff --git a/src/testa_item_2.h b/src/testa_item_2.h
index 3544916..9999fbc 100644
--- a/src/testa_item_2.h
+++ b/src/testa_item_2.h
@@ -1,10 +1,10 @@
-#ifndef TESTA_ITEM_2_H_
-#define TESTA_ITEM_2_H_
-
 /*
  * aluno: joilnen leite
  */
 
+#ifndef TESTA_ITEM_2_H_
+#define TESTA_ITEM_2_H_
+
 void tela_item_2(const char *m);
 void testa_item_2(const char *m);
 
diff --git a/src/testa_item_3.c b/src/testa_item_3.c
index a648ccf..cb696a9 100644
--- a/src/testa_item_3.c
+++ b/src/testa_item_3.c
@@ -1,15 +1,13 @@
+/*
+ * aluno: joilnen leite
+ */
+
 #include <stdio.h>
 #include <string.h>
 #include <time.h>
 #include "conjunto_ordenado.h"
 #include "testa.h"
-/*
- * aluno: joilnen leite
- */
 
-/*
- * aluno: joilnen leite
- */
 static void imprime_meu_tipo(void *);
 
 typedef struct
diff --git a/src/testa_item_3.h b/src/testa_item_3.h
index 30f724e..513ce0c 100644
--- a/src/testa_item_3.h
+++ b/src/testa_item_3.h
@@ -1,10 +1,10 @@
-#ifndef TESTA_ITEM_3_H_
-#define TESTA_ITEM_3_H_
-
 /*
  * aluno: joilnen leite
  */
 
+#ifndef TESTA_ITEM_3_H_
+
+#define TESTA_ITEM_3_H_
 void tela_item_3(const char *m);
 void testa_item_3(const char *m);
 
diff --git a/src/testa_rb.h b/src/testa_rb.h
index 8224693..7553bea 100644
--- a/src/testa_rb.h
+++ b/src/testa_rb.h
@@ -1,10 +1,10 @@
-#ifndef TESTA_ARVORE_RB_
-#define TESTA_ARVORE_RB_
-
 /*
  * aluno: joilnen leite
  */
 
+#ifndef TESTA_ARVORE_RB_
+#define TESTA_ARVORE_RB_
+
 /**
  * declaracao da funcao de teste da 
  * arvore vermelha e preta

commit 012746b1ab981a56b821cb48f017d1e1e7b63ab0
Author: Joilnen <joilnen@gmail.com>
Date:   Tue Jan 18 11:43:03 2022 -0300

    melhorando a documentacao

diff --git a/doc/tex/relatorio.pdf b/doc/tex/relatorio.pdf
index 57c96a7..401927c 100644
Binary files a/doc/tex/relatorio.pdf and b/doc/tex/relatorio.pdf differ
diff --git a/doc/tex/relatorio.tex b/doc/tex/relatorio.tex
index 88f5221..1134f59 100644
--- a/doc/tex/relatorio.tex
+++ b/doc/tex/relatorio.tex
@@ -432,6 +432,7 @@ que são representativos de uma rotação a esquerda e não árvores completas.\
 \end{tcolorbox}
 \ \\
 \ \\
+\section {Inserção na Árvore Red-Black}
 \noindent Podemos agora entender melhor o funcionamento da função \enf{rb_insert}.
 \lstinputlisting [firstnumber=43, linerange={43-145}, caption = {Fragmento do red_black.c}]{../../src/red_black.c}
 
@@ -703,63 +704,54 @@ Então chega-se ao \enf{caso 3}, \enf{z} em linha com o nó pai, ambos vermelhos
         \end{tikzpicture}
     \end{minipage}
 \end{tcolorbox}
-\enf{conjunto_ordenado.h} é o arquivo cabeçalho que deverá ser incluído no código 
-fonte do cliente, \enf{conjunto_ordenado.c} onde estão implementados as funções,
-\enf{red_black.h} e \enf{red_black.c}, cabeçalho e implementações da estrutura
-de dados, árvore red-black e \enf{jcurses.h} um arquivo com macros auxiliares 
-de impressao e formatação de saida na tela.
-
-sendo necessário apenas para seu uso a inclusão via, \\
-O TAD \enf{conjord} é a abstração mais alta, representando conjunto, a qual o código 
-cliente tem acesso e suas respectivas funções.
-\enf{\#include "conjunto\_ordenado.h"} onde se encontra declarado, sendo definido em \\
-\enf{"conjunto\_ordenado.c"}, o TAD \footnote{Tipo Abstrato de Dados} 
-\enf{conjord} que oculta do código cliente e manipula internamente a estrutura de dados
-red black \enf{"struct rb\_n"} aqui neste trabalho, declarada em \enf{red\_black.h} e definida em 
-\enf{red\_black.c} 
-
-Além da convencional inclusão e compilação, o usuário da biblioteca, pessoa
-que escreve o programa cliente, aqui neste trabalho exemplificado pelo os arquivos \\
-\enf{main.c} \\
-\enf{test\_tree.c} \\
-deverá escolher definir seu tipo dado, através de uma struct ou utilizar um tipo de dado nativo da 
-linguagem.
-\renewcommand{\lstlistingname}{Fonte}
-\begin{lstlisting}[caption={Exemplo do uso da biblioteca conjunto_ordenado}]
-#include "conjunto_ordenado.h"
-
-int main()
-{
-    typedef struct {
-        char *nome;
-        char *telefone;
-    } meu_tipo;
-    meu_tipo mt0, mt1;
-    mt0.nome = (char *) malloc(sizeof("nome para teste") + 1);
-    strncpy(mt0.nome, "nome para teste", sizeof("nome para teste") + 1);
-    mt0.telefone = (char *) malloc(sizeof("999999999") + 1);
-    strncpy(mt0.telefone, "999999999", sizeof("999999999") + 1);
-
-    seta_imprime_elemento(imprime_meu_tipo);
-
-    CRIA_CONJUNTO_ORDENDADO(conjunto_a, 10, mt0);
-    mt1.nome = (char *) malloc(sizeof("nome para teste") + 1);
-    strncpy(mt1.nome, "nome para teste", sizeof("nome para teste") + 1);
-    mt1.telefone = (char *) malloc(sizeof("999999999") + 1);
-    strncpy(mt1.telefone, "999999999", sizeof("999999999") + 1);
-
-    insere_elemento(&conjunto_a, 9, &mt1);
-}
-\end{lstlisting}
 
-\section{Lista de Estruturas e Funções Implementadas}
-Como foi especificado a estrutura de dados utilizada para guardar os dados neste projeto 
+\section {Deleção na Árvore Red-Black}
+\lstinputlisting [firstnumber=147, linerange={147-191}, caption = {Fragmento do red_black.c}]{../../src/red_black.c}
+
+A deleção faz uso de outras funções que abordamos agora, a primeira delas é a \enf{rb_transplant}, 
+linha 152, ela basicamente põe o nó \enf{v} no lugar do nó \enf{u}, na linha 154, é verificado 
+se o nó \enf{u} é raíz, checando se este aponta ponteiro pai para nó sentinela, caso sim, 
+faz nó raíz apontado por \enf{t} apontar para \enf{u}.
+Os outras decições apenas colocam \enf{v} do lado esquerdo ou direito de acordo com a posição de 
+\enf{u}.
+O \enf{if} final checa se nó raíz é válido e por fim atualiza pai
+de \enf{v}, o novo nó, com pai de \enf{u}.
+
+
+A função a seguir a analisármos é a \enf{tree_minimum}, linha 171,  este nome segue a
+bibliografia, essa
+função é um loop que itera de um nó qualquer até sua folha mais a esquerda, ela é importante
+para se encontra o sucessor de um nó.
+
+E em seguida \enf{sucessor}, que usa o resultado da \enf{tree_minimum}, essa função é interessante,
+ela trata quando o nó em questão não tem subárvore a direita, logo o sucessor não é possível
+fazendo, \enf{tree_minimum} de nó a direita, então o \enf{while}, linha 188, itera subindo 
+aos nós pais e atualizando \enf{x} com nó direita de \enf{y} e \enf{y} com o pai de \enf{x},
+\enf{x}, aqui funciona como nó temporário, e \enf{y} conterá o resultado esperado
+o último desta iteração, como diz a função a intenção aqui é retornar o nó sucessor do 
+nó pesquisado, que em alguns contexto é igual ao nó mais esquerda do nó a direita, por isso
+a relação desta função com \enf{tree_minimum}.
+
+Após estas funções podemos analisar melhor a função de deleção, junto com a insersão, os 
+dois pontos nevralgicos no algoritmo, árvore vermelha e preta.
+
+A deleção neste trabalho, foi primeiramente implementada, sem nós sentinelas, caso se 
+interesse por esse processo de desenvolvimento, no apêndice está o histórico de cada linha 
+de código escrita, mas nesse tipo de árvore o nó sentinela tem um papel importante e facilita
+o funcionamento, boa parte da lógica aqui é a iteração pelo nó pai, tando partindo das folhas
+como com relação ao nó raíz, e sem nó sentinela essa ação
+é mais complexa, especificamente na deleção.
+\lstinputlisting [firstnumber=193, linerange={193-312}, caption = {Fragmento do red_black.c}]{../../src/red_black.c}
+
+
+\section{Lista de Estruturas e Funções Implementadas} Como foi especificado a estrutura de dados utilizada para guardar os dados neste projeto 
 é a árvore binária de busca Red Black, no código esta árvore e seus nós são representados
 pela estrutura \enf{rb_n}\footnote{Red Black Node ou nó Red Black}, a semântica escolhida
 é a seguinte, representamos apenas os nós e seus relacionamentos, a árvore completa fica
 referenciada no ato da criação do nó raiz no código cliente, logo no exemplo acima
 temos uma árvore nomeada \enf{conjunto_a}, enquanto nós filhos nessa árvore é adicionado 
 com \enf{insere_elemento}
+
 \ \\
 \section{}
 \nocite{*}
